<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mason Efficiency Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Barlow+Semi+Condensed:wght@400;600;700;800&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f5f5;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            padding: 0;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1), 0 12px 40px rgba(0,0,0,0.15);
            overflow: hidden;
        }
        
        .header {
            display: flex;
            align-items: stretch;
            margin-bottom: 0;
            border-radius: 12px 12px 0 0;
            overflow: hidden;
            min-height: 100px;
            position: relative;
            z-index: 10;
            box-shadow: 0 6px 16px rgba(0,0,0,0.25), 0 12px 32px rgba(0,0,0,0.15);
        }
        
        .header-left {
            background: #2D3436;
            color: white;
            flex: 0 0 70%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            padding: 25px 60px 25px 30px;
            position: relative;
            z-index: 1;
        }
        
        .header-left::after {
            content: '';
            position: absolute;
            top: 0;
            right: -40px;
            width: 80px;
            height: 100%;
            background: #2D3436;
            transform: skewX(-17deg);
            z-index: 1;
        }
        
        .header-left h1 {
            font-family: 'Barlow Semi Condensed', sans-serif;
            font-size: 2.2rem;
            margin: 0 0 6px 0;
            font-weight: 700;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            text-shadow: 0 1px 3px rgba(0,0,0,0.15);
        }
        
        .header-left p {
            font-size: 1.05rem;
            opacity: 0.7;
            margin: 0;
            text-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .header-right {
            background: white;
            flex: 0 0 30%;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding: 20px 30px 20px 60px;
        }
        
        .header-right img {
            max-height: 60px;
            width: auto;
        }

        .user-bar {
            background: #CC0000;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-radius: 0 0 10px 10px;
            margin-top: -10px;
            margin-bottom: 0;
            font-size: 0.9rem;
            position: relative;
            z-index: 9;
            min-height: 52px;
            padding: 22px 16px 14px 16px;
            box-shadow: 0 6px 16px rgba(0,0,0,0.25), 0 12px 32px rgba(0,0,0,0.15);
        }

        .user-bar .user-info {
            display: flex;
            align-items: center;
            gap: 10px;
            color: white;
        }

        .user-bar .user-icon {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: white;
            overflow: hidden;
            flex-shrink: 0;
        }

        .user-bar .user-icon img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            object-position: top;
        }

        .user-bar .user-info strong {
            font-weight: 700;
            color: white;
            font-size: 0.95rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            text-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        .settings-wrapper {
            position: relative;
        }

        .btn-settings {
            background: none;
            border: none;
            cursor: pointer;
            padding: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background 0.2s;
        }

        .btn-settings:hover {
            background: rgba(255,255,255,0.15);
        }

        .btn-settings svg {
            width: 22px;
            height: 22px;
            fill: white;
        }

        .settings-dropdown {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 6px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.15);
            min-width: 160px;
            z-index: 1000;
            overflow: hidden;
        }

        .settings-dropdown.open {
            display: block;
        }

        .settings-dropdown button {
            display: flex;
            align-items: center;
            gap: 10px;
            width: 100%;
            padding: 12px 16px;
            border: none;
            background: none;
            cursor: pointer;
            font-size: 0.85rem;
            font-family: inherit;
            color: #2D3436;
            transition: background 0.15s;
        }

        .settings-dropdown button:hover {
            background: #f5f5f5;
        }

        .settings-dropdown button svg {
            width: 16px;
            height: 16px;
            fill: #636E72;
        }

        .settings-dropdown button.danger {
            color: #CC0000;
        }

        .settings-dropdown button.danger svg {
            fill: #CC0000;
        }
        
        .controls {
            background: white;
            padding: 24px 20px 20px 20px;
            border-radius: 0;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            margin-top: -10px;
            margin-bottom: 0;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
            position: relative;
            z-index: 8;
        }
        
        .tabs {
            display: flex;
            background: white;
            border-radius: 0;
            box-shadow: none;
            margin-top: -10px;
            margin-bottom: 0;
            overflow: hidden;
            position: relative;
            z-index: 7;
            padding-top: 10px;
        }
        
        .tab-button {
            flex: 1;
            padding: 15px 20px;
            background: #f5f5f5;
            border: none;
            cursor: pointer;
            font-family: 'Barlow Semi Condensed', sans-serif;
            font-size: 1rem;
            font-weight: 600;
            color: #666;
            transition: all 0.3s;
            border-bottom: 3px solid transparent;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .tab-button:hover {
            background: #e8e8e8;
        }
        
        .tab-button.active {
            background: white;
            color: #2D3436;
            border-bottom-color: #CC0000;
        }
        
        .tab-content {
            display: none;
            background: white;
            padding: 20px;
            border-radius: 0;
            box-shadow: none;
            position: relative;
            z-index: 6;
        }
        
        .tab-content.active {
            display: block;
        }
        
        #map {
            width: 100%;
            height: 600px;
            border-radius: 8px;
        }
        
        .map-controls {
            margin-bottom: 15px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .map-controls button {
            padding: 8px 16px;
            background: #2D3436;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
        }
        
        .map-controls button:hover {
            background: #444;
        }
        
        .controls label {
            font-weight: 600;
            color: #333;
        }
        
        .controls select, .controls button {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 1px 4px rgba(0,0,0,0.1);
        }
        
        .controls select {
            background: white;
        }
        
        .controls button {
            background: #E0E0E0;
            color: white;
            font-weight: 600;
        }
        
        .controls button:hover {
            background: #D0D0D0;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .stat-card {
            background: white;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08), 0 8px 24px rgba(0,0,0,0.12);
            text-align: center;
            transition: transform 0.3s;
        }
        
        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1), 0 12px 32px rgba(0,0,0,0.18);
        }
        
        .stat-card h3 {
            font-family: 'Barlow Semi Condensed', sans-serif;
            color: #555;
            font-size: 0.9rem;
            text-transform: uppercase;
            margin-bottom: 10px;
            letter-spacing: 1px;
            font-weight: 600;
        }
        
        .stat-card .value {
            font-family: 'Barlow Semi Condensed', sans-serif;
            font-size: 2.5rem;
            font-weight: 700;
            color: #333;
            margin-bottom: 5px;
        }
        
        .stat-card .label {
            color: #666;
            font-size: 0.9rem;
        }
        
        .chart-container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08), 0 8px 24px rgba(0,0,0,0.12);
            margin-bottom: 20px;
        }
        
        .chart-container h2 {
            font-family: 'Barlow Semi Condensed', sans-serif;
            color: #333;
            margin-bottom: 20px;
            text-align: center;
            font-weight: 700;
            letter-spacing: 0.5px;
            text-transform: uppercase;
        }
        
        .chart-wrapper {
            position: relative;
            height: 400px;
        }
        
        .last-updated {
            text-align: center;
            color: #888;
            font-size: 0.9rem;
            opacity: 0.8;
            margin-top: -6px;
            padding-top: 20px;
            position: relative;
            z-index: 5;
        }
        
        .loading {
            text-align: center;
            color: #666;
            font-size: 1.2rem;
            padding: 50px;
        }
        
        .error {
            background: #ff6b6b;
            color: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            margin-bottom: 20px;
        }
        
        .mason-select-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .refresh-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #4ade80;
            margin-left: 10px;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            animation: fadeIn 0.3s;
        }
        
        .modal.show {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            max-width: 500px;
            width: 90%;
            animation: slideIn 0.3s;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes slideIn {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        .modal-content h2 {
            font-family: 'Barlow Semi Condensed', sans-serif;
            color: #2D3436;
            margin-bottom: 20px;
            text-align: center;
            font-weight: 700;
            letter-spacing: 0.5px;
            text-transform: uppercase;
        }
        
        .modal-field {
            margin-bottom: 20px;
        }
        
        .modal-field label {
            display: block;
            color: #333;
            font-weight: 600;
            margin-bottom: 8px;
        }
        
        .modal-field select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1rem;
            background: white;
            cursor: pointer;
            transition: border-color 0.3s;
        }
        
        .modal-field select:focus {
            outline: none;
            border-color: #2D3436;
        }
        
        .modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 25px;
        }
        
        .modal-buttons button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .modal-buttons .btn-generate {
            background: #2D3436;
            color: white;
        }
        
        .modal-buttons .btn-generate:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .modal-buttons .btn-cancel {
            background: #e0e0e0;
            color: #666;
        }
        
        .modal-buttons .btn-cancel:hover {
            background: #d0d0d0;
        }
        
        .placement-log {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08), 0 8px 24px rgba(0,0,0,0.12);
            margin-bottom: 20px;
            max-height: 500px;
            overflow-y: auto;
        }
        
        .placement-log h2 {
            font-family: 'Barlow Semi Condensed', sans-serif;
            color: #333;
            margin-bottom: 20px;
            text-align: center;
            font-weight: 700;
            letter-spacing: 0.5px;
            text-transform: uppercase;
        }
        
        .placement-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            border-bottom: 1px solid #e0e0e0;
            transition: background 0.2s;
        }
        
        .placement-item:hover {
            background: #f5f5f5;
        }
        
        .placement-item:last-child {
            border-bottom: none;
        }
        
        .placement-item.new {
            animation: highlight 1s;
        }
        
        @keyframes highlight {
            0% { background: #4ade80; }
            100% { background: transparent; }
        }
        
        .placement-timestamp {
            font-family: 'Courier New', monospace;
            color: #333;
            font-weight: bold;
            font-size: 0.95rem;
        }
        
        .placement-details {
            display: flex;
            gap: 20px;
            align-items: center;
        }
        
        .placement-mason {
            color: #2D3436;
            font-weight: 600;
        }
        
        .placement-brick {
            color: #666;
            font-size: 0.9rem;
            font-family: 'Courier New', monospace;
        }
        
        .no-placements {
            text-align: center;
            color: #999;
            padding: 40px;
            font-style: italic;
        }

        /* Banner build-down animation — matches the Android app cascade */
        @keyframes bannerSlideDown {
            0% {
                opacity: 0;
                transform: translateY(-40px) scaleY(0.96);
            }
            40% {
                opacity: 0.7;
                transform: translateY(-8px) scaleY(0.99);
            }
            100% {
                opacity: 1;
                transform: translateY(0) scaleY(1);
            }
        }

        .header,
        .user-bar,
        .controls,
        .tabs,
        .stats-grid {
            will-change: transform, opacity;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            transform-origin: top center;
            animation-fill-mode: both;
            animation-timing-function: cubic-bezier(0, 0, 0.2, 1); /* Material decelerate */
            animation-name: bannerSlideDown;
        }

        .header {
            animation-duration: 0.35s;
            animation-delay: 0s;
        }

        .user-bar {
            animation-duration: 0.38s;
            animation-delay: 0.12s;
        }

        .controls {
            animation-duration: 0.41s;
            animation-delay: 0.24s;
        }

        .tabs {
            animation-duration: 0.44s;
            animation-delay: 0.36s;
        }

        .stats-grid {
            animation-duration: 0.47s;
            animation-delay: 0.48s;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="header-left">
                <h1 id="dashboardTitle">Efficiency Dashboard</h1>
                <p>Real-time performance insights</p>
            </div>
            <div class="header-right">
                <img src="cr_logo.png" alt="Construction Robotics">
            </div>
        </div>

        <div class="user-bar">
            <span class="user-info">
                <span class="user-icon">
                    <img src="usericon.png" alt="User">
                </span>
                <strong id="currentUserDisplay">—</strong>
            </span>
            <div class="settings-wrapper">
                <button class="btn-settings" onclick="toggleSettingsMenu()" title="Account Settings">
                    <svg viewBox="0 0 24 24"><path d="M19.14 12.94c.04-.31.06-.63.06-.94 0-.31-.02-.63-.06-.94l2.03-1.58a.49.49 0 00.12-.61l-1.92-3.32a.49.49 0 00-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54a.484.484 0 00-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96a.49.49 0 00-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.04.31-.06.63-.06.94s.02.63.06.94l-2.03 1.58a.49.49 0 00-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6A3.6 3.6 0 1112 8.4a3.6 3.6 0 010 7.2z"/></svg>
                </button>
                <div class="settings-dropdown" id="settingsDropdown">
                    <button id="manageUsersBtn" onclick="openManageUsers()" style="display: none;">
                        <svg viewBox="0 0 24 24"><path d="M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5C6.34 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z"/></svg>
                        Manage Users
                    </button>
                    <button onclick="logout()" class="danger">
                        <svg viewBox="0 0 24 24"><path d="M17 7l-1.41 1.41L18.17 11H8v2h10.17l-2.58 2.58L17 17l5-5zM4 5h8V3H4c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h8v-2H4V5z"/></svg>
                        Sign Out
                    </button>
                </div>
            </div>
        </div>
        
        <div class="controls">
            <div class="mason-select-group">
                <label for="masonSelect">User</label>
                <select id="masonSelect">
                    <option value="">Loading...</option>
                </select>
            </div>
            <button onclick="showReportModal()" style="background: #636E72; margin-left: auto;">
                Create Performance Review
            </button>
        </div>
        
        <!-- Performance Review Modal -->
        <div id="reportModal" class="modal">
            <div class="modal-content">
                <h2>Generate Performance Review</h2>
                <div class="modal-field">
                    <label for="modalMasonSelect">User</label>
                    <select id="modalMasonSelect">
                        <option value="ALL">All Users</option>
                    </select>
                </div>
                <div class="modal-field">
                    <label for="modalPeriodSelect">Time Period:</label>
                    <select id="modalPeriodSelect">
                        <option value="1">Today</option>
                        <option value="7">Last 7 Days</option>
                        <option value="30" selected>Last 30 Days</option>
                        <option value="90">Last 90 Days (Quarterly)</option>
                        <option value="365">Last Year</option>
                        <option value="all">All Time</option>
                    </select>
                </div>
                <div class="modal-buttons">
                    <button class="btn-cancel" onclick="closeReportModal()">Cancel</button>
                    <button class="btn-generate" onclick="generateReport()">Generate Report</button>
                </div>
            </div>
        </div>
        
        <div id="error" class="error" style="display: none;"></div>
        
        <div id="loading" class="loading">Loading dashboard data...</div>
        
        <div id="dashboard" style="display: none; margin-top: -10px; position: relative; z-index: 7;">
            <!-- Tab Navigation -->
            <div class="tabs">
                <button class="tab-button active" onclick="switchTab('overview')">Overview</button>
                <button class="tab-button" onclick="switchTab('map')">Map View</button>
            </div>
            
            <!-- Overview Tab -->
            <div id="overview-tab" class="tab-content active">
            <div class="stats-grid">
                <div class="stat-card">
                    <h3>Total Placements</h3>
                    <div class="value" id="totalPlacements">0</div>
                </div>
                <div class="stat-card">
                    <h3>Days Worked</h3>
                    <div class="value" id="daysWorked">0</div>
                </div>
                <div class="stat-card">
                    <h3>Average Per Day</h3>
                    <div class="value" id="avgPerDay">0</div>
                </div>
                <div class="stat-card">
                    <h3>Current Efficiency</h3>
                    <div class="value" id="currentEfficiency">0</div>
                </div>
            </div>
            
            <div class="chart-container">
                <h2>Live Placements Timeline</h2>
                <div class="chart-wrapper">
                    <canvas id="liveChart"></canvas>
                </div>
            </div>
            
            <div class="chart-container">
                <h2>Daily Placement Totals</h2>
                <div class="chart-wrapper">
                    <canvas id="dailyChart"></canvas>
                </div>
            </div>
            
            <div class="placement-log">
                <h2>Live Placement Log</h2>
                <div id="placementLog">
                    <div class="no-placements">Loading placements...</div>
                </div>
            </div>
            </div>
            
            <!-- Map Tab -->
            <div id="map-tab" class="tab-content">
                <h2 style="margin-bottom: 15px;">Placement Locations</h2>
                <div class="map-controls">
                    <button onclick="fitMapBounds()">Fit All Markers</button>
                    <button onclick="refreshMapData()">Refresh Map</button>
                </div>
                <div id="map"></div>
            </div>
            
            <!-- Manage Users Tab (admin only) -->
            <div id="manage-users-tab" class="tab-content">
                <h2 style="margin-bottom: 15px;">User Management</h2>

                <div style="overflow-x: auto;">
                    <table id="userManagementTable" style="width: 100%; border-collapse: collapse; font-size: 0.95rem;">
                        <thead>
                            <tr style="background: #2D3436; color: white; text-align: left;">
                                <th style="padding: 12px 16px;">Username</th>
                                <th style="padding: 12px 16px;">Mason ID</th>
                                <th style="padding: 12px 16px;">Company</th>
                                <th style="padding: 12px 16px;">Role</th>
                                <th style="padding: 12px 16px;">Actions</th>
                            </tr>
                        </thead>
                        <tbody id="userManagementBody">
                            <tr><td colspan="5" style="padding: 20px; text-align: center; color: #999;">Loading users...</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
        
        <div class="last-updated">
            Last updated: <span id="lastUpdated">Never</span>
        </div>
    </div>
    
    <script>
        // XSS sanitization helper
        function escapeHtml(str) {
            if (str === null || str === undefined) return '';
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
        }

        const API_BASE = window.location.origin;
        let authToken = localStorage.getItem('dashboard_token');
        let liveChart = null;
        let dailyChart = null;
        let currentMasonId = null;
        let allMasons = [];
        let refreshInterval = null;
        let lastPlacementIds = new Set();
        let allPlacements = [];
        let lastPlacementCount = 0;
        let isUpdating = false;
        
        // Role awareness
        const userRole = localStorage.getItem('dashboard_role') || 'user';
        const isSuperAdmin = localStorage.getItem('dashboard_isSuperAdmin') === 'true';
        const isCompanyAdmin = localStorage.getItem('dashboard_isCompanyAdmin') === 'true';
        const isAnyAdmin = isSuperAdmin || isCompanyAdmin;
        const userCompanyRaw = localStorage.getItem('dashboard_company');
        const userCompany = userCompanyRaw ? JSON.parse(userCompanyRaw) : null;
        
        // Redirect to login page if not authenticated
        if (!authToken) {
            window.location.href = '/';
        }

        // Show current user in the user bar (with role badge)
        const currentUser = localStorage.getItem('dashboard_user');
        if (currentUser) {
            let displayText = currentUser;
            if (isSuperAdmin) {
                displayText += ' (Super Admin)';
            } else if (isCompanyAdmin) {
                displayText += ' (Company Admin)';
            }
            document.getElementById('currentUserDisplay').textContent = displayText;
        }

        // Authenticated fetch wrapper — attaches Bearer token to all API calls
        async function authFetch(url, options = {}) {
            if (!authToken) {
                window.location.href = '/';
                throw new Error('Not authenticated');
            }
            const headers = { ...(options.headers || {}), 'Authorization': `Bearer ${authToken}` };
            let response = await fetch(url, { ...options, headers });
            // If token expired, redirect to login
            if (response.status === 401) {
                logout();
                throw new Error('Session expired');
            }
            return response;
        }

        // Logout — clear all stored auth data and redirect to login
        function logout() {
            localStorage.removeItem('dashboard_token');
            localStorage.removeItem('dashboard_user');
            localStorage.removeItem('dashboard_pass');
            localStorage.removeItem('dashboard_masonId');
            localStorage.removeItem('dashboard_isAdmin');
            localStorage.removeItem('dashboard_role');
            localStorage.removeItem('dashboard_isSuperAdmin');
            localStorage.removeItem('dashboard_isCompanyAdmin');
            localStorage.removeItem('dashboard_company');
            window.location.href = '/';
        }

        // Settings cog dropdown
        function toggleSettingsMenu() {
            document.getElementById('settingsDropdown').classList.toggle('open');
        }

        // Open Manage Users tab from cog menu
        function openManageUsers() {
            document.getElementById('settingsDropdown').classList.remove('open');
            switchTab('manage-users');
        }

        document.addEventListener('click', function(e) {
            const wrapper = document.querySelector('.settings-wrapper');
            if (wrapper && !wrapper.contains(e.target)) {
                document.getElementById('settingsDropdown').classList.remove('open');
            }
        });
        
        // Map variables
        let map = null;
        let markers = [];
        let markerGroup = null;
        let wallPolygons = [];
        
        // Color palette for different masons
        const masonColors = [
            '#FF0000', '#0066FF', '#00CC00', '#FF6600', 
            '#AA00FF', '#00CCCC', '#FF00AA', '#CCCC00',
            '#FF3399', '#00FF66', '#3366FF', '#FF9900'
        ];
        
        // Helper function to get consistent color for a mason
        function getMasonColor(masonId, allMasonIds = null) {
            // If we have all mason IDs, use them for consistent ordering
            if (allMasonIds) {
                const sortedMasons = [...allMasonIds].sort();
                const index = sortedMasons.indexOf(masonId);
                return index >= 0 ? masonColors[index % masonColors.length] : '#CC0000';
            }
            // Fallback: get unique masons from allPlacements
            if (allPlacements.length > 0) {
                const sortedMasons = [...new Set(allPlacements.map(p => p.mason_id || p.masonId))].sort();
                const index = sortedMasons.indexOf(masonId);
                return index >= 0 ? masonColors[index % masonColors.length] : '#CC0000';
            }
            return '#CC0000';
        }
        
        // Clustering parameters
        const WALL_CLUSTER_DISTANCE = 10; // meters - scans within 10m are part of same wall
        const MIN_WALL_SIZE = 3; // minimum 3 scans to form a wall
        const TIME_WINDOW = 24 * 60 * 60 * 1000; // 24 hours - placements within this time are more likely same wall
        
        // Tab switching function
        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            // Highlight the matching tab button if one exists (manage-users has no tab button)
            const matchingBtn = document.querySelector(`.tab-button[onclick*="'${tabName}'"]`);
            if (matchingBtn) {
                matchingBtn.classList.add('active');
            }
            
            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(tabName + '-tab').classList.add('active');
            
            // Initialize map when switching to map tab
            if (tabName === 'map' && !map) {
                setTimeout(() => initializeMap(), 100);
            }
        }
        
        // Initialize Leaflet Map
        async function initializeMap() {
            const mapDiv = document.getElementById('map');
            if (!mapDiv || map) return;
            
            // Create map centered on USA
            map = L.map('map').setView([39.8283, -98.5795], 4);
            
            // Add OpenStreetMap tiles (free, no API key needed)
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: 'Â© OpenStreetMap contributors',
                maxZoom: 19
            }).addTo(map);
            
            // Create marker group for easy management
            markerGroup = L.layerGroup().addTo(map);
            
            loadMapData();
        }
        
        // Load placement data for map
        async function loadMapData() {
            try {
                const masonId = document.getElementById('masonSelect').value;
                const url = masonId ? 
                    `${API_BASE}/api/placements/mason/${masonId}` : 
                    `${API_BASE}/api/placements/recent?limit=500`;
                
                const response = await authFetch(url);
                const data = await response.json();
                
                if (data.success && data.placements) {
                    updateMapWithWalls(data.placements);
                }
            } catch (error) {
                console.error('Error loading map data:', error);
            }
        }
        
        // Calculate distance between two GPS points in meters
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371e3; // Earth radius in meters
            const phi1 = lat1 * Math.PI / 180;
            const phi2 = lat2 * Math.PI / 180;
            const dPhi = (lat2 - lat1) * Math.PI / 180;
            const dLambda = (lon2 - lon1) * Math.PI / 180;
            
            const a = Math.sin(dPhi/2) * Math.sin(dPhi/2) +
                    Math.cos(phi1) * Math.cos(phi2) *
                    Math.sin(dLambda/2) * Math.sin(dLambda/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            
            return R * c;
        }
        
        // Calculate bearing (direction) between two GPS points in degrees (0-360)
        function calculateBearing(lat1, lon1, lat2, lon2) {
            const phi1 = lat1 * Math.PI / 180;
            const phi2 = lat2 * Math.PI / 180;
            const dLambda = (lon2 - lon1) * Math.PI / 180;
            
            const y = Math.sin(dLambda) * Math.cos(phi2);
            const x = Math.cos(phi1) * Math.sin(phi2) -
                    Math.sin(phi1) * Math.cos(phi2) * Math.cos(dLambda);
            const theta = Math.atan2(y, x);
            
            return (theta * 180 / Math.PI + 360) % 360; // Normalize to 0-360
        }
        
        // Calculate the smallest angle difference between two bearings
        function angleDifference(bearing1, bearing2) {
            let diff = Math.abs(bearing1 - bearing2);
            if (diff > 180) diff = 360 - diff;
            return diff;
        }
        
        // Calculate average bearing for a cluster of placements
        function calculateClusterBearing(placements) {
            if (placements.length < 2) return null;
            
            let sumSin = 0, sumCos = 0;
            let count = 0;
            
            // Calculate bearings between consecutive points
            for (let i = 0; i < placements.length - 1; i++) {
                const bearing = calculateBearing(
                    placements[i].latitude, placements[i].longitude,
                    placements[i + 1].latitude, placements[i + 1].longitude
                );
                sumSin += Math.sin(bearing * Math.PI / 180);
                sumCos += Math.cos(bearing * Math.PI / 180);
                count++;
            }
            
            if (count === 0) return null;
            
            const avgBearing = Math.atan2(sumSin / count, sumCos / count) * 180 / Math.PI;
            return (avgBearing + 360) % 360;
        }
        
        // Split a cluster into sub-clusters based on wall direction/orientation
        // Helps separate walls that are close but face different directions
        function splitByDirection(cluster) {
            if (cluster.length < 3) return [cluster]; // Too small to determine direction
            
            const MAX_BEARING_DIFF = 45; // degrees - walls with >45 degrees difference are separate
            const subclusters = [];
            const used = new Set();
            
            // Sort by timestamp for sequential processing
            const sorted = [...cluster].sort((a, b) => a.timestamp - b.timestamp);
            
            for (let i = 0; i < sorted.length; i++) {
                if (used.has(i)) continue;
                
                const subcluster = [sorted[i]];
                used.add(i);
                
                // Add nearby points with similar bearing
                for (let j = i + 1; j < sorted.length; j++) {
                    if (used.has(j)) continue;
                    
                    // Check if this point fits the current subcluster's direction
                    const testCluster = [...subcluster, sorted[j]];
                    const bearing = calculateClusterBearing(testCluster);
                    
                    if (bearing !== null) {
                        // Check bearing consistency with all points in subcluster
                        let consistent = true;
                        for (let k = 0; k < subcluster.length - 1; k++) {
                            const segmentBearing = calculateBearing(
                                subcluster[k].latitude, subcluster[k].longitude,
                                subcluster[k + 1].latitude, subcluster[k + 1].longitude
                            );
                            if (angleDifference(bearing, segmentBearing) > MAX_BEARING_DIFF) {
                                consistent = false;
                                break;
                            }
                        }
                        
                        if (consistent) {
                            subcluster.push(sorted[j]);
                            used.add(j);
                        }
                    }
                }
                
                subclusters.push(subcluster);
            }
            
            return subclusters;
        }
        
        // Cluster placements into walls using DBSCAN-like algorithm with directional checks
        // Groups placements by proximity, time, AND direction (walls have orientation)
        function clusterIntoWalls(placements) {
            const walls = [];
            const visited = new Set();
            let wallCounter = 1;
            
            // Sort by timestamp to process chronologically
            const sorted = [...placements].sort((a, b) => a.timestamp - b.timestamp);
            
            sorted.forEach((placement, idx) => {
                if (visited.has(idx)) return;
                
                const cluster = [placement];
                const queue = [placement];
                visited.add(idx);
                
                // DBSCAN-like expansion: find all connected neighbors
                while (queue.length > 0) {
                    const current = queue.shift();
                    
                    sorted.forEach((other, otherIdx) => {
                        if (visited.has(otherIdx)) return;
                        
                        const spatialDist = calculateDistance(
                            current.latitude, current.longitude,
                            other.latitude, other.longitude
                        );
                        
                        const temporalDist = Math.abs(current.timestamp - other.timestamp);
                        
                        // Consider both spatial and temporal proximity
                        // Close in space AND reasonably close in time = same wall
                        if (spatialDist <= WALL_CLUSTER_DISTANCE && temporalDist <= TIME_WINDOW) {
                            cluster.push(other);
                            queue.push(other);
                            visited.add(otherIdx);
                        }
                    });
                }
                
                // Split cluster by direction if it has different wall orientations
                const directionClusters = splitByDirection(cluster);
                
                directionClusters.forEach(subCluster => {
                    if (subCluster.length >= MIN_WALL_SIZE) {
                        // Multi-mason wall
                        const masons = [...new Set(subCluster.map(p => p.mason_id || p.masonId))];
                        const brickCounts = {};
                        masons.forEach(m => {
                            brickCounts[m] = subCluster.filter(p => (p.mason_id || p.masonId) === m).length;
                        });
                        
                        walls.push({
                            id: `WALL_${wallCounter++}`,
                            placements: subCluster,
                            masons: masons,
                            brickCounts: brickCounts,
                            isMultiMason: masons.length > 1
                        });
                    } else {
                        // Individual placements (not part of a wall)
                        subCluster.forEach(p => {
                            walls.push({
                                id: null,
                                placements: [p],
                                masons: [p.mason_id || p.masonId],
                                brickCounts: {},
                                isMultiMason: false
                            });
                        });
                    }
                });
            });
            
            return walls;
        }
        
        // Update map with wall visualization
        function updateMapWithWalls(placements) {
            if (!map || !markerGroup) return;
            
            // Clear existing markers and polygons
            markerGroup.clearLayers();
            markers = [];
            wallPolygons.forEach(p => p.remove());
            wallPolygons = [];
            
            // Filter placements with valid GPS
            const validPlacements = placements.filter(p => 
                p.latitude && p.longitude && 
                p.latitude !== 0 && p.longitude !== 0
            );
            
            if (validPlacements.length === 0) {
                alert('No placements with GPS coordinates found');
                return;
            }
            
            // Cluster into walls
            const walls = clusterIntoWalls(validPlacements);
            const bounds = L.latLngBounds();
            const uniqueMasons = [...new Set(validPlacements.map(p => p.mason_id || p.masonId))];
            
            walls.forEach((wall, wallIdx) => {
                if (!wall.id) {
                    // Individual placement (not part of a wall)
                    const p = wall.placements[0];
                    const latlng = [p.latitude, p.longitude];
                    const masonId = p.mason_id || p.masonId;
                    const masonIndex = uniqueMasons.indexOf(masonId);
                    const color = masonIndex >= 0 ? 
                        masonColors[masonIndex % masonColors.length] : 
                        '#CC0000';
                    
                    const icon = L.divIcon({
                        className: 'custom-marker',
                        html: `<div style="background-color: ${color}; width: 16px; height: 16px; border-radius: 50%; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>`,
                        iconSize: [16, 16],
                        iconAnchor: [8, 8]
                    });
                    
                    const marker = L.marker(latlng, { icon: icon });
                    const altitude = p.altitude || 0;
                    const popupContent = `
                        <div style="padding: 10px; font-family: Arial; min-width: 200px;">
                            <h3 style="margin: 0 0 10px 0; color: ${color};">${masonId || 'Unknown Mason'}</h3>
                            <p style="margin: 5px 0;"><strong>RFID:</strong> ${p.rfidTag || p.brickNumber}</p>
                            <p style="margin: 5px 0;"><strong>Time:</strong> ${new Date(p.timestamp).toLocaleString()}</p>
                            <p style="margin: 5px 0;"><strong>Location:</strong> ${p.latitude.toFixed(6)}, ${p.longitude.toFixed(6)}</p>
                            <p style="margin: 5px 0;"><strong>Altitude:</strong> ${altitude.toFixed(1)} m</p>
                            <p style="margin: 5px 0;"><strong>Accuracy:</strong> Â±${p.accuracy ? p.accuracy.toFixed(1) : '999'} m</p>
                            ${p.rssiAvg ? `<p style="margin: 5px 0;"><strong>RSSI:</strong> ${p.rssiAvg} dBm</p>` : ''}
                        </div>
                    `;
                    marker.bindPopup(popupContent);
                    marker.addTo(markerGroup);
                    markers.push(marker);
                    bounds.extend(latlng);
                    return;
                }
                
                // Wall with multiple placements
                const points = wall.placements.map(p => [p.latitude, p.longitude]);
                
                // Determine wall color
                let wallColor = '#CC0000';
                if (wall.isMultiMason) {
                    wallColor = '#2D3436'; // Charcoal for collaboration
                } else {
                    const masonId = wall.masons[0];
                    const masonIndex = uniqueMasons.indexOf(masonId);
                    wallColor = masonIndex >= 0 ? 
                        masonColors[masonIndex % masonColors.length] : 
                        '#CC0000';
                }
                
                // Create polygon for wall
                const polygon = L.polygon(points, {
                    color: wallColor,
                    fillColor: wallColor,
                    fillOpacity: 0.25,
                    weight: 4,
                    dashArray: wall.isMultiMason ? '10, 5' : null
                }).addTo(map);
                
                // Calculate wall dimensions for text scaling
                const wallBounds = polygon.getBounds();
                const wallWidth = wallBounds.getNorthEast().distanceTo(wallBounds.getNorthWest());
                const wallHeight = wallBounds.getNorthEast().distanceTo(wallBounds.getSouthEast());
                const wallArea = wallWidth * wallHeight;
                const textSize = Math.min(20, Math.max(10, 8 + Math.log10(wallArea + 1) * 3));
                
                // Calculate wall statistics
                const avgAltitude = wall.placements.reduce((sum, p) => sum + (p.altitude || 0), 0) / wall.placements.length;
                const timeSpan = Math.max(...wall.placements.map(p => p.timestamp)) - Math.min(...wall.placements.map(p => p.timestamp));
                const timeSpanHours = (timeSpan / (1000 * 60 * 60)).toFixed(1);
                
                // Build mason breakdown for popup
                const masonBreakdown = wall.masons.map(m => {
                    const count = wall.brickCounts[m];
                    const masonIndex = uniqueMasons.indexOf(m);
                    const masonColor = masonIndex >= 0 ? masonColors[masonIndex % masonColors.length] : '#CC0000';
                    return `<span style="color: ${masonColor}; font-weight: bold;">${m}</span>: ${count} brick${count > 1 ? 's' : ''}`;
                }).join('<br>');
                
                // Hover tooltip
                const hoverContent = `
                    <div style="padding: 8px; font-family: Arial;">
                        <h4 style="margin: 0 0 5px 0; color: ${wallColor};">
                            ${wall.id}
                            ${wall.isMultiMason ? '<span style="font-size: 0.7em; background: #2D3436; color: white; padding: 2px 4px; border-radius: 2px; margin-left: 3px;">TEAM</span>' : ''}
                        </h4>
                        <p style="margin: 3px 0; font-size: 0.9em;"><strong>Bricks:</strong> ${wall.placements.length}</p>
                        <p style="margin: 3px 0; font-size: 0.9em;"><strong>Masons:</strong> ${wall.masons.join(', ')}</p>
                        <p style="margin: 3px 0; font-size: 0.9em;"><strong>Altitude:</strong> ${avgAltitude.toFixed(1)} m</p>
                        <p style="margin: 3px 0; font-size: 0.85em; color: #666;">Click for details</p>
                    </div>
                `;
                
                polygon.bindTooltip(hoverContent, {
                    sticky: true,
                    opacity: 0.95
                });
                
                // Click popup - shows detailed information
                const popupContent = `
                    <div style="max-width: 300px; font-family: Arial;">
                        <h3 style="margin: 0 0 10px 0; color: ${wallColor};">
                            ${wall.id}
                            ${wall.isMultiMason ? '<span style="font-size: 0.7em; background: #2D3436; color: white; padding: 2px 6px; border-radius: 3px; margin-left: 5px;">COLLABORATIVE WALL</span>' : ''}
                        </h3>
                        
                        <p style="margin: 5px 0;"><strong>Total Bricks:</strong> ${wall.placements.length}</p>
                        <p style="margin: 5px 0;"><strong>Build Duration:</strong> ${timeSpanHours}h</p>
                        <p style="margin: 5px 0;"><strong>Average Altitude:</strong> ${avgAltitude.toFixed(1)} m</p>
                        <p style="margin: 5px 0;"><strong>Start Time:</strong> ${new Date(Math.min(...wall.placements.map(p => p.timestamp))).toLocaleString()}</p>
                        
                        <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #ddd;">
                            <h4 style="margin: 0 0 5px 0;">Mason Breakdown:</h4>
                            ${masonBreakdown}
                        </div>
                        
                        <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #ddd; max-height: 200px; overflow-y: auto;">
                            <h4 style="margin: 0 0 5px 0;">All Placements (${wall.placements.length}):</h4>
                            ${wall.placements.map((p, idx) => `
                                <div style="font-size: 0.85em; margin: 3px 0; padding: 2px 0;">
                                    <strong>${idx + 1}.</strong> 
                                    RFID: ${p.rfidTag || p.brickNumber} | 
                                    Mason: <span style="color: ${masonColors[uniqueMasons.indexOf(p.mason_id || p.masonId) % masonColors.length] || '#CC0000'};">${p.mason_id || p.masonId}</span> | 
                                    ${new Date(p.timestamp).toLocaleTimeString()}
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
                
                polygon.bindPopup(popupContent, { maxWidth: 400 });
                
                // Add hover effects
                polygon.on('mouseover', function() {
                    this.setStyle({
                        fillOpacity: 0.4,
                        weight: 6
                    });
                });
                
                polygon.on('mouseout', function() {
                    this.setStyle({
                        fillOpacity: 0.25,
                        weight: 4
                    });
                });
                
                wallPolygons.push(polygon);
                
                // Add individual placement dots within the wall
                wall.placements.forEach(p => {
                    const masonId = p.mason_id || p.masonId;
                    const masonIndex = uniqueMasons.indexOf(masonId);
                    const dotColor = masonIndex >= 0 ? 
                        masonColors[masonIndex % masonColors.length] : 
                        '#CC0000';
                    
                    const dotIcon = L.divIcon({
                        className: 'custom-marker',
                        html: `<div style="background-color: ${dotColor}; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>`,
                        iconSize: [12, 12],
                        iconAnchor: [6, 6]
                    });
                    
                    const dotMarker = L.marker([p.latitude, p.longitude], { icon: dotIcon });
                    const altitude = p.altitude || 0;
                    const dotPopup = `
                        <div style="padding: 10px; font-family: Arial; min-width: 200px;">
                            <h3 style="margin: 0 0 10px 0; color: ${dotColor};">${masonId || 'Unknown Mason'}</h3>
                            <p style="margin: 5px 0;"><strong>RFID:</strong> ${p.rfidTag || p.brickNumber}</p>
                            <p style="margin: 5px 0;"><strong>Time:</strong> ${new Date(p.timestamp).toLocaleString()}</p>
                            <p style="margin: 5px 0;"><strong>Location:</strong> ${p.latitude.toFixed(6)}, ${p.longitude.toFixed(6)}</p>
                            <p style="margin: 5px 0;"><strong>Altitude:</strong> ${altitude.toFixed(1)} m</p>
                            <p style="margin: 5px 0;"><strong>Accuracy:</strong> Â±${p.accuracy ? p.accuracy.toFixed(1) : '999'} m</p>
                            ${p.rssiAvg ? `<p style="margin: 5px 0;"><strong>RSSI:</strong> ${p.rssiAvg} dBm</p>` : ''}
                        </div>
                    `;
                    dotMarker.bindPopup(dotPopup);
                    dotMarker.addTo(markerGroup);
                    markers.push(dotMarker);
                });
                
                points.forEach(p => bounds.extend(p));
            });
            
            if (bounds.isValid()) {
                map.fitBounds(bounds, { padding: [50, 50] });
            }
        }
        
        // Update map markers
        function updateMapMarkers(placements) {
            if (!map || !markerGroup) return;
            
            // Clear existing markers
            markerGroup.clearLayers();
            markers = [];
            
            // Filter placements with valid GPS
            const validPlacements = placements.filter(p => 
                p.latitude && p.longitude && 
                p.latitude !== 0 && p.longitude !== 0
            );
            
            if (validPlacements.length === 0) {
                alert('No placements with GPS coordinates found');
                return;
            }
            
            // Create bounds for auto-fit
            const bounds = L.latLngBounds();
            
            // Create unique mason ID list to ensure consistent color mapping
            const uniqueMasons = [...new Set(validPlacements.map(p => p.mason_id || p.masonId))];
            
            validPlacements.forEach((placement, idx) => {
                const latlng = [placement.latitude, placement.longitude];
                
                // Get mason color - consistent with chart colors
                const masonId = placement.mason_id || placement.masonId;
                const masonIndex = uniqueMasons.indexOf(masonId);
                const color = masonIndex >= 0 ? 
                    masonColors[masonIndex % masonColors.length] : 
                    '#CC0000';
                
                // Create custom icon
                const icon = L.divIcon({
                    className: 'custom-marker',
                    html: `<div style="background-color: ${color}; width: 16px; height: 16px; border-radius: 50%; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>`,
                    iconSize: [16, 16],
                    iconAnchor: [8, 8]
                });
                
                // Create marker
                const marker = L.marker(latlng, { icon: icon });
                
                // Create popup content
                const altitude = placement.altitude || 0;
                const popupContent = `
                    <div style="padding: 10px; font-family: Arial; min-width: 200px;">
                        <h3 style="margin: 0 0 10px 0; color: ${color};">${masonId || 'Unknown Mason'}</h3>
                        <p style="margin: 5px 0;"><strong>RFID:</strong> ${placement.rfidTag || placement.brickNumber}</p>
                        <p style="margin: 5px 0;"><strong>Time:</strong> ${new Date(placement.timestamp).toLocaleString()}</p>
                        <p style="margin: 5px 0;"><strong>Location:</strong> ${placement.latitude.toFixed(6)}, ${placement.longitude.toFixed(6)}</p>
                        <p style="margin: 5px 0;"><strong>Altitude:</strong> ${altitude.toFixed(1)} m</p>
                        <p style="margin: 5px 0;"><strong>Accuracy:</strong> Â±${placement.accuracy ? placement.accuracy.toFixed(1) : '999'} m</p>
                        ${placement.rssiAvg ? `<p style="margin: 5px 0;"><strong>RSSI:</strong> ${placement.rssiAvg} dBm</p>` : ''}
                    </div>
                `;
                
                marker.bindPopup(popupContent);
                marker.addTo(markerGroup);
                markers.push(marker);
                bounds.extend(latlng);
            });
            
            // Fit map to show all markers
            if (validPlacements.length === 1) {
                map.setView(bounds.getCenter(), 15);
            } else {
                map.fitBounds(bounds, { padding: [50, 50] });
            }
        }
        
        // Fit map bounds to show all markers
        function fitMapBounds() {
            if (!map || markers.length === 0) return;
            
            const bounds = L.latLngBounds();
            markers.forEach(marker => {
                bounds.extend(marker.getLatLng());
            });
            
            if (markers.length === 1) {
                map.setView(bounds.getCenter(), 15);
            } else {
                map.fitBounds(bounds, { padding: [50, 50] });
            }
        }
        
        // Refresh map data
        function refreshMapData() {
            loadMapData();
        }
        
        // ============================================
        // USER MANAGEMENT (Admin only)
        // ============================================
        
        function populateUserManagement(users) {
            const tbody = document.getElementById('userManagementBody');
            if (!tbody) return;
            

            
            if (!users || users.length === 0) {
                tbody.innerHTML = '<tr><td colspan="5" style="padding: 20px; text-align: center; color: #999;">No users found.</td></tr>';
                return;
            }
            
            const currentMason = localStorage.getItem('dashboard_masonId');
            
            tbody.innerHTML = users.map(user => {
                const isCurrentUser = user.masonId === currentMason;
                const roleBadge = getRoleBadge(user.role);
                const canChangeRole = !isCurrentUser && (isSuperAdmin || (isCompanyAdmin && user.role !== 'super_admin'));
                
                let actionsHtml = '';
                if (canChangeRole) {
                    if (user.role === 'user') {
                        actionsHtml = `<button onclick="changeUserRole('${escapeHtml(user.masonId)}', 'company_admin')" 
                            style="padding: 6px 12px; background: #0984E3; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.85rem;">
                            Promote to Admin</button>`;
                    } else if (user.role === 'company_admin') {
                        actionsHtml = `<button onclick="changeUserRole('${escapeHtml(user.masonId)}', 'user')" 
                            style="padding: 6px 12px; background: #636E72; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.85rem;">
                            Remove Admin</button>`;
                    }
                    if (isSuperAdmin && user.role !== 'super_admin') {
                        actionsHtml += ` <button onclick="changeUserRole('${escapeHtml(user.masonId)}', 'super_admin')" 
                            style="padding: 6px 12px; background: #CC0000; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.85rem;">
                            Make Super Admin</button>`;
                    }
                } else if (isCurrentUser) {
                    actionsHtml = '<span style="color: #999; font-style: italic;">You</span>';
                }
                
                return `<tr style="border-bottom: 1px solid #eee;">
                    <td style="padding: 12px 16px; font-weight: ${isCurrentUser ? '700' : '400'};">${escapeHtml(user.username)}</td>
                    <td style="padding: 12px 16px; font-family: monospace; color: #636E72;">${escapeHtml(user.masonId)}</td>
                    <td style="padding: 12px 16px;">${escapeHtml(user.company)}</td>
                    <td style="padding: 12px 16px;">${roleBadge}</td>
                    <td style="padding: 12px 16px;">${actionsHtml}</td>
                </tr>`;
            }).join('');
        }
        
        function getRoleBadge(role) {
            switch(role) {
                case 'super_admin':
                    return '<span style="background: #CC0000; color: white; padding: 4px 10px; border-radius: 12px; font-size: 0.8rem; font-weight: 600;">Super Admin</span>';
                case 'company_admin':
                    return '<span style="background: #0984E3; color: white; padding: 4px 10px; border-radius: 12px; font-size: 0.8rem; font-weight: 600;">Company Admin</span>';
                default:
                    return '<span style="background: #DFE6E9; color: #2D3436; padding: 4px 10px; border-radius: 12px; font-size: 0.8rem;">User</span>';
            }
        }
        
        async function changeUserRole(masonId, newRole) {
            const roleName = newRole === 'super_admin' ? 'Super Admin' : newRole === 'company_admin' ? 'Company Admin' : 'User';
            if (!confirm(`Change this user's role to ${roleName}?`)) return;
            
            try {
                const response = await authFetch(`${API_BASE}/api/users/${encodeURIComponent(masonId)}/role`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ role: newRole })
                });
                const data = await response.json();
                
                if (data.success) {
                    // Reload user list to reflect changes
                    await loadMasons();
                    alert(`Role updated to ${roleName} successfully.`);
                } else {
                    alert('Error: ' + (data.message || 'Failed to update role'));
                }
            } catch (err) {
                console.error('Error changing role:', err);
                alert('Failed to update role. Check console for details.');
            }
        }
        
        // Initialize dashboard
        async function initDashboard() {
            try {
                // Show manage users in cog menu if admin
                if (isAnyAdmin) {
                    const manageBtn = document.getElementById('manageUsersBtn');
                    if (manageBtn) manageBtn.style.display = '';
                }
                
                await loadMasons();
                await refreshData();
                await loadPlacements();
                
                // Auto-refresh stats every 30 seconds (reduced from 10)
                refreshInterval = setInterval(() => {
                    refreshData();
                }, 30000);
                // Check for new placements every 5 seconds (reduced from 2)
                setInterval(loadPlacements, 5000);
            } catch (error) {
                console.error('Failed to initialize dashboard:', error);
                showError('Failed to initialize dashboard: ' + error.message);
                document.getElementById('loading').style.display = 'none';
            }
        }
        
        // Load all masons from /api/users endpoint (company-scoped based on role)
        async function loadMasons() {
            try {
                const response = await authFetch(`${API_BASE}/api/users`);
                const data = await response.json();
                
                if (data.success && data.users && data.users.length > 0) {
                    allMasons = data.users;
                    const select = document.getElementById('masonSelect');
                    const companyLabel = isCompanyAdmin && userCompany ? ` (${escapeHtml(userCompany.name)})` : '';
                    select.innerHTML = `<option value="">All Users${companyLabel}</option>`;
                    
                    data.users.forEach(user => {
                        const option = document.createElement('option');
                        option.value = user.masonId;
                        const roleTag = user.role === 'company_admin' ? ' ★' : user.role === 'super_admin' ? ' ◆' : '';
                        option.textContent = user.username + roleTag;
                        select.appendChild(option);
                    });
                    
                    // Also populate the modal mason select
                    const modalSelect = document.getElementById('modalMasonSelect');
                    if (modalSelect) {
                        modalSelect.innerHTML = `<option value="ALL">All Users${companyLabel}</option>`;
                        data.users.forEach(user => {
                            const option = document.createElement('option');
                            option.value = user.masonId;
                            option.textContent = user.username;
                            modalSelect.appendChild(option);
                        });
                    }
                    
                    // Populate admin user management table if admin
                    if (isAnyAdmin) {
                        populateUserManagement(data.users);
                    }
                    
                    currentMasonId = '';
                } else {
                    const select = document.getElementById('masonSelect');
                    select.innerHTML = '<option value="">All Users (No users yet)</option>';
                    allMasons = [];
                    currentMasonId = '';
                }
            } catch (error) {
                console.error('Error loading masons:', error);
                const select = document.getElementById('masonSelect');
                select.innerHTML = '<option value="">All Users (Error)</option>';
                allMasons = [];
                currentMasonId = '';
            }
        }
        
        // Load recent placements
        async function loadPlacements() {
            if (isUpdating) return;
            
            try {
                isUpdating = true;
                const masonId = document.getElementById('masonSelect').value;
                
                if (!masonId) {
                    const response = await authFetch(`${API_BASE}/api/placements/recent?limit=100`);
                    const data = await response.json();
                    
                    if (data.success && data.placements) {
                        // Only update if placement count changed
                        if (data.placements.length !== lastPlacementCount) {
                            lastPlacementCount = data.placements.length;
                            
                            const today = new Date();
                            today.setHours(0, 0, 0, 0);
                            const todayTimestamp = today.getTime();
                            
                            const todayPlacements = data.placements.filter(p => p.timestamp >= todayTimestamp);
                            
                            allPlacements = todayPlacements;
                            updatePlacementLog(allPlacements);
                            updateLiveChartMultiMason(allPlacements);
                        }
                    }
                } else {
                    const url = `${API_BASE}/api/placements/mason/${masonId}`;
                    const response = await authFetch(url);
                    const data = await response.json();
                    
                    if (data.success) {
                        if (data.placements.length !== lastPlacementCount) {
                            lastPlacementCount = data.placements.length;
                            
                            const today = new Date();
                            today.setHours(0, 0, 0, 0);
                            const todayTimestamp = today.getTime();
                            
                            const todayPlacements = (data.placements || []).filter(p => p.timestamp >= todayTimestamp);
                            
                            allPlacements = todayPlacements;
                            updatePlacementLog(allPlacements);
                            updateLiveChart(allPlacements);
                        }
                    }
                }
            } catch (error) {
                console.error('Error loading placements:', error);
            } finally {
                isUpdating = false;
            }
        }
        
        function updatePlacementLog(placements) {
            const logDiv = document.getElementById('placementLog');
            
            if (!placements || placements.length === 0) {
                logDiv.innerHTML = '<div class="no-placements">No placements recorded yet</div>';
                return;
            }
            
            // Sort by timestamp descending (newest first)
            placements.sort((a, b) => b.timestamp - a.timestamp);
            
            // Take only the most recent 50
            const recentPlacements = placements.slice(0, 50);
            
            // Track new placements for animation
            const newIds = new Set(recentPlacements.map(p => p.id));
            const justAdded = [...newIds].filter(id => !lastPlacementIds.has(id));
            lastPlacementIds = newIds;
            
            logDiv.innerHTML = recentPlacements.map(placement => {
                // Use GPS-based timezone if coordinates available
                const date = new Date(placement.timestamp);
                let timeString;
                
                if (placement.latitude && placement.longitude) {
                    // Calculate timezone offset based on longitude (rough approximation)
                    // 15 degrees longitude = 1 hour
                    const timezoneOffset = Math.round(placement.longitude / 15);
                    const localDate = new Date(date.getTime() + (timezoneOffset * 3600000));
                    
                    timeString = localDate.toISOString().replace('T', ' ').substring(0, 19) + 
                                 ` (GPS: ${placement.latitude.toFixed(4)}, ${placement.longitude.toFixed(4)})`;
                } else {
                    timeString = date.toLocaleString('en-US', {
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit',
                        hour12: false
                    });
                }
                
                const isNew = justAdded.includes(placement.id);
                const newClass = isNew ? ' new' : '';
                
                // Display both brickNumber and rfidTag if available
                const brickInfo = placement.brickNumber || placement.rfidTag || 'Unknown';
                const displayText = brickInfo.length > 20 ? 
                    `RFID: ${escapeHtml(brickInfo.substring(brickInfo.length - 8))}` : 
                    `Brick #${escapeHtml(brickInfo)}`;
                
                // Show session + sequence for true ordering (use snake_case column names)
                const sessionInfo = (placement.build_session_id || placement.buildSessionId) && (placement.event_seq || placement.eventSeq)
                    ? `<div style="font-size:0.8rem;color:#888;">Session: ${escapeHtml((placement.build_session_id || placement.buildSessionId).substring(0, 8))}... | Seq: ${placement.event_seq || placement.eventSeq}</div>` 
                    : '';
                
                // Show RSSI and decision status (use snake_case column names)
                const rssiAvg = placement.rssi_avg || placement.rssiAvg;
                const rssiPeak = placement.rssi_peak || placement.rssiPeak;
                const readsInWindow = placement.reads_in_window || placement.readsInWindow;
                const decisionStatus = placement.decision_status || placement.decisionStatus;
                const rssiInfo = rssiAvg ? `<div style="font-size:0.8rem;color:#4ade80;">RSSI: ${rssiAvg}dBm (peak ${rssiPeak}, reads ${readsInWindow})</div>` : '';
                const statusInfo = decisionStatus && decisionStatus !== 'ACCEPTED' ? `<div style="font-size:0.8rem;color:#ff6b6b;font-weight:600;">[${escapeHtml(decisionStatus)}]</div>` : '';
                
                return `
                    <div class="placement-item${newClass}">
                        <div class="placement-timestamp">${escapeHtml(timeString)}</div>
                        <div class="placement-details">
                            <div class="placement-mason">${escapeHtml(placement.mason_id || placement.masonId || 'Unknown')}</div>
                            <div class="placement-brick">${displayText}</div>
                            ${sessionInfo}
                            ${rssiInfo}
                            ${statusInfo}
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // Refresh dashboard data (stats only, don't reload placements)
        async function refreshData() {
            try {
                const response = await authFetch(`${API_BASE}/api/statistics/efficiency`);
                const data = await response.json();
                
                if (!data.success) {
                    throw new Error(data.message || 'Failed to fetch data');
                }
                
                hideError();
                updateDashboard(data);
                document.getElementById('lastUpdated').textContent = new Date().toLocaleString();
                
            } catch (error) {
                console.error('Error refreshing data:', error);
                showError('Failed to refresh data: ' + error.message);
            }
        }
        
        // Update dashboard with new data
        function updateDashboard(data) {
            const masonId = document.getElementById('masonSelect').value || currentMasonId;
            
            // Filter data for selected mason
            let dailyData = data.dailyEfficiency || [];
            let summaryData = data.masonSummary || [];
            
            if (masonId) {
                dailyData = dailyData.filter(d => d.masonId === masonId);
                summaryData = summaryData.filter(s => s.masonId === masonId);
            }
            
            // Update title
            const title = 'Efficiency Dashboard';
            document.getElementById('dashboardTitle').textContent = title;
            
            // Update summary stats
            if (summaryData.length > 0) {
                if (masonId) {
                    // Single mason - show their data
                    const summary = summaryData[0];
                    document.getElementById('totalPlacements').textContent = summary.totalPlacements.toLocaleString();
                    document.getElementById('daysWorked').textContent = summary.daysWorked;
                    document.getElementById('avgPerDay').textContent = summary.avgPlacementsPerDay.toFixed(1);
                } else {
                    // All masons - aggregate the data
                    const totalPlacements = summaryData.reduce((sum, s) => sum + s.totalPlacements, 0);
                    const maxDaysWorked = Math.max(...summaryData.map(s => s.daysWorked));
                    const avgPerDay = (totalPlacements / maxDaysWorked).toFixed(1);
                    
                    document.getElementById('totalPlacements').textContent = totalPlacements.toLocaleString();
                    document.getElementById('daysWorked').textContent = maxDaysWorked;
                    document.getElementById('avgPerDay').textContent = avgPerDay;
                }
            } else {
                // No data yet
                document.getElementById('totalPlacements').textContent = '0';
                document.getElementById('daysWorked').textContent = '0';
                document.getElementById('avgPerDay').textContent = '0.0';
            }
            
            // Update current efficiency (most recent day)
            if (dailyData.length > 0) {
                if (masonId) {
                    // Single mason
                    const latest = dailyData[0];
                    document.getElementById('currentEfficiency').textContent = latest.placementsPerHour.toFixed(1);
                } else {
                    // All masons - average efficiency across all masons' latest day
                    const avgEfficiency = (dailyData.reduce((sum, d) => sum + d.placementsPerHour, 0) / dailyData.length).toFixed(1);
                    document.getElementById('currentEfficiency').textContent = avgEfficiency;
                }
            } else {
                document.getElementById('currentEfficiency').textContent = '0.0';
            }
            
            // Update daily chart
            updateDailyChart(dailyData);
            
            // Show dashboard
            document.getElementById('loading').style.display = 'none';
            document.getElementById('dashboard').style.display = 'block';
        }
        
        // Update live placements chart for multiple masons
        function updateLiveChartMultiMason(placements) {
            if (!placements || placements.length === 0) return;
            
            const masonGroups = {};
            placements.forEach(p => {
                const masonId = p.mason_id || p.masonId;
                if (!masonId) return;
                if (!masonGroups[masonId]) masonGroups[masonId] = [];
                masonGroups[masonId].push(p);
            });
            
            // Sort mason IDs for consistent ordering
            const sortedMasonIds = Object.keys(masonGroups).sort();
            
            // Create datasets for each mason
            const datasets = sortedMasonIds.map((masonId) => {
                const masonPlacements = masonGroups[masonId].sort((a, b) => a.timestamp - b.timestamp);
                const dataPoints = masonPlacements.map((p, pIdx) => ({
                    x: p.timestamp,
                    y: pIdx + 1
                }));
                
                const color = getMasonColor(masonId, sortedMasonIds);
                
                return {
                    label: masonId,
                    data: dataPoints,
                    borderColor: color,
                    backgroundColor: color + '20', // Add transparency
                    borderWidth: 3,
                    fill: false,
                    tension: 0.4,
                    pointRadius: 3,
                    pointHoverRadius: 6,
                    pointBackgroundColor: color,
                    pointBorderColor: '#fff',
                    pointBorderWidth: 2
                };
            });
            
            // Calculate max Y value across all mason datasets
            const maxY = Math.max(...datasets.map(ds => Math.max(...ds.data.map(p => p.y)))) + 5;
            
            // Update existing chart or create new one
            if (liveChart) {
                liveChart.data.datasets = datasets;
                liveChart.options.scales.y.suggestedMax = maxY;
                liveChart.update('none');
                return;
            }
            
            // Create new chart
            const liveCtx = document.getElementById('liveChart').getContext('2d');
            liveChart = new Chart(liveCtx, {
                type: 'line',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            padding: 12,
                            titleFont: { size: 14 },
                            bodyFont: { size: 13 },
                            callbacks: {
                                title: function(context) {
                                    const date = new Date(context[0].parsed.x);
                                    return date.toLocaleString('en-US', {
                                        month: 'short',
                                        day: 'numeric',
                                        hour: '2-digit',
                                        minute: '2-digit',
                                        second: '2-digit'
                                    });
                                },
                                label: function(context) {
                                    return context.dataset.label + ': ' + context.parsed.y + ' placements';
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            suggestedMax: maxY,
                            title: {
                                display: true,
                                text: 'Cumulative Placements (per Mason)',
                                font: { size: 14, weight: 'bold' }
                            },
                            grid: {
                                color: 'rgba(0, 0, 0, 0.05)'
                            }
                        },
                        x: {
                            type: 'time',
                            time: {
                                unit: 'minute',
                                displayFormats: {
                                    minute: 'HH:mm',
                                    hour: 'HH:mm'
                                },
                                tooltipFormat: 'MMM d, HH:mm:ss'
                            },
                            title: {
                                display: true,
                                text: 'Time',
                                font: { size: 14, weight: 'bold' }
                            },
                            grid: {
                                display: false
                            },
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45,
                                autoSkip: true,
                                maxTicksLimit: 10
                            }
                        }
                    }
                }
            });
        }
        
        // Update live placements chart for single mason
        function updateLiveChart(placements) {
            if (!placements || placements.length === 0) return;
            
            // Sort by timestamp and take last 50
            const sorted = [...placements].sort((a, b) => a.timestamp - b.timestamp).slice(-50);
            
            // Use actual timestamp values for proper time-based spacing
            const dataPoints = sorted.map((p, idx) => ({
                x: p.timestamp, // Use actual timestamp for X-axis
                y: idx + 1      // Cumulative count for Y-axis
            }));
            
            // Update existing chart instead of destroying it
            if (liveChart) {
                liveChart.data.datasets = [{
                    label: 'Cumulative Placements',
                    data: dataPoints,
                    borderColor: '#CC0000',
                    backgroundColor: 'rgba(204, 0, 0, 0.1)',
                    borderWidth: 3,
                    fill: true,
                    tension: 0.4,
                    pointRadius: 3,
                    pointHoverRadius: 6,
                    pointBackgroundColor: '#CC0000',
                    pointBorderColor: '#fff',
                    pointBorderWidth: 2
                }];
                liveChart.options.scales.y.suggestedMax = undefined;
                liveChart.update('none'); // Update without animation for smooth real-time updates
                return;
            }
            
            // Create chart only if it doesn't exist
            const liveCtx = document.getElementById('liveChart').getContext('2d');
            liveChart = new Chart(liveCtx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Cumulative Placements',
                        data: dataPoints,
                        borderColor: '#CC0000',
                        backgroundColor: 'rgba(204, 0, 0, 0.1)',
                        borderWidth: 3,
                        fill: true,
                        tension: 0.4,
                        pointRadius: 3,
                        pointHoverRadius: 6,
                        pointBackgroundColor: '#CC0000',
                        pointBorderColor: '#fff',
                        pointBorderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            padding: 12,
                            titleFont: { size: 14 },
                            bodyFont: { size: 13 },
                            callbacks: {
                                title: function(context) {
                                    const date = new Date(context[0].parsed.x);
                                    return date.toLocaleString('en-US', {
                                        month: 'short',
                                        day: 'numeric',
                                        hour: '2-digit',
                                        minute: '2-digit',
                                        second: '2-digit'
                                    });
                                },
                                label: function(context) {
                                    return 'Total: ' + context.parsed.y + ' placements';
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Cumulative Placements',
                                font: { size: 14, weight: 'bold' }
                            },
                            grid: {
                                color: 'rgba(0, 0, 0, 0.05)'
                            }
                        },
                        x: {
                            type: 'time',
                            time: {
                                unit: 'minute',
                                displayFormats: {
                                    minute: 'HH:mm',
                                    hour: 'HH:mm'
                                },
                                tooltipFormat: 'MMM d, HH:mm:ss'
                            },
                            title: {
                                display: true,
                                text: 'Time',
                                font: { size: 14, weight: 'bold' }
                            },
                            grid: {
                                display: false
                            },
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45,
                                autoSkip: true,
                                maxTicksLimit: 10
                            }
                        }
                    }
                }
            });
        }
        
        // Update daily chart with aggregate data
        function updateDailyChart(dailyData) {
            // Sort by date ascending
            dailyData.sort((a, b) => new Date(a.date) - new Date(b.date));
            
            const masonId = document.getElementById('masonSelect').value;
            
            console.log('updateDailyChart called with:', { masonId, dataCount: dailyData.length, data: dailyData });
            
            // If "All Masons" selected, create bar chart with each mason
            if (!masonId && dailyData.length > 0) {
                // Group by date and mason
                const dateMap = {};
                const masonSet = new Set();
                
                dailyData.forEach(d => {
                    if (!dateMap[d.date]) {
                        dateMap[d.date] = {};
                    }
                    dateMap[d.date][d.masonId] = d.totalPlacements;
                    masonSet.add(d.masonId);
                });
                
                console.log('Grouped data:', { dateMap, masons: Array.from(masonSet) });
                
                const dates = Object.keys(dateMap).sort();
                const masonIds = Array.from(masonSet).sort(); // Sort for consistent ordering
                
                // Create datasets for each mason
                const datasets = masonIds.map((mId) => {
                    const color = getMasonColor(mId, masonIds);
                    
                    return {
                        label: mId,
                        data: dates.map(date => dateMap[date][mId] || 0),
                        backgroundColor: color,
                        borderColor: color,
                        borderWidth: 2,
                        borderRadius: 5
                    };
                });
                
                if (dailyChart) {
                    dailyChart.data.labels = dates;
                    dailyChart.data.datasets = datasets;
                    dailyChart.options.scales.y.suggestedMax = Math.max(...dates.map(date => 
                        Object.values(dateMap[date]).reduce((sum, val) => sum + val, 0)
                    )) + 10;
                    dailyChart.update('none'); // Update without animation
                    return;
                }
                
                // Create stacked bar chart
                const dailyCtx = document.getElementById('dailyChart').getContext('2d');
                dailyChart = new Chart(dailyCtx, {
                    type: 'bar',
                    data: {
                        labels: dates,
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            tooltip: {
                                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                                padding: 12,
                                titleFont: { size: 14 },
                                bodyFont: { size: 13 }
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                stacked: false,  // Changed from true to false for side-by-side bars
                                suggestedMax: Math.max(...dates.map(date => 
                                    Math.max(...Object.values(dateMap[date]))
                                )) + 10,
                                title: {
                                    display: true,
                                    text: 'Total Placements',
                                    font: { size: 14, weight: 'bold' }
                                },
                                grid: {
                                    color: 'rgba(0, 0, 0, 0.05)'
                                }
                            },
                            x: {
                                stacked: false,  // Changed from true to false for side-by-side bars
                                title: {
                                    display: true,
                                    text: 'Date',
                                    font: { size: 14, weight: 'bold' }
                                },
                                grid: {
                                    display: false
                                }
                            }
                        }
                    }
                });
                return;
            }
            
            // Single mason view
            const dates = dailyData.map(d => d.date);
            const totals = dailyData.map(d => d.totalPlacements);
            
            // Get the mason's color (use first data point's masonId)
            const selectedMasonId = dailyData.length > 0 ? dailyData[0].masonId : null;
            const masonColor = selectedMasonId ? getMasonColor(selectedMasonId) : '#2D3436';
            
            // Update existing chart instead of destroying it
            if (dailyChart) {
                dailyChart.data.labels = dates;
                dailyChart.data.datasets = [{
                    label: `${selectedMasonId || 'Total'} Bricks Placed`,
                    data: totals,
                    backgroundColor: masonColor,
                    borderColor: masonColor,
                    borderWidth: 2,
                    borderRadius: 5
                }];
                dailyChart.options.scales.y.stacked = false;
                dailyChart.options.scales.x.stacked = false;
                dailyChart.options.scales.y.suggestedMax = undefined;
                dailyChart.update('none'); // Update without animation
                return;
            }
            
            // Create chart only if it doesn't exist
            const dailyCtx = document.getElementById('dailyChart').getContext('2d');
            dailyChart = new Chart(dailyCtx, {
                type: 'bar',
                data: {
                    labels: dates,
                    datasets: [{
                        label: `${selectedMasonId || 'Total'} Bricks Placed`,
                        data: totals,
                        backgroundColor: masonColor,
                        borderColor: masonColor,
                        borderWidth: 2,
                        borderRadius: 5
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            padding: 12,
                            titleFont: { size: 14 },
                            bodyFont: { size: 13 }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Total Placements',
                                font: { size: 14, weight: 'bold' }
                            },
                            grid: {
                                color: 'rgba(0, 0, 0, 0.05)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Date',
                                font: { size: 14, weight: 'bold' }
                            },
                            grid: {
                                display: false
                            }
                        }
                    }
                }
            });
        }
        
        // Show performance review modal
        function showReportModal() {
            const modal = document.getElementById('reportModal');
            const modalMasonSelect = document.getElementById('modalMasonSelect');
            const currentMasonSelect = document.getElementById('masonSelect');
            
            // Populate modal mason dropdown with current masons
            modalMasonSelect.innerHTML = '<option value="ALL">All Users</option>';
            Array.from(currentMasonSelect.options).forEach(option => {
                if (option.value && option.value !== '') {
                    const opt = document.createElement('option');
                    opt.value = option.value;
                    opt.textContent = option.textContent;
                    if (option.value === currentMasonSelect.value) {
                        opt.selected = true;
                    }
                    modalMasonSelect.appendChild(opt);
                }
            });
            
            modal.classList.add('show');
        }
        
        // Close performance review modal
        function closeReportModal() {
            const modal = document.getElementById('reportModal');
            modal.classList.remove('show');
        }
        
        // Generate report from modal
        function generateReport() {
            const masonId = document.getElementById('modalMasonSelect').value;
            const periodDays = document.getElementById('modalPeriodSelect').value;
            
            // Calculate date range based on selected period
            const endDate = Date.now();
            let startDate;
            
            if (periodDays === 'all') {
                startDate = 0; // Unix epoch
            } else {
                const days = parseInt(periodDays);
                startDate = endDate - (days * 24 * 60 * 60 * 1000);
            }
            
            // Open report in new tab
            const reportUrl = `${API_BASE}/api/report/mason/${masonId}?startDate=${startDate}&endDate=${endDate}`;
            window.open(reportUrl, '_blank');
            
            // Close modal
            closeReportModal();
        }
        
        // Close modal when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('reportModal');
            if (event.target === modal) {
                closeReportModal();
            }
        }
        
        // Show error message
        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }
        
        // Hide error message
        function hideError() {
            document.getElementById('error').style.display = 'none';
        }
        
        // Mason selection change handler
        document.getElementById('masonSelect').addEventListener('change', function() {
            currentMasonId = this.value;
            allPlacements = [];
            lastPlacementIds = new Set();
            lastPlacementCount = 0;
            refreshData();
            loadPlacements();
            
            // Refresh map if it's initialized
            if (map) {
                loadMapData();
            }
        });
        
        // Initialize on page load
        window.addEventListener('DOMContentLoaded', initDashboard);
        
        window.addEventListener('beforeunload', () => {
            if (refreshInterval) {
                clearInterval(refreshInterval);
            }
        });
    </script>
</body>
</html>
