<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mason Efficiency Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Barlow+Semi+Condensed:wght@400;600;700;800&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #e8e8e8;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            width: 100%;
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            padding: 0;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1), 0 12px 40px rgba(0,0,0,0.15);
            min-height: calc(100vh - 40px);
            overflow: visible;
        }

        /* Fullscreen map mode */
        body.map-fullscreen {
            padding: 0;
            overflow: hidden;
        }
        body.map-fullscreen .container {
            max-width: 100%;
            border-radius: 0;
            min-height: 100vh;
        }
        body.map-fullscreen .header,
        body.map-fullscreen .user-bar,
        body.map-fullscreen .controls,
        body.map-fullscreen #loading,
        body.map-fullscreen #error,
        body.map-fullscreen .last-updated,
        body.map-fullscreen .tabs {
            display: none !important;
        }
        body.map-fullscreen #dashboard {
            display: block !important;
            margin-top: 0 !important;
        }
        body.map-fullscreen #map-tab {
            display: block !important;
            padding: 0;
            height: 100vh;
            position: relative;
        }
        body.map-fullscreen #map-tab h2 {
            display: none;
        }
        body.map-fullscreen #map {
            height: 100vh !important;
            max-width: 100% !important;
            border-radius: 0;
        }
        body.map-fullscreen .map-controls {
            position: fixed !important;
            top: 12px;
            left: 12px;
            right: 12px;
            z-index: 10000;
            background: rgba(255,255,255,0.95);
            padding: 8px 12px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            display: flex !important;
        }
        body.map-fullscreen #overview-tab,
        body.map-fullscreen #manage-users-tab {
            display: none !important;
        }
        body.map-fullscreen .scroll-to-top {
            display: none !important;
        }

        .scroll-to-top {
            position: fixed;
            bottom: 24px;
            right: 24px;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: #2D3436;
            color: white;
            border: none;
            cursor: pointer;
            box-shadow: 0 3px 10px rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.25s ease, visibility 0.25s ease, transform 0.25s ease;
            transform: translateY(12px);
        }
        .scroll-to-top.visible {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }
        .scroll-to-top:hover {
            background: #444;
            transform: translateY(-2px);
        }
        .scroll-to-top svg {
            width: 22px;
            height: 22px;
        }

        .header {
            display: flex;
            align-items: stretch;
            margin-bottom: 0;
            border-radius: 12px 12px 0 0;
            overflow: hidden;
            min-height: 100px;
            position: relative;
            z-index: 10;
            box-shadow: 0 6px 16px rgba(0,0,0,0.25), 0 12px 32px rgba(0,0,0,0.15);
        }
        
        .header-left {
            background: #2D3436;
            color: white;
            flex: 0 0 70%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            padding: 25px 60px 25px 30px;
            position: relative;
            z-index: 1;
        }
        
        .header-left::after {
            content: '';
            position: absolute;
            top: 0;
            right: -40px;
            width: 80px;
            height: 100%;
            background: #2D3436;
            transform: skewX(-17deg);
            z-index: 1;
        }
        
        .header-left h1 {
            font-family: 'Barlow Semi Condensed', sans-serif;
            font-size: 2.2rem;
            margin: 0 0 6px 0;
            font-weight: 700;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            text-shadow: 0 1px 3px rgba(0,0,0,0.15);
        }
        
        .header-left p {
            font-size: 1.05rem;
            opacity: 0.7;
            margin: 0;
            text-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .header-right {
            background: white;
            flex: 0 0 30%;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding: 20px 30px 20px 60px;
        }
        
        .header-right img {
            max-height: 60px;
            width: auto;
        }

        .user-bar {
            background: #CC0000;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-radius: 0;
            margin-top: -10px;
            margin-bottom: 0;
            font-size: 0.9rem;
            position: relative;
            z-index: 9;
            min-height: 52px;
            padding: 22px 16px 14px 16px;
            box-shadow: 0 6px 16px rgba(0,0,0,0.25), 0 12px 32px rgba(0,0,0,0.15);
        }

        .user-bar .user-info {
            display: flex;
            align-items: center;
            gap: 10px;
            color: white;
        }

        .user-bar .user-icon {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: white;
            overflow: hidden;
            flex-shrink: 0;
        }

        .user-bar .user-icon img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            object-position: top;
        }

        .user-bar .user-info strong {
            font-weight: 700;
            color: white;
            font-size: 0.95rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            text-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        .settings-wrapper {
            position: relative;
        }

        .btn-settings {
            background: none;
            border: none;
            cursor: pointer;
            padding: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background 0.2s;
        }

        .btn-settings:hover {
            background: rgba(255,255,255,0.15);
        }

        .btn-settings svg {
            width: 22px;
            height: 22px;
            fill: white;
        }

        .settings-dropdown {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 6px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.15);
            min-width: 160px;
            z-index: 1000;
            overflow: hidden;
        }

        .settings-dropdown.open {
            display: block;
        }

        .settings-dropdown button {
            display: flex;
            align-items: center;
            gap: 10px;
            width: 100%;
            padding: 12px 16px;
            border: none;
            background: none;
            cursor: pointer;
            font-size: 0.85rem;
            font-family: inherit;
            color: #2D3436;
            transition: background 0.15s;
        }

        .settings-dropdown button:hover {
            background: #f5f5f5;
        }

        .settings-dropdown button svg {
            width: 16px;
            height: 16px;
            fill: #636E72;
        }

        .settings-dropdown button.danger {
            color: #CC0000;
        }

        .settings-dropdown button.danger svg {
            fill: #CC0000;
        }
        
        .controls {
            background: white;
            padding: 24px 20px 20px 20px;
            border-radius: 0;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            margin-top: -10px;
            margin-bottom: 0;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
            position: relative;
            z-index: 8;
        }
        
        .tabs {
            display: flex;
            background: white;
            border-radius: 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-top: -10px;
            margin-bottom: 0;
            overflow: hidden;
            position: sticky;
            top: 0;
            z-index: 100;
            padding-top: 10px;
        }
        
        .tab-button {
            flex: 1;
            padding: 15px 20px;
            background: #f5f5f5;
            border: none;
            cursor: pointer;
            font-family: 'Barlow Semi Condensed', sans-serif;
            font-size: 1rem;
            font-weight: 600;
            color: #666;
            transition: all 0.3s;
            border-bottom: 3px solid transparent;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .tab-button:hover {
            background: #e8e8e8;
        }
        
        .tab-button.active {
            background: white;
            color: #2D3436;
            border-bottom-color: #CC0000;
        }
        
        .tab-content {
            display: none;
            background: white;
            padding: 30px;
            border-radius: 0;
            box-shadow: none;
            position: relative;
            z-index: 6;
        }
        
        .tab-content.active {
            display: block;
        }
        
        #map {
            width: 100%;
            height: 500px;
            border-radius: 8px;
        }

        .pallet-bubble-marker {
            background: none !important;
            border: none !important;
        }
        
        .map-controls {
            margin-bottom: 15px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .map-controls button {
            padding: 8px 16px;
            background: #2D3436;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
        }
        
        .map-controls button:hover {
            background: #444;
        }
        
        .controls label {
            font-weight: 600;
            color: #333;
        }
        
        /* ── Polished Select Styling (global) ── */
        select {
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='8' viewBox='0 0 12 8'%3E%3Cpath d='M1 1.5L6 6.5L11 1.5' stroke='%23636E72' stroke-width='1.8' fill='none' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 14px center;
            padding-right: 40px !important;
            font-family: inherit;
        }

        .controls select, .controls button {
            padding: 10px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 0.95rem;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: none;
        }
        
        .controls select {
            background-color: white;
            color: #2D3436;
            min-width: 180px;
        }

        .controls select:hover {
            border-color: #ccc;
        }

        .controls select:focus {
            outline: none;
            border-color: #CC0000;
            box-shadow: 0 0 0 3px rgba(204, 0, 0, 0.1);
        }
        
        .controls button {
            background: #2D3436;
            color: white;
            font-weight: 600;
            border: none;
        }
        
        .controls button:hover {
            background: #444;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        /* === Widget Grid System === */
        .widget-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
            gap: 16px;
            margin-bottom: 20px;
        }

        .widget {
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08), 0 8px 24px rgba(0,0,0,0.12);
            position: relative;
            transition: transform 0.25s ease, box-shadow 0.25s ease;
            user-select: none;
            overflow: hidden;
        }
        .widget:hover { transform: translateY(-3px); box-shadow: 0 4px 12px rgba(0,0,0,0.10), 0 12px 32px rgba(0,0,0,0.18); }

        /* KPI widgets stay in the grid flow */
        .widget.widget-kpi {
            padding: 22px 18px;
            text-align: center;
            min-height: 100px;
        }
        .widget.widget-kpi h3 {
            font-family: 'Barlow Semi Condensed', sans-serif;
            color: #555;
            font-size: 0.85rem;
            text-transform: uppercase;
            margin: 0 0 8px;
            letter-spacing: 1px;
            font-weight: 600;
        }
        .widget.widget-kpi .widget-value {
            font-family: 'Barlow Semi Condensed', sans-serif;
            font-size: 2.4rem;
            font-weight: 700;
            color: #333;
        }

        /* Chart widgets span full width */
        .widget.widget-chart {
            grid-column: 1 / -1;
            padding: 24px;
        }
        .widget.widget-chart h2 {
            font-family: 'Barlow Semi Condensed', sans-serif;
            color: #333;
            margin: 0 0 16px;
            text-align: center;
            font-weight: 700;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            font-size: 1.1rem;
        }

        /* Drag handle */
        .widget .drag-handle {
            display: none;
            width: 100%;
            padding: 6px 0;
            text-align: center;
            cursor: grab;
            color: #bbb;
            font-size: 14px;
            letter-spacing: 3px;
            user-select: none;
            touch-action: none;
            border-bottom: 1px solid #eee;
            margin-bottom: 8px;
        }
        .widget .drag-handle:active { cursor: grabbing; }
        .widget-grid.editing .widget .drag-handle { display: block; }

        /* Edit mode */
        .widget-grid.editing .widget {
            box-shadow: 0 2px 12px rgba(0,0,0,0.15);
        }
        .widget-grid.editing .widget:hover {
            transform: none;
        }

        /* Remove button (X) */
        .widget .widget-remove {
            display: none;
            position: absolute;
            top: 8px;
            right: 8px;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: #ff3b30;
            color: white;
            border: none;
            font-size: 18px;
            line-height: 28px;
            text-align: center;
            cursor: pointer;
            z-index: 5;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            padding: 0;
            font-weight: bold;
            transition: transform 0.15s, background 0.15s;
        }
        .widget .widget-remove:hover {
            background: #d32f2f;
            transform: scale(1.15);
        }
        .widget-grid.editing .widget .widget-remove {
            display: block;
        }

        /* Drag indicator line */
        .drop-indicator {
            position: absolute;
            height: 4px;
            background: #CC0000;
            border-radius: 2px;
            z-index: 100;
            pointer-events: none;
        }
        .widget.dragging {
            opacity: 0.3;
            animation: none !important;
        }

        /* Add widget button (in edit bar) */
        .widget-add-btn {
            display: none;
            background: none;
            border: 1px dashed #aaa;
            cursor: pointer;
            padding: 5px 14px;
            border-radius: 8px;
            color: #888;
            transition: all 0.2s;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            align-items: center;
            gap: 4px;
        }
        .widget-add-btn:hover {
            border-color: #2D3436;
            color: #2D3436;
            background: #f0f0f0;
        }
        .widget-add-btn.visible {
            display: flex;
        }

        /* Edit mode toggle */
        .widget-edit-bar {
            display: flex;
            justify-content: flex-end;
            margin-bottom: 10px;
            gap: 8px;
        }
        .widget-edit-btn {
            background: none;
            border: 1px solid transparent;
            cursor: pointer;
            padding: 5px 12px;
            border-radius: 8px;
            color: #888;
            transition: all 0.2s;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .widget-edit-btn:hover {
            color: #2D3436;
            background: #f0f0f0;
        }
        .widget-edit-btn.active {
            color: white;
            background: #2D3436;
            border-color: #2D3436;
        }

        /* Widget gallery modal */
        .gallery-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 12px;
            max-height: 400px;
            overflow-y: auto;
            padding: 4px;
        }
        .gallery-item {
            background: #f8f8f8;
            border: 2px solid #e5e5e5;
            border-radius: 10px;
            padding: 16px 12px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        .gallery-item:hover {
            border-color: #2D3436;
            background: #f0f0f0;
            transform: translateY(-2px);
        }
        .gallery-item.already-added {
            background: #e8f5e9;
            border-color: #4caf50;
        }
        .gallery-item.already-added .gallery-desc {
            color: #2e7d32;
            font-weight: 600;
        }
        .gallery-item .gallery-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 6px;
        }
        .gallery-item .gallery-icon svg {
            width: 28px;
            height: 28px;
            stroke: #CC0000;
        }
        .gallery-item .gallery-name {
            font-weight: 600;
            font-size: 0.85rem;
            color: #333;
        }
        .gallery-item .gallery-desc {
            font-size: 0.75rem;
            color: #999;
            margin-top: 4px;
        }

        .chart-container {
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08), 0 8px 24px rgba(0,0,0,0.12);
        }
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08), 0 8px 24px rgba(0,0,0,0.12);
            margin-bottom: 20px;
        }
        
        .chart-container h2 {
            font-family: 'Barlow Semi Condensed', sans-serif;
            color: #333;
            margin-bottom: 20px;
            text-align: center;
            font-weight: 700;
            letter-spacing: 0.5px;
            text-transform: uppercase;
        }
        
        .chart-wrapper {
            position: relative;
            height: 400px;
        }
        
        .last-updated {
            text-align: center;
            color: #888;
            font-size: 0.9rem;
            opacity: 0.8;
            margin-top: -6px;
            padding-top: 20px;
            position: relative;
            z-index: 5;
        }
        
        .loading {
            text-align: center;
            color: #666;
            font-size: 1.2rem;
            padding: 50px;
        }
        
        .error {
            background: #ff6b6b;
            color: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            margin-bottom: 20px;
        }
        
        .mason-select-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .company-select-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .filter-divider {
            width: 1px;
            height: 28px;
            background: #ddd;
            margin: 0 4px;
        }
        
        .refresh-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #4ade80;
            margin-left: 10px;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        
        .modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            animation: fadeIn 0.3s;
            justify-content: center;
            align-items: center;
        }
        
        .modal.show {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            max-width: 500px;
            width: 90%;
            animation: slideIn 0.3s;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes slideIn {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        .modal-content h2 {
            font-family: 'Barlow Semi Condensed', sans-serif;
            color: #2D3436;
            margin-bottom: 20px;
            text-align: center;
            font-weight: 700;
            letter-spacing: 0.5px;
            text-transform: uppercase;
        }
        
        .modal-field {
            margin-bottom: 20px;
        }
        
        .modal-field label {
            display: block;
            color: #333;
            font-weight: 600;
            margin-bottom: 8px;
        }
        
        .modal-field select,
        .modal-field input[type="text"],
        .modal-field input[type="password"] {
            width: 100%;
            padding: 12px 14px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1rem;
            background-color: white;
            cursor: pointer;
            transition: border-color 0.2s, box-shadow 0.2s;
            font-family: inherit;
            color: #2D3436;
        }

        .modal-field input[type="text"],
        .modal-field input[type="password"] {
            cursor: text;
        }
        
        .modal-field select:focus,
        .modal-field input[type="text"]:focus,
        .modal-field input[type="password"]:focus {
            outline: none;
            border-color: #CC0000;
            box-shadow: 0 0 0 3px rgba(204, 0, 0, 0.1);
        }

        .modal-field select:hover,
        .modal-field input[type="text"]:hover,
        .modal-field input[type="password"]:hover {
            border-color: #ccc;
        }
        
        .modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 25px;
        }
        
        .modal-buttons button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .modal-buttons .btn-generate {
            background: #2D3436;
            color: white;
        }
        
        .modal-buttons .btn-generate:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .modal-buttons .btn-cancel {
            background: #e0e0e0;
            color: #666;
        }
        
        .modal-buttons .btn-cancel:hover {
            background: #d0d0d0;
        }

        /* Report section presets & checkboxes */
        .report-preset-btn {
            padding: 5px 12px;
            border: 1.5px solid #ccc;
            border-radius: 6px;
            background: white;
            font-size: 0.78rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            color: #555;
        }
        .report-preset-btn:hover { border-color: #999; color: #333; }
        .report-preset-btn.active {
            background: #2D3436;
            color: white;
            border-color: #2D3436;
        }
        .report-sections-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 10px;
            max-height: 380px;
            overflow-y: auto;
            padding: 4px;
        }
        .report-section-divider {
            grid-column: 1 / -1;
            font-size: 0.7rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #999;
            margin-top: 6px;
            padding-bottom: 2px;
            border-bottom: 1px solid #eee;
        }
        .report-card {
            background: #f8f8f8;
            border: 2px solid #e5e5e5;
            border-radius: 10px;
            padding: 14px 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            user-select: none;
        }
        .report-card:hover {
            border-color: #2D3436;
            background: #f0f0f0;
            transform: translateY(-2px);
        }
        .report-card.selected {
            background: #e8f5e9;
            border-color: #4caf50;
        }
        .report-card .report-card-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 6px;
        }
        .report-card .report-card-icon svg {
            width: 26px;
            height: 26px;
            stroke: #CC0000;
        }
        .report-card.selected .report-card-icon svg {
            stroke: #2e7d32;
        }
        .report-card .report-card-name {
            font-weight: 600;
            font-size: 0.82rem;
            color: #333;
        }
        .report-card .report-card-status {
            font-size: 0.72rem;
            color: #999;
            margin-top: 3px;
        }
        .report-card.selected .report-card-status {
            color: #2e7d32;
            font-weight: 600;
        }

        /* ── User Management Table ── */
        .um-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 16px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .um-header h2 {
            margin: 0;
            font-family: 'Barlow Semi Condensed', sans-serif;
            font-size: 1.6rem;
            font-weight: 700;
            color: #2D3436;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .um-actions {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .um-search {
            padding: 10px 14px 10px 38px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 0.9rem;
            font-family: inherit;
            width: 220px;
            transition: border-color 0.2s, box-shadow 0.2s;
            background: white url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23999' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='11' cy='11' r='8'/%3E%3Cline x1='21' y1='21' x2='16.65' y2='16.65'/%3E%3C/svg%3E") no-repeat 12px center;
        }
        .um-search:focus {
            outline: none;
            border-color: #CC0000;
            box-shadow: 0 0 0 3px rgba(204, 0, 0, 0.1);
        }
        .btn-add-user {
            padding: 10px 20px;
            background: #CC0000;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
            font-family: inherit;
        }
        .btn-add-user:hover {
            background: #a50000;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(204, 0, 0, 0.3);
        }
        .btn-add-user svg {
            width: 16px;
            height: 16px;
        }
        .um-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            font-size: 0.92rem;
        }
        .um-table thead th {
            background: #2D3436;
            color: white;
            padding: 14px 18px;
            text-align: left;
            font-weight: 600;
            font-size: 0.82rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            white-space: nowrap;
        }
        .um-table thead th:first-child { border-radius: 10px 0 0 0; }
        .um-table thead th:last-child { border-radius: 0 10px 0 0; }
        .um-table tbody tr {
            transition: background 0.15s;
        }
        .um-table tbody tr:hover {
            background: #f8f9fa;
        }
        .um-table tbody td {
            padding: 14px 18px;
            border-bottom: 1px solid #f0f0f0;
            vertical-align: middle;
        }
        .um-table tbody tr:last-child td {
            border-bottom: none;
        }
        .um-mason-id {
            font-family: 'SF Mono', 'Consolas', monospace;
            font-size: 0.82rem;
            color: #636E72;
            background: #f5f5f5;
            padding: 4px 8px;
            border-radius: 4px;
        }
        .um-username {
            font-weight: 600;
            color: #2D3436;
        }
        .um-username.is-you {
            color: #CC0000;
        }
        .um-company {
            color: #555;
        }
        .role-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.78rem;
            font-weight: 600;
            white-space: nowrap;
        }
        .role-badge.super-admin {
            background: #CC0000;
            color: white;
        }
        .role-badge.company-admin {
            background: #0984E3;
            color: white;
        }
        .role-badge.user {
            background: #f0f0f0;
            color: #555;
        }
        .um-btn {
            padding: 6px 14px;
            border: none;
            border-radius: 6px;
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s;
            font-family: inherit;
            white-space: nowrap;
        }
        .um-btn:hover {
            transform: translateY(-1px);
        }
        .um-btn.promote {
            background: #0984E3;
            color: white;
        }
        .um-btn.promote:hover {
            background: #0770c2;
            box-shadow: 0 3px 8px rgba(9, 132, 227, 0.3);
        }
        .um-btn.demote {
            background: #636E72;
            color: white;
        }
        .um-btn.demote:hover {
            background: #555;
            box-shadow: 0 3px 8px rgba(99, 110, 114, 0.3);
        }
        .um-btn.super {
            background: #CC0000;
            color: white;
        }
        .um-btn.super:hover {
            background: #a50000;
            box-shadow: 0 3px 8px rgba(204, 0, 0, 0.3);
        }
        .um-btn.delete {
            background: none;
            color: #CC0000;
            border: 1.5px solid #CC0000;
        }
        .um-btn.delete:hover {
            background: #CC0000;
            color: white;
        }
        .um-actions-cell {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }
        .um-empty {
            text-align: center;
            padding: 40px 20px;
            color: #999;
            font-size: 0.95rem;
        }
        .um-you-tag {
            font-size: 0.72rem;
            color: #999;
            font-style: italic;
            margin-left: 6px;
        }

        /* ── Create User Modal extras ── */
        .modal-field .field-hint {
            font-size: 0.78rem;
            color: #999;
            margin-top: 4px;
        }
        .modal-field .field-error {
            font-size: 0.78rem;
            color: #CC0000;
            margin-top: 4px;
            display: none;
        }
        .modal-field .field-error.show {
            display: block;
        }
        .modal-divider {
            height: 1px;
            background: #eee;
            margin: 20px 0;
        }

        /* KPI Config */



        /* Banner build-down animation — matches the Android app cascade */
        @keyframes bannerSlideDown {
            0% {
                opacity: 0;
                transform: translateY(-40px) scaleY(0.96);
            }
            40% {
                opacity: 0.7;
                transform: translateY(-8px) scaleY(0.99);
            }
            100% {
                opacity: 1;
                transform: translateY(0) scaleY(1);
            }
        }

        .header,
        .user-bar,
        .controls,
        .tabs,
        .widget-grid {
            will-change: transform, opacity;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            transform-origin: top center;
            animation-fill-mode: both;
            animation-timing-function: cubic-bezier(0, 0, 0.2, 1); /* Material decelerate */
            animation-name: bannerSlideDown;
        }

        .header {
            animation-duration: 0.35s;
            animation-delay: 0s;
        }

        .user-bar {
            animation-duration: 0.38s;
            animation-delay: 0.12s;
        }

        .controls {
            animation-duration: 0.41s;
            animation-delay: 0.24s;
        }

        .tabs {
            animation-duration: 0.44s;
            animation-delay: 0.36s;
        }

        .widget-grid {
            animation-duration: 0.47s;
            animation-delay: 0.48s;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="header-left">
                <h1 id="dashboardTitle">Efficiency Dashboard</h1>
                <p>Real-time performance insights</p>
            </div>
            <div class="header-right">
                <img src="cr_logo.png" alt="Construction Robotics">
            </div>
        </div>

        <div class="user-bar">
            <span class="user-info">
                <span class="user-icon">
                    <img src="usericon.png" alt="User">
                </span>
                <strong id="currentUserDisplay">—</strong>
            </span>
            <div class="settings-wrapper">
                <button class="btn-settings" onclick="toggleSettingsMenu()" title="Account Settings">
                    <svg viewBox="0 0 24 24"><path d="M19.14 12.94c.04-.31.06-.63.06-.94 0-.31-.02-.63-.06-.94l2.03-1.58a.49.49 0 00.12-.61l-1.92-3.32a.49.49 0 00-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54a.484.484 0 00-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96a.49.49 0 00-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.04.31-.06.63-.06.94s.02.63.06.94l-2.03 1.58a.49.49 0 00-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6A3.6 3.6 0 1112 8.4a3.6 3.6 0 010 7.2z"/></svg>
                </button>
                <div class="settings-dropdown" id="settingsDropdown">
                    <button id="manageUsersBtn" onclick="openManageUsers()" style="display: none;">
                        <svg viewBox="0 0 24 24"><path d="M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5C6.34 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z"/></svg>
                        Manage Users
                    </button>
                    <button onclick="logout()" class="danger">
                        <svg viewBox="0 0 24 24"><path d="M17 7l-1.41 1.41L18.17 11H8v2h10.17l-2.58 2.58L17 17l5-5zM4 5h8V3H4c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h8v-2H4V5z"/></svg>
                        Sign Out
                    </button>
                </div>
            </div>
        </div>
        
        <div class="controls" id="controlsBar">
            <div class="company-select-group" id="companySelectGroup" style="display:none;">
                <label for="companySelect">Company</label>
                <select id="companySelect">
                    <option value="">All Companies</option>
                </select>
            </div>
            <div class="filter-divider" id="filterDivider" style="display:none;"></div>
            <div class="mason-select-group">
                <label for="masonSelect">User</label>
                <select id="masonSelect">
                    <option value="">Loading...</option>
                </select>
            </div>
            <button onclick="showReportModal()" style="background: #636E72; margin-left: auto;">
                Create Performance Review
            </button>
        </div>
        
        <!-- Widget Gallery Modal -->
        <div id="widgetGalleryModal" class="modal" onclick="if(event.target===this)closeWidgetGallery()">
            <div class="modal-content" style="max-width:600px;">
                <h2>Edit Widgets</h2>
                <p style="color:#888;font-size:0.9rem;text-align:center;margin-bottom:16px;">Tap a widget to add or remove it from your dashboard</p>
                <div class="gallery-grid" id="widgetGallery"></div>
                <div class="modal-buttons">
                    <button class="btn-cancel" onclick="closeWidgetGallery()">Close</button>
                </div>
            </div>
        </div>

        <!-- Performance Review Modal -->
        <div id="reportModal" class="modal">
            <div class="modal-content" style="max-width: 640px;">
                <h2>Generate Performance Review</h2>
                <div class="modal-field" id="modalCompanyGroup" style="display:none;">
                    <label for="modalCompanySelect">Company</label>
                    <select id="modalCompanySelect" onchange="filterModalUsers()">
                        <option value="">All Companies</option>
                    </select>
                </div>
                <div class="modal-field">
                    <label for="modalMasonSelect">User</label>
                    <select id="modalMasonSelect">
                        <option value="ALL">All Users</option>
                    </select>
                </div>
                <div class="modal-field">
                    <label for="modalPeriodSelect">Time Period:</label>
                    <select id="modalPeriodSelect">
                        <option value="1">Today</option>
                        <option value="7">Last 7 Days</option>
                        <option value="30" selected>Last 30 Days</option>
                        <option value="90">Last 90 Days (Quarterly)</option>
                        <option value="365">Last Year</option>
                        <option value="all">All Time</option>
                    </select>
                </div>
                <div class="modal-field">
                    <label>Report Sections</label>
                    <div style="display: flex; gap: 6px; margin-bottom: 10px; flex-wrap: wrap;">
                        <button type="button" class="report-preset-btn" onclick="reportPresetAll()">All</button>
                        <button type="button" class="report-preset-btn active" onclick="reportPresetDashboard()">Same as Dashboard</button>
                    </div>
                    <div id="reportSections" class="report-sections-grid"></div>
                </div>
                <div class="modal-buttons">
                    <button class="btn-cancel" onclick="closeReportModal()">Cancel</button>
                    <button class="btn-generate" onclick="generateReport()">Generate Report</button>
                </div>
            </div>
        </div>
        
        <div id="error" class="error" style="display: none;"></div>
        
        <div id="loading" class="loading">Loading dashboard data...</div>
        
        <div id="dashboard" style="display: none; margin-top: -10px; position: relative; z-index: 7;">
            <!-- Tab Navigation -->
            <div class="tabs">
                <button class="tab-button active" onclick="switchTab('overview')">Dashboard</button>
                <button class="tab-button" onclick="switchTab('map')">Map</button>
            </div>
            
            <!-- Overview Tab -->
            <div id="overview-tab" class="tab-content active">
            <div class="widget-edit-bar">
                <button class="widget-add-btn" id="widgetAddBtn" onclick="openWidgetGallery()">Edit Widgets</button>
                <button class="widget-edit-btn" id="widgetEditBtn" onclick="toggleWidgetEdit()">Edit</button>
            </div>
            <div class="widget-grid" id="widgetGrid">
                <!-- Widgets rendered dynamically -->
            </div>
            </div>
            
            <!-- Map Tab -->
            <div id="map-tab" class="tab-content">
                <h2 style="margin-bottom: 15px;">Placement Locations</h2>
                <div class="map-controls" style="position:relative;">
                    <button onclick="fitMapBounds()">Fit All Markers</button>
                    <button onclick="refreshMapData()">Refresh Map</button>
                    <button onclick="toggleMapFullscreen()" id="btnFullscreen" title="Toggle Fullscreen" style="padding:8px 12px;display:flex;align-items:center;gap:5px;">
                        <svg viewBox="0 0 24 24" width="16" height="16" fill="white"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/></svg>
                        Fullscreen
                    </button>
                    <div style="display:flex;gap:6px;margin-left:auto;">
                        <button onclick="setMapFilter('all')" id="mapFilterAll" style="padding:4px 12px;border-radius:6px;border:1px solid #ccc;background:#2D3436;color:white;font-size:0.8rem;font-weight:600;cursor:pointer;">All</button>
                        <button onclick="setMapFilter('placement')" id="mapFilterPlacement" style="padding:4px 12px;border-radius:6px;border:1px solid #ccc;background:transparent;color:#555;font-size:0.8rem;font-weight:600;cursor:pointer;">Placements</button>
                        <button onclick="setMapFilter('pallet')" id="mapFilterPallet" style="padding:4px 12px;border-radius:6px;border:1px solid #ccc;background:transparent;color:#555;font-size:0.8rem;font-weight:600;cursor:pointer;">Pallet</button>
                    </div>
                </div>
                <div id="map" style="max-width:1100px;margin:0 auto;"></div>
            </div>
            
            <!-- Manage Users Tab (admin only) -->
            <div id="manage-users-tab" class="tab-content">
                <div class="um-header">
                    <h2>User Management</h2>
                    <div class="um-actions">
                        <input type="text" class="um-search" id="umSearch" placeholder="Search users..." oninput="filterUserTable()">
                        <button class="btn-add-user" onclick="openCreateUserModal()">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
                            Add User
                        </button>
                    </div>
                </div>

                <div style="overflow-x: auto; border-radius: 10px; box-shadow: 0 2px 8px rgba(0,0,0,0.06);">
                    <table class="um-table" id="userManagementTable">
                        <thead>
                            <tr>
                                <th>Username</th>
                                <th>User ID</th>
                                <th>Company</th>
                                <th>Role</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="userManagementBody">
                            <tr><td colspan="5" class="um-empty">Loading users...</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>

        </div>

        </div>
        
        <div class="last-updated">
            Last updated: <span id="lastUpdated">Never</span>
        </div>
    </div>

    <!-- Create User Modal (outside .container to avoid stacking context issues) -->
    <div id="createUserModal" class="modal" onclick="if(event.target===this)closeCreateUserModal()">
        <div class="modal-content" style="max-width: 480px;">
            <h2>Create New User</h2>
            <div id="createUserError" class="field-error" style="display:none; background:#FFE8E8; color:#CC0000; padding:10px 14px; border-radius:8px; font-size:0.9rem; margin-bottom:16px; border:1px solid #FFCCCC;"></div>
            <div class="modal-field">
                <label for="newUsername">Username</label>
                <input type="text" id="newUsername" placeholder="e.g. jsmith" autocomplete="off">
            </div>
            <div class="modal-field">
                <label for="newPassword">Password</label>
                <input type="password" id="newPassword" placeholder="Minimum 6 characters">
                <div class="field-hint">Must be at least 6 characters</div>
            </div>
            <div class="modal-field">
                <label for="newMasonId">User ID</label>
                <input type="text" id="newMasonId" placeholder="e.g. MASON_JSMITH">
                <div class="field-hint">Unique identifier used by the RFID scanner</div>
            </div>
            <div class="modal-divider"></div>
            <div class="modal-field">
                <label for="newCompany">Company</label>
                <select id="newCompany" onchange="toggleNewCompanyFields()">
                    <option value="">Select a company...</option>
                </select>
                <div id="newCompanyFields" style="display:none; margin-top:12px; padding:16px; background:#f8f9fa; border-radius:8px; border:1.5px dashed #ccc;">
                    <div class="modal-field" style="margin-bottom:12px;">
                        <label for="newCompanyName" style="font-size:0.85rem;">Company Name</label>
                        <input type="text" id="newCompanyName" placeholder="e.g. Acme Construction">
                    </div>
                    <div class="modal-field" style="margin-bottom:0;">
                        <label for="newCompanyCode" style="font-size:0.85rem;">Company Code</label>
                        <input type="text" id="newCompanyCode" placeholder="e.g. ACME" style="text-transform:uppercase;">
                        <div class="field-hint">Short unique code (2-10 chars)</div>
                    </div>
                </div>
            </div>
            <div class="modal-field">
                <label for="newRole">Role</label>
                <select id="newRole">
                    <option value="user">User</option>
                    <option value="company_admin">Company Admin</option>
                </select>
            </div>
            <div class="modal-buttons">
                <button class="btn-cancel" onclick="closeCreateUserModal()">Cancel</button>
                <button class="btn-generate" id="btnCreateUser" onclick="submitCreateUser()">Create User</button>
            </div>
        </div>
    </div>
    
    <script>
        // XSS sanitization helper
        function escapeHtml(str) {
            if (str === null || str === undefined) return '';
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
        }

        const API_BASE = window.location.origin;
        let authToken = localStorage.getItem('dashboard_token');
        let liveChart = null;
        let dailyChart = null;
        let efficiencyChartInstance = null;
        let masonCompareChartInstance = null;
        let hourlyChartInstance = null;
        let placedVsIndexedChartInstance = null;
        let currentMasonId = null;
        let allMasons = [];
        let refreshInterval = null;
        let allPlacements = [];
        let lastPlacementCount = 0;
        let isUpdating = false;
        let mapFilter = 'all'; // 'all', 'placement', 'pallet'
        let widgetEditMode = false;

        // ═══════════════════════════════════════════
        // === WIDGET SYSTEM (Apple-style drag/drop) ===
        // ═══════════════════════════════════════════

        const WIDGET_REGISTRY = {
            // ── KPI widgets ──
            totalPlacements:  { type: 'kpi', label: 'Blocks Placed',         icon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>', description: 'Total placement scans recorded',          color: '#10b981' },
            totalIndexed:     { type: 'kpi', label: 'Blocks Indexed',        icon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"/><rect x="8" y="2" width="8" height="4" rx="1"/></svg>', description: 'Total pallet/index scans recorded',       color: '#3b82f6' },
            daysWorked:       { type: 'kpi', label: 'Days Worked',           icon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="4" width="18" height="18" rx="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>', description: 'Distinct days with activity',              color: '#6366f1' },
            avgPerDay:        { type: 'kpi', label: 'Placements / Day',      icon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="20" x2="12" y2="10"/><line x1="18" y1="20" x2="18" y2="4"/><line x1="6" y1="20" x2="6" y2="16"/></svg>', description: 'Average placements per worked day',       color: '#f97316' },
            currentEfficiency:{ type: 'kpi', label: 'Placements / Hour',     icon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg>', description: 'Placement rate for the most recent day',  color: '#ef4444' },
            activeMasons:     { type: 'kpi', label: 'Active Users',          icon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>', description: 'Number of users with recorded data',      color: '#f59e0b' },
            totalScans:       { type: 'kpi', label: 'Total Scans',           icon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 16.1A5 5 0 0 1 5.9 20M2 12.05A9 9 0 0 1 9.95 20M2 8V6a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-6"/><line x1="2" y1="20" x2="2.01" y2="20"/></svg>', description: 'Combined placed + indexed count',         color: '#8b5cf6' },
            avgPerHourAllTime:{ type: 'kpi', label: 'Avg / Hour (All Time)', icon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>', description: 'Overall placement rate across all days',  color: '#14b8a6' },
            // ── Chart widgets ──
            liveChart:        { type: 'chart', label: 'Live Placements Timeline',  icon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"/></svg>', description: 'Real-time placement activity' },
            dailyChart:       { type: 'chart', label: 'Daily Placement Totals',    icon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="20" x2="18" y2="10"/><line x1="12" y1="20" x2="12" y2="4"/><line x1="6" y1="20" x2="6" y2="14"/></svg>', description: 'Daily totals bar chart' },
            efficiencyChart:  { type: 'chart', label: 'Efficiency Over Time',      icon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 6 13.5 15.5 8.5 10.5 1 18"/><polyline points="17 6 23 6 23 12"/></svg>', description: 'Placements per hour trend line' },
            masonCompareChart:{ type: 'chart', label: 'User Comparison',           icon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><line x1="22" y1="8" x2="22" y2="14"/><line x1="19" y1="11" x2="25" y2="11"/></svg>', description: 'Side-by-side user totals' },
            hourlyChart:      { type: 'chart', label: 'Hourly Activity Pattern',   icon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>', description: 'When placements happen by hour' },
            placedVsIndexed:  { type: 'chart', label: 'Placed vs Indexed',         icon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.21 15.89A10 10 0 1 1 8 2.83"/><path d="M22 12A10 10 0 0 0 12 2v10z"/></svg>', description: 'Placement vs index scan breakdown' }
        };

        const DEFAULT_LAYOUT = [
            'totalPlacements', 'totalIndexed', 'daysWorked', 'avgPerDay', 'currentEfficiency',
            'liveChart', 'dailyChart'
        ];

        function getWidgetLayout() {
            try {
                const saved = localStorage.getItem('dashboard_widget_layout');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    return parsed.filter(k => WIDGET_REGISTRY[k]);
                }
            } catch (e) {}
            return [...DEFAULT_LAYOUT];
        }

        function saveWidgetLayout(layout) {
            localStorage.setItem('dashboard_widget_layout', JSON.stringify(layout));
            // Persist to server (async, fire-and-forget)
            authFetch('/api/user/preferences', {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ preferences: { widgetLayout: layout } })
            }).catch(err => console.warn('Could not sync layout to server:', err));
        }

        // Load widget layout from server on login, merge into localStorage
        async function loadServerWidgetLayout() {
            try {
                const resp = await authFetch('/api/user/preferences');
                if (resp.ok) {
                    const data = await resp.json();
                    if (data.success && data.preferences && Array.isArray(data.preferences.widgetLayout)) {
                        const serverLayout = data.preferences.widgetLayout.filter(k => WIDGET_REGISTRY[k]);
                        if (serverLayout.length > 0) {
                            localStorage.setItem('dashboard_widget_layout', JSON.stringify(serverLayout));
                            renderWidgets();
                            updateDashboard();
                        }
                    }
                }
            } catch (err) {
                console.warn('Could not load layout from server, using local:', err);
            }
        }

        // ── Render all widgets ──
        function renderWidgets() {
            // Destroy existing charts before re-rendering
            if (liveChart) { liveChart.destroy(); liveChart = null; }
            if (dailyChart) { dailyChart.destroy(); dailyChart = null; }
            if (efficiencyChartInstance) { efficiencyChartInstance.destroy(); efficiencyChartInstance = null; }
            if (masonCompareChartInstance) { masonCompareChartInstance.destroy(); masonCompareChartInstance = null; }
            if (hourlyChartInstance) { hourlyChartInstance.destroy(); hourlyChartInstance = null; }
            if (placedVsIndexedChartInstance) { placedVsIndexedChartInstance.destroy(); placedVsIndexedChartInstance = null; }

            const grid = document.getElementById('widgetGrid');
            if (!grid) return;
            const layout = getWidgetLayout();

            let html = layout.map(key => {
                const w = WIDGET_REGISTRY[key];
                if (!w) return '';

                if (w.type === 'kpi') {
                    const borderStyle = w.color ? ` style="border-top:3px solid ${w.color};"` : '';
                    return `<div class="widget widget-kpi" data-widget-id="${key}"${borderStyle}>
                        <div class="drag-handle">⋮⋮⋮</div>
                        <button class="widget-remove" onclick="removeWidget('${key}')">&minus;</button>
                        <h3>${w.label}</h3>
                        <div class="widget-value" id="${key}">0</div>
                    </div>`;
                }

                if (w.type === 'chart') {
                    return `<div class="widget widget-chart" data-widget-id="${key}">
                        <div class="drag-handle">⋮⋮⋮</div>
                        <button class="widget-remove" onclick="removeWidget('${key}')">&minus;</button>
                        <h2>${w.label}</h2>
                        <div class="chart-wrapper"><canvas id="${key}"></canvas></div>
                    </div>`;
                }
                return '';
            }).join('');

            grid.innerHTML = html;

            // Re-apply edit mode state
            if (widgetEditMode) enableDragOnWidgets();
        }

        // ── Toggle edit mode ──
        function toggleWidgetEdit() {
            widgetEditMode = !widgetEditMode;
            const grid = document.getElementById('widgetGrid');
            const btn = document.getElementById('widgetEditBtn');
            if (widgetEditMode) {
                grid.classList.add('editing');
                btn.classList.add('active');
                btn.textContent = 'Done';
                document.getElementById('widgetAddBtn').classList.add('visible');
                enableDragOnWidgets();
            } else {
                grid.classList.remove('editing');
                btn.classList.remove('active');
                btn.textContent = 'Edit';
                document.getElementById('widgetAddBtn').classList.remove('visible');
                disableDragOnWidgets();
            }
        }

        // ── Drag & Drop (pointer-based, works on touch + mouse) ──
        let dragState = null;
        let autoScrollRAF = null;

        function enableDragOnWidgets() {
            document.querySelectorAll('#widgetGrid .widget .drag-handle').forEach(handle => {
                handle.addEventListener('pointerdown', handlePointerDown);
            });
        }

        function disableDragOnWidgets() {
            document.querySelectorAll('#widgetGrid .widget .drag-handle').forEach(handle => {
                handle.removeEventListener('pointerdown', handlePointerDown);
            });
        }

        function startAutoScroll() {
            function tick() {
                if (!dragState) return;
                const y = dragState.lastClientY;
                const edge = 60; // px from edge to start scrolling
                const maxSpeed = 18;
                if (y < edge) {
                    const speed = Math.ceil(maxSpeed * (1 - y / edge));
                    window.scrollBy(0, -speed);
                } else if (y > window.innerHeight - edge) {
                    const speed = Math.ceil(maxSpeed * (1 - (window.innerHeight - y) / edge));
                    window.scrollBy(0, speed);
                }
                autoScrollRAF = requestAnimationFrame(tick);
            }
            autoScrollRAF = requestAnimationFrame(tick);
        }

        function stopAutoScroll() {
            if (autoScrollRAF) { cancelAnimationFrame(autoScrollRAF); autoScrollRAF = null; }
        }

        function handlePointerDown(e) {
            e.preventDefault();
            const widget = this.closest('.widget');
            if (!widget) return;

            const grid = document.getElementById('widgetGrid');
            const rect = widget.getBoundingClientRect();

            // Create a floating clone
            const clone = widget.cloneNode(true);
            clone.style.position = 'fixed';
            clone.style.width = rect.width + 'px';
            clone.style.height = rect.height + 'px';
            clone.style.left = rect.left + 'px';
            clone.style.top = rect.top + 'px';
            clone.style.zIndex = '9999';
            clone.style.opacity = '0.85';
            clone.style.pointerEvents = 'none';
            clone.style.boxShadow = '0 8px 32px rgba(0,0,0,0.25)';
            clone.style.transition = 'none';
            clone.style.transform = 'scale(1.03)';
            document.body.appendChild(clone);

            widget.classList.add('dragging');

            dragState = {
                widget,
                clone,
                widgetId: widget.dataset.widgetId,
                offsetX: e.clientX - rect.left,
                offsetY: e.clientY - rect.top,
                lastClientY: e.clientY,
                grid
            };

            startAutoScroll();
            document.addEventListener('pointermove', handlePointerMove);
            document.addEventListener('pointerup', handlePointerUp);
        }

        function removeDropIndicator() {
            const old = document.querySelector('.drop-indicator');
            if (old) old.remove();
        }

        function getVisualRow(targetWidget) {
            // Find all widgets on the same visual row (same top position, ±2px tolerance)
            const widgets = [...dragState.grid.querySelectorAll('.widget')];
            const tRect = targetWidget.getBoundingClientRect();
            const rowWidgets = widgets.filter(w => {
                if (w === dragState.widget) return false;
                const r = w.getBoundingClientRect();
                return Math.abs(r.top - tRect.top) < 4;
            });
            // Sort by left position
            rowWidgets.sort((a, b) => a.getBoundingClientRect().left - b.getBoundingClientRect().left);
            return rowWidgets;
        }

        function getDropInfo(e) {
            const widgets = [...dragState.grid.querySelectorAll('.widget')];
            for (const w of widgets) {
                if (w === dragState.widget) continue;
                const r = w.getBoundingClientRect();
                if (e.clientX >= r.left && e.clientX <= r.right && e.clientY >= r.top && e.clientY <= r.bottom) {
                    const midY = r.top + r.height / 2;
                    const before = e.clientY < midY;
                    // Snap to row boundary: before → first in row, after → last in row
                    const row = getVisualRow(w);
                    if (row.length > 1) {
                        const snapTarget = before ? row[0] : row[row.length - 1];
                        return { target: snapTarget, before, row };
                    }
                    return { target: w, before, row };
                }
            }
            return null;
        }

        function showDropIndicator(targetWidget, before, row) {
            removeDropIndicator();
            const indicator = document.createElement('div');
            indicator.className = 'drop-indicator';

            const grid = dragState.grid;
            const gridRect = grid.getBoundingClientRect();

            // Span full grid width for rows with multiple widgets
            if (row && row.length > 1) {
                const firstRect = row[0].getBoundingClientRect();
                const lastRect = row[row.length - 1].getBoundingClientRect();
                indicator.style.left = (firstRect.left - gridRect.left) + 'px';
                indicator.style.width = (lastRect.right - firstRect.left) + 'px';
                if (before) {
                    indicator.style.top = (firstRect.top - gridRect.top - 6) + 'px';
                } else {
                    indicator.style.top = (lastRect.bottom - gridRect.top + 2) + 'px';
                }
            } else {
                const tRect = targetWidget.getBoundingClientRect();
                indicator.style.left = (tRect.left - gridRect.left) + 'px';
                indicator.style.width = tRect.width + 'px';
                if (before) {
                    indicator.style.top = (tRect.top - gridRect.top - 6) + 'px';
                } else {
                    indicator.style.top = (tRect.bottom - gridRect.top + 2) + 'px';
                }
            }

            grid.style.position = 'relative';
            grid.appendChild(indicator);
        }

        function handlePointerMove(e) {
            if (!dragState) return;
            e.preventDefault();

            dragState.lastClientY = e.clientY;

            // Move clone
            dragState.clone.style.left = (e.clientX - dragState.offsetX) + 'px';
            dragState.clone.style.top = (e.clientY - dragState.offsetY) + 'px';

            // Show drop indicator line
            const info = getDropInfo(e);
            if (info) {
                showDropIndicator(info.target, info.before, info.row);
                dragState.dropInfo = info;
            } else {
                removeDropIndicator();
                dragState.dropInfo = null;
            }
        }

        function handlePointerUp(e) {
            if (!dragState) return;
            stopAutoScroll();
            document.removeEventListener('pointermove', handlePointerMove);
            document.removeEventListener('pointerup', handlePointerUp);

            removeDropIndicator();
            dragState.widget.classList.remove('dragging');

            // Use last known drop info
            const info = dragState.dropInfo || getDropInfo(e);

            // Remove clone
            dragState.clone.remove();

            if (info) {
                const layout = getWidgetLayout();
                const fromId = dragState.widgetId;
                const toId = info.target.dataset.widgetId;
                const fromIdx = layout.indexOf(fromId);
                let toIdx = layout.indexOf(toId);

                if (fromIdx !== -1 && toIdx !== -1) {
                    layout.splice(fromIdx, 1);
                    // Recalculate toIdx after removal
                    toIdx = layout.indexOf(toId);
                    // Insert before or after based on cursor position
                    const insertIdx = info.before ? toIdx : toIdx + 1;
                    layout.splice(insertIdx, 0, fromId);
                    saveWidgetLayout(layout);
                    renderWidgets();
                    if (typeof refreshData === 'function') refreshData();
                }
            }

            dragState = null;
        }

        // ── Remove widget ──
        function removeWidget(key) {
            const layout = getWidgetLayout();
            const idx = layout.indexOf(key);
            if (idx !== -1) {
                layout.splice(idx, 1);
                saveWidgetLayout(layout);
                renderWidgets();
                if (typeof refreshData === 'function') refreshData();
            }
        }

        // ── Widget Gallery ──
        function openWidgetGallery() {
            const layout = getWidgetLayout();
            const gallery = document.getElementById('widgetGallery');
            gallery.innerHTML = Object.entries(WIDGET_REGISTRY).map(([key, w]) => {
                const added = layout.includes(key);
                return `<div class="gallery-item${added ? ' already-added' : ''}" onclick="toggleWidget('${key}')">
                    <div class="gallery-icon">${w.icon}</div>
                    <div class="gallery-name">${w.label}</div>
                    <div class="gallery-desc">${added ? '✓ Added' : w.description}</div>
                </div>`;
            }).join('');
            document.getElementById('widgetGalleryModal').classList.add('show');
        }

        function closeWidgetGallery() {
            document.getElementById('widgetGalleryModal').classList.remove('show');
        }

        function toggleWidget(key) {
            const layout = getWidgetLayout();
            const idx = layout.indexOf(key);
            if (idx >= 0) {
                // Remove widget
                layout.splice(idx, 1);
            } else {
                // Add widget at end — user can drag it wherever they want
                layout.push(key);
            }
            saveWidgetLayout(layout);
            renderWidgets();
            openWidgetGallery();
            if (typeof refreshData === 'function') refreshData();
        }

        // ── Initial render ──
        renderWidgets();
        
        // Role awareness
        const userRole = localStorage.getItem('dashboard_role') || 'user';
        const isSuperAdmin = localStorage.getItem('dashboard_isSuperAdmin') === 'true';
        const isCompanyAdmin = localStorage.getItem('dashboard_isCompanyAdmin') === 'true';
        const isAnyAdmin = isSuperAdmin || isCompanyAdmin;
        const userCompanyRaw = localStorage.getItem('dashboard_company');
        const userCompany = userCompanyRaw ? JSON.parse(userCompanyRaw) : null;
        
        // Redirect to login page if not authenticated
        if (!authToken) {
            window.location.href = '/';
        }

        // Show current user in the user bar (with role badge)
        const currentUser = localStorage.getItem('dashboard_user');
        if (currentUser) {
            let displayText = currentUser;
            if (isSuperAdmin) {
                displayText += ' (Super Admin)';
            } else if (isCompanyAdmin) {
                displayText += ' (Company Admin)';
            }
            document.getElementById('currentUserDisplay').textContent = displayText;
        }

        // Authenticated fetch wrapper — attaches Bearer token to all API calls
        async function authFetch(url, options = {}) {
            if (!authToken) {
                window.location.href = '/';
                throw new Error('Not authenticated');
            }
            const headers = { ...(options.headers || {}), 'Authorization': `Bearer ${authToken}` };
            let response = await fetch(url, { ...options, headers });
            // If token expired, redirect to login
            if (response.status === 401) {
                logout();
                throw new Error('Session expired');
            }
            return response;
        }

        // Logout — clear all stored auth data and redirect to login
        function logout() {
            localStorage.removeItem('dashboard_token');
            localStorage.removeItem('dashboard_user');
            localStorage.removeItem('dashboard_pass');
            localStorage.removeItem('dashboard_masonId');
            localStorage.removeItem('dashboard_isAdmin');
            localStorage.removeItem('dashboard_role');
            localStorage.removeItem('dashboard_isSuperAdmin');
            localStorage.removeItem('dashboard_isCompanyAdmin');
            localStorage.removeItem('dashboard_company');
            window.location.href = '/';
        }

        // Settings cog dropdown
        function toggleSettingsMenu() {
            document.getElementById('settingsDropdown').classList.toggle('open');
        }

        // Open Manage Users tab from cog menu
        function openManageUsers() {
            document.getElementById('settingsDropdown').classList.remove('open');
            switchTab('manage-users');
        }

        document.addEventListener('click', function(e) {
            const wrapper = document.querySelector('.settings-wrapper');
            if (wrapper && !wrapper.contains(e.target)) {
                document.getElementById('settingsDropdown').classList.remove('open');
            }
        });
        
        // Map variables
        let map = null;
        let markers = [];
        let markerGroup = null;
        let wallPolygons = [];
        let cachedPlacementScans = null;
        let cachedPalletScans = null;
        let isZoomRender = false;
        
        // Color palette for different masons
        const masonColors = [
            '#FF0000', '#0066FF', '#00CC00', '#FF6600', 
            '#AA00FF', '#00CCCC', '#FF00AA', '#CCCC00',
            '#FF3399', '#00FF66', '#3366FF', '#FF9900'
        ];
        
        // Helper function to get consistent color for a mason
        function getMasonColor(masonId, allMasonIds = null) {
            // If we have all mason IDs, use them for consistent ordering
            if (allMasonIds) {
                const sortedMasons = [...allMasonIds].sort();
                const index = sortedMasons.indexOf(masonId);
                return index >= 0 ? masonColors[index % masonColors.length] : '#CC0000';
            }
            // Fallback: get unique masons from allPlacements
            if (allPlacements.length > 0) {
                const sortedMasons = [...new Set(allPlacements.map(p => p.mason_id || p.masonId))].sort();
                const index = sortedMasons.indexOf(masonId);
                return index >= 0 ? masonColors[index % masonColors.length] : '#CC0000';
            }
            return '#CC0000';
        }
        
        // Clustering parameters
        // Zoom-based cluster distance: zoomed out = absorb, zoomed in = break apart
        // Even at max zoom, overlapping points within 3m merge so you can click them
        function getClusterDistance(zoom) {
            // Conservative clustering — only merge truly nearby scans
            if (zoom >= 20) return 3;
            if (zoom >= 19) return 5;
            if (zoom >= 18) return 8;
            if (zoom >= 17) return 12;
            if (zoom >= 16) return 18;
            if (zoom >= 15) return 30;
            if (zoom >= 14) return 50;
            if (zoom >= 13) return 120;
            if (zoom >= 12) return 250;
            if (zoom >= 10) return 600;
            if (zoom >= 8) return 2000;
            return 5000;
        }

        // After geographic clustering, merge any clusters whose markers
        // would visually overlap on screen. Guarantees zero icon stacking.
        function mergeOverlappingClusters(clusters, markerSizePx) {
            if (!map || clusters.length <= 1) return clusters;

            // Markers display at scale(0.5), so visual size is half
            const minPixelDist = markerSizePx * 0.55;
            let merged = clusters.map(c => [...c]); // deep copy
            let changed = true;

            while (changed) {
                changed = false;
                for (let i = 0; i < merged.length; i++) {
                    const ci = merged[i];
                    const latI = ci.reduce((s, p) => s + p.latitude, 0) / ci.length;
                    const lngI = ci.reduce((s, p) => s + p.longitude, 0) / ci.length;
                    const pxI = map.latLngToContainerPoint(L.latLng(latI, lngI));

                    for (let j = i + 1; j < merged.length; j++) {
                        const cj = merged[j];
                        const latJ = cj.reduce((s, p) => s + p.latitude, 0) / cj.length;
                        const lngJ = cj.reduce((s, p) => s + p.longitude, 0) / cj.length;
                        const pxJ = map.latLngToContainerPoint(L.latLng(latJ, lngJ));

                        const dx = pxI.x - pxJ.x;
                        const dy = pxI.y - pxJ.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < minPixelDist) {
                            // Merge j into i
                            merged[i] = ci.concat(cj);
                            merged.splice(j, 1);
                            changed = true;
                            break;
                        }
                    }
                    if (changed) break; // restart outer loop after merge
                }
            }
            return merged;
        }
        
        // Tab switching function
        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            // Highlight the matching tab button if one exists (manage-users has no tab button)
            const matchingBtn = document.querySelector(`.tab-button[onclick*="'${tabName}'"]`);
            if (matchingBtn) {
                matchingBtn.classList.add('active');
            }
            
            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(tabName + '-tab').classList.add('active');
            
            // Initialize map when switching to map tab
            if (tabName === 'map' && !map) {
                setTimeout(() => initializeMap(), 100);
            }
        }
        
        // Initialize Leaflet Map
        async function initializeMap() {
            const mapDiv = document.getElementById('map');
            if (!mapDiv || map) return;
            
            // Create map centered on USA
            map = L.map('map').setView([39.8283, -98.5795], 4);
            
            // Add OpenStreetMap tiles (free, no API key needed)
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: 'Â© OpenStreetMap contributors',
                maxZoom: 19
            }).addTo(map);
            
            // Create marker group for easy management
            markerGroup = L.layerGroup().addTo(map);
            
            // Re-render on zoom change so markers cluster/uncluster dynamically
            map.on('zoomend', function() {
                if (cachedPlacementScans || cachedPalletScans) {
                    renderMapFromCache();
                }
            });
            
            loadMapData();
        }
        
        // Re-render map from cached data (called on zoom change)
        function renderMapFromCache() {
            isZoomRender = true;
            const zoom = map.getZoom();
            const clusterDist = getClusterDistance(zoom);
            
            if (mapFilter === 'pallet') {
                if (cachedPalletScans) updateMapWithPalletBubbles(cachedPalletScans);
            } else if (mapFilter === 'placement') {
                if (cachedPlacementScans) renderPlacementBubbles(cachedPlacementScans);
            } else {
                // "all" mode: always use combined renderer
                const allScans = [...(cachedPlacementScans || []), ...(cachedPalletScans || [])];
                if (allScans.length > 0) renderCombinedBubbles(allScans);
            }
            isZoomRender = false;
        }
        
        // Load placement data for map
        async function loadMapData() {
            try {
                const masonId = document.getElementById('masonSelect').value;
                const url = masonId ? 
                    `${API_BASE}/api/placements/mason/${masonId}` : 
                    `${API_BASE}/api/placements/recent?limit=500`;
                
                const response = await authFetch(url);
                const data = await response.json();
                
                if (data.success && data.placements) {
                    const all = data.placements;
                    
                    // Cache the data for zoom-based re-rendering
                    cachedPlacementScans = all.filter(p => (p.scan_type || p.scanType || 'placement') !== 'pallet');
                    cachedPalletScans = all.filter(p => (p.scan_type || p.scanType || 'placement') === 'pallet');
                    
                    if (mapFilter === 'pallet') {
                        updateMapWithPalletBubbles(cachedPalletScans);
                    } else if (mapFilter === 'placement') {
                        renderPlacementBubbles(cachedPlacementScans);
                    } else {
                        // 'all' — always use combined renderer
                        renderCombinedBubbles([...cachedPlacementScans, ...cachedPalletScans]);
                    }
                }
            } catch (error) {
                console.error('Error loading map data:', error);
            }
        }
        
        // Calculate distance between two GPS points in meters
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371e3; // Earth radius in meters
            const phi1 = lat1 * Math.PI / 180;
            const phi2 = lat2 * Math.PI / 180;
            const dPhi = (lat2 - lat1) * Math.PI / 180;
            const dLambda = (lon2 - lon1) * Math.PI / 180;
            
            const a = Math.sin(dPhi/2) * Math.sin(dPhi/2) +
                    Math.cos(phi1) * Math.cos(phi2) *
                    Math.sin(dLambda/2) * Math.sin(dLambda/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            
            return R * c;
        }
        

        // Build a diagonal CSS gradient from mason proportions in a cluster
        // Returns a CSS background value: solid color for 1 mason, diagonal gradient for multi-mason
        function getMasonGradient(cluster, uniqueMasons) {
            const masons = [...new Set(cluster.map(p => p.mason_id || p.masonId))];
            if (masons.length === 1) {
                const idx = uniqueMasons.indexOf(masons[0]);
                return idx >= 0 ? masonColors[idx % masonColors.length] : '#CC0000';
            }
            // Count per mason, sorted by count descending
            const counts = masons.map(m => ({
                mason: m,
                count: cluster.filter(p => (p.mason_id || p.masonId) === m).length,
                color: (() => { const i = uniqueMasons.indexOf(m); return i >= 0 ? masonColors[i % masonColors.length] : '#CC0000'; })()
            })).sort((a, b) => b.count - a.count);
            const total = cluster.length;
            // Build gradient stops
            let pct = 0;
            const stops = [];
            counts.forEach(c => {
                const end = pct + (c.count / total) * 100;
                stops.push(`${c.color} ${pct.toFixed(1)}%`);
                stops.push(`${c.color} ${end.toFixed(1)}%`);
                pct = end;
            });
            return `linear-gradient(135deg, ${stops.join(', ')})`;
        }
        
        // Simple proximity-only clustering (no time/direction constraints)
        // Used when zoomed out so everything merges properly
        function clusterByProximity(placements, maxDist) {
            const clusters = [];
            const visited = new Set();
            placements.forEach((p, idx) => {
                if (visited.has(idx)) return;
                const cluster = [p];
                const queue = [p];
                visited.add(idx);
                while (queue.length > 0) {
                    const current = queue.shift();
                    placements.forEach((other, otherIdx) => {
                        if (visited.has(otherIdx)) return;
                        const dist = calculateDistance(
                            current.latitude, current.longitude,
                            other.latitude, other.longitude
                        );
                        if (dist <= maxDist) {
                            cluster.push(other);
                            queue.push(other);
                            visited.add(otherIdx);
                        }
                    });
                }
                clusters.push(cluster);
            });
            return clusters;
        }
        
        // Render ALL scans (placements + pallets) as unified combined bubbles
        // Used in "all" mode at every zoom level.
        // Zoom <= 14: "Job Site #N" neutral bubbles (everything clusters into sites)
        // Zoom > 14: individual/combined bubbles with brick + pallet icons
        function renderCombinedBubbles(allScans) {
            if (!map || !markerGroup) return;
            
            markerGroup.clearLayers();
            markers = [];
            wallPolygons.forEach(p => p.remove());
            wallPolygons = [];
            
            const valid = allScans.filter(p =>
                p.latitude && p.longitude &&
                p.latitude !== 0 && p.longitude !== 0
            );
            if (valid.length === 0) return;
            
            const zoom = map.getZoom();
            const clusterDist = getClusterDistance(zoom);
            const geoClusters = clusterByProximity(valid, clusterDist);
            const isJobSiteMode = zoom <= 14;
            const mergePx = isJobSiteMode ? 120 : 100;
            const clusters = mergeOverlappingClusters(geoClusters, mergePx);
            const bounds = L.latLngBounds();
            const uniqueMasons = [...new Set(valid.map(p => p.mason_id || p.masonId))];
            
            clusters.forEach((cluster, clusterIndex) => {
                const avgLat = cluster.reduce((s, p) => s + p.latitude, 0) / cluster.length;
                const avgLng = cluster.reduce((s, p) => s + p.longitude, 0) / cluster.length;
                const latlng = [avgLat, avgLng];
                
                const placementItems = cluster.filter(p => (p.scan_type || p.scanType || 'placement') !== 'pallet');
                const palletItems = cluster.filter(p => (p.scan_type || p.scanType || 'placement') === 'pallet');
                const pCount = placementItems.length;
                const kCount = palletItems.length;
                const total = cluster.length;
                const hasBoth = pCount > 0 && kCount > 0;
                const palletOnly = pCount === 0 && kCount > 0;
                
                const masons = [...new Set(cluster.map(p => p.mason_id || p.masonId))];
                const primaryMason = masons[0];
                const masonIndex = uniqueMasons.indexOf(primaryMason);
                const bgStyle = getMasonGradient(cluster, uniqueMasons);
                const popupColor = masonIndex >= 0 ? masonColors[masonIndex % masonColors.length] : '#555';
                
                let innerHtml, markerW, pinHeight;
                
                if (isJobSiteMode) {
                    // === JOB SITE MODE: neutral square-rounded bubble with "Job Site #N" ===
                    const siteNum = clusterIndex + 1;
                    const bSize = 68;
                    markerW = 160;
                    pinHeight = bSize + 12;
                    
                    // Toolbox icon — white outline, no tools inside
                    const toolSvg = `<svg viewBox="0 0 24 24" width="28" height="28" fill="none" stroke="white" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" style="flex-shrink:0;opacity:0.95;">
                      <path d="M9 5V3.5A1.5 1.5 0 0 1 10.5 2h3A1.5 1.5 0 0 1 15 3.5V5"/>
                      <rect x="2" y="5" width="20" height="16" rx="2"/>
                      <line x1="2" y1="12" x2="22" y2="12"/>
                      <rect x="9" y="14.5" width="6" height="2" rx="1"/>
                    </svg>`;
                    
                    innerHtml = `
                        <div style="
                            height:${bSize}px;
                            border-radius:10px;
                            background:#5a6577;
                            border:3px solid white;
                            display:flex;align-items:center;justify-content:center;
                            padding:0 16px;gap:10px;
                        ">
                            ${toolSvg}
                            <span style="color:white;font-weight:800;font-size:18px;line-height:1;text-shadow:0 1px 2px rgba(0,0,0,0.5);white-space:nowrap;">Job Site ${siteNum}</span>
                        </div>
                        <div style="width:0;height:0;border-left:8px solid transparent;border-right:8px solid transparent;border-top:12px solid white;margin-top:-1px;"></div>`;
                } else {
                    // === DETAILED MODE: individual brick/pallet icons ===
                    const bubbleSize = Math.max(36, Math.min(64, 28 + Math.log2(total + 1) * 8));
                    
                    // Brick SVG
                    const brickSvg = `<svg viewBox="0 0 24 18" width="${bubbleSize * 0.5}" height="${bubbleSize * 0.38}" style="opacity:0.9;"><rect x="0" y="0" width="11" height="5" rx="0.5" fill="white" opacity="0.9"/><rect x="13" y="0" width="11" height="5" rx="0.5" fill="white" opacity="0.9"/><rect x="0" y="6.5" width="5" height="5" rx="0.5" fill="white" opacity="0.9"/><rect x="7" y="6.5" width="10" height="5" rx="0.5" fill="white" opacity="0.9"/><rect x="19" y="6.5" width="5" height="5" rx="0.5" fill="white" opacity="0.9"/><rect x="0" y="13" width="11" height="5" rx="0.5" fill="white" opacity="0.9"/><rect x="13" y="13" width="11" height="5" rx="0.5" fill="white" opacity="0.9"/></svg>`;
                    
                    // Pallet SVG
                    const palletSvg = `<svg viewBox="0 0 32 32" width="${bubbleSize * 0.45}" height="${bubbleSize * 0.45}" style="opacity:0.9;"><rect x="1" y="3" width="30" height="4" rx="1" fill="white" opacity="0.9"/><rect x="1" y="13" width="30" height="4" rx="1" fill="white" opacity="0.9"/><rect x="1" y="23" width="30" height="4" rx="1" fill="white" opacity="0.9"/><rect x="3" y="8" width="2" height="4" fill="white" opacity="0.5"/><rect x="15" y="8" width="2" height="4" fill="white" opacity="0.5"/><rect x="27" y="8" width="2" height="4" fill="white" opacity="0.5"/><rect x="3" y="18" width="2" height="4" fill="white" opacity="0.5"/><rect x="15" y="18" width="2" height="4" fill="white" opacity="0.5"/><rect x="27" y="18" width="2" height="4" fill="white" opacity="0.5"/></svg>`;
                    
                    if (hasBoth) {
                        // White bubble container with two separate colored square icons inside
                        const placementBg = getMasonGradient(placementItems, uniqueMasons);
                        const palletBg = getMasonGradient(palletItems, uniqueMasons);
                        const iconSize = bubbleSize - 6;
                        const gap = 6;
                        markerW = iconSize * 2 + gap + 16;
                        pinHeight = bubbleSize + 18;
                        innerHtml = `
                            <div style="
                                display:flex;align-items:center;justify-content:center;
                                border-radius:8px;
                                background:white;
                                padding:5px;
                                gap:${gap}px;
                            ">
                                <div style="
                                    width:${iconSize}px;height:${iconSize}px;
                                    border-radius:5px;
                                    background:${placementBg};
                                    display:flex;flex-direction:column;align-items:center;justify-content:center;
                                ">
                                    ${brickSvg}
                                    <span style="color:white;font-weight:800;font-size:${pCount > 99 ? 9 : 11}px;line-height:1;margin-top:2px;text-shadow:0 1px 2px rgba(0,0,0,0.5);">${pCount}</span>
                                </div>
                                <div style="
                                    width:${iconSize}px;height:${iconSize}px;
                                    border-radius:5px;
                                    background:${palletBg};
                                    display:flex;flex-direction:column;align-items:center;justify-content:center;
                                ">
                                    ${palletSvg}
                                    <span style="color:white;font-weight:800;font-size:${kCount > 99 ? 9 : 11}px;line-height:1;margin-top:2px;text-shadow:0 1px 2px rgba(0,0,0,0.5);">${kCount}</span>
                                </div>
                            </div>
                            <div style="width:0;height:0;border-left:8px solid transparent;border-right:8px solid transparent;border-top:12px solid white;margin-top:-1px;"></div>`;
                    } else if (palletOnly) {
                        markerW = bubbleSize;
                        pinHeight = bubbleSize + 12;
                        innerHtml = `
                            <div style="
                                width:${bubbleSize}px;height:${bubbleSize}px;
                                border-radius:6px;
                                background:${bgStyle};
                                border:3px solid white;
                                display:flex;flex-direction:column;align-items:center;justify-content:center;
                            ">
                                ${palletSvg}
                                <span style="color:white;font-weight:800;font-size:${kCount > 99 ? 10 : 12}px;line-height:1;margin-top:2px;text-shadow:0 1px 2px rgba(0,0,0,0.5);">${kCount}</span>
                            </div>
                            <div style="width:0;height:0;border-left:8px solid transparent;border-right:8px solid transparent;border-top:12px solid white;margin-top:-1px;"></div>`;
                    } else {
                        markerW = bubbleSize;
                        pinHeight = bubbleSize + 12;
                        innerHtml = `
                            <div style="
                                width:${bubbleSize}px;height:${bubbleSize}px;
                                border-radius:6px;
                                background:${bgStyle};
                                border:3px solid white;
                                display:flex;flex-direction:column;align-items:center;justify-content:center;
                            ">
                                ${brickSvg}
                                <span style="color:white;font-weight:800;font-size:${pCount > 99 ? 10 : 12}px;line-height:1;margin-top:2px;text-shadow:0 1px 2px rgba(0,0,0,0.5);">${pCount}</span>
                            </div>
                            <div style="width:0;height:0;border-left:8px solid transparent;border-right:8px solid transparent;border-top:12px solid white;margin-top:-1px;"></div>`;
                    }
                    
                    if (!pinHeight) pinHeight = 48;
                }

                const icon = L.divIcon({
                    className: 'pallet-bubble-marker',
                    html: `<div class="combined-pin-inner" style="
                        display:flex;flex-direction:column;align-items:center;
                        cursor:pointer;filter:drop-shadow(0 3px 6px rgba(0,0,0,0.35));
                        transform:scale(0.5);transition:transform 0.2s ease;transform-origin:bottom center;
                    ">
                        ${innerHtml}
                    </div>`,
                    iconSize: [markerW, pinHeight],
                    iconAnchor: [markerW / 2, pinHeight]
                });
                
                const marker = L.marker(latlng, { icon: icon });
                marker.on('mouseover', function() {
                    const el = this._icon.querySelector('.combined-pin-inner');
                    if (el) { el.style.transform = 'scale(1)'; this._icon.style.zIndex = 9999; }
                });
                marker.on('mouseout', function() {
                    const el = this._icon.querySelector('.combined-pin-inner');
                    if (el) { el.style.transform = 'scale(0.5)'; this._icon.style.zIndex = ''; }
                });
                
                // Popup with full breakdown
                const avgAlt = cluster.reduce((s, p) => s + (p.altitude || 0), 0) / cluster.length;
                const timeRange = cluster.length > 1
                    ? `${new Date(Math.min(...cluster.map(p => p.timestamp))).toLocaleString()} \u2014 ${new Date(Math.max(...cluster.map(p => p.timestamp))).toLocaleString()}`
                    : new Date(cluster[0].timestamp).toLocaleString();
                const masonBreakdown = masons.map(m => {
                    const c = cluster.filter(p => (p.mason_id || p.masonId) === m).length;
                    const mi = uniqueMasons.indexOf(m);
                    const mc = mi >= 0 ? masonColors[mi % masonColors.length] : '#555';
                    return `<span style="color:${mc};font-weight:bold;">${m}</span>: ${c} scan${c > 1 ? 's' : ''}`;
                }).join('<br>');
                
                const siteLabel = isJobSiteMode ? `<h3 style="margin:0 0 4px 0;color:#5a6577;">Job Site ${clusterIndex + 1}</h3>` : '';
                const popupContent = `
                    <div style="padding:10px;font-family:Arial;min-width:220px;">
                        ${siteLabel}
                        <h3 style="margin:0 0 8px 0;color:${popupColor};">
                            ${total} Scan${total > 1 ? 's' : ''}
                        </h3>
                        ${pCount > 0 ? `<p style="margin:4px 0;font-size:0.9em;"><strong>Placements:</strong> ${pCount}</p>` : ''}
                        ${kCount > 0 ? `<p style="margin:4px 0;font-size:0.9em;"><strong>Pallet:</strong> ${kCount}</p>` : ''}
                        <p style="margin:4px 0;font-size:0.9em;"><strong>Masons:</strong> ${masons.length}</p>
                        <p style="margin:4px 0;font-size:0.9em;"><strong>Location:</strong> ${avgLat.toFixed(6)}, ${avgLng.toFixed(6)}</p>
                        <p style="margin:4px 0;font-size:0.9em;"><strong>Avg Altitude:</strong> ${avgAlt.toFixed(1)} m</p>
                        <p style="margin:4px 0;font-size:0.9em;"><strong>Time:</strong> ${timeRange}</p>
                        <div style="margin-top:8px;padding-top:8px;border-top:1px solid #ddd;">
                            <strong>Mason Breakdown:</strong><br>${masonBreakdown}
                        </div>
                    </div>
                `;
                marker.bindPopup(popupContent, { maxWidth: 400 });
                marker.addTo(markerGroup);
                markers.push(marker);
                bounds.extend(latlng);
            });
            
            if (bounds.isValid() && !isZoomRender) {
                map.fitBounds(bounds, { padding: [50, 50] });
            }
        }
        
        // Render placements as proximity-clustered bubbles at every zoom level
        // Overlapping points always combine so nothing blocks anything
        function renderPlacementBubbles(placements) {
            if (!map || !markerGroup) return;
            
            markerGroup.clearLayers();
            markers = [];
            wallPolygons.forEach(p => p.remove());
            wallPolygons = [];
            
            const validPlacements = placements.filter(p =>
                p.latitude && p.longitude &&
                p.latitude !== 0 && p.longitude !== 0
            );
            if (validPlacements.length === 0) return;
            
            const zoom = map.getZoom();
            const clusterDist = getClusterDistance(zoom);
            const geoClusters = clusterByProximity(validPlacements, clusterDist);
            // Second pass: merge clusters that would visually overlap on screen
            const clusters = mergeOverlappingClusters(geoClusters, 64);
            const bounds = L.latLngBounds();
            const uniqueMasons = [...new Set(validPlacements.map(p => p.mason_id || p.masonId))];
            
            clusters.forEach(cluster => {
                renderPlacementClusterBubble(cluster, uniqueMasons, bounds);
            });
            
            if (bounds.isValid() && !isZoomRender) {
                map.fitBounds(bounds, { padding: [50, 50] });
            }
        }
        
        // Render a cluster of placements as a single bubble pin with brick icon + count
        function renderPlacementClusterBubble(cluster, uniqueMasons, bounds) {
            const avgLat = cluster.reduce((s, p) => s + p.latitude, 0) / cluster.length;
            const avgLng = cluster.reduce((s, p) => s + p.longitude, 0) / cluster.length;
            const latlng = [avgLat, avgLng];
            const count = cluster.length;
            const masons = [...new Set(cluster.map(p => p.mason_id || p.masonId))];
            const primaryMason = masons[0];
            const masonIndex = uniqueMasons.indexOf(primaryMason);
            // Diagonal gradient when multiple masons, solid color for single mason
            const bgStyle = getMasonGradient(cluster, uniqueMasons);
            const popupColor = masonIndex >= 0 ? masonColors[masonIndex % masonColors.length] : '#CC0000';

            // Log scale: 1→32, 5→40, 12→45, 50→56, 200→64 (max 64)
            const bubbleSize = Math.max(32, Math.min(64, 28 + Math.log2(count + 1) * 8));
            const halfSize = bubbleSize / 2;
            const brickSvg = `<svg viewBox="0 0 24 18" width="${bubbleSize * 0.5}" height="${bubbleSize * 0.38}" style="opacity:0.9;"><rect x="0" y="0" width="11" height="5" rx="0.5" fill="white" opacity="0.9"/><rect x="13" y="0" width="11" height="5" rx="0.5" fill="white" opacity="0.9"/><rect x="0" y="6.5" width="5" height="5" rx="0.5" fill="white" opacity="0.9"/><rect x="7" y="6.5" width="10" height="5" rx="0.5" fill="white" opacity="0.9"/><rect x="19" y="6.5" width="5" height="5" rx="0.5" fill="white" opacity="0.9"/><rect x="0" y="13" width="11" height="5" rx="0.5" fill="white" opacity="0.9"/><rect x="13" y="13" width="11" height="5" rx="0.5" fill="white" opacity="0.9"/></svg>`;

            const pinHeight = bubbleSize + 12;
            const icon = L.divIcon({
                className: 'pallet-bubble-marker',
                html: `<div class="placement-pin-inner" style="
                    display:flex;flex-direction:column;align-items:center;
                    cursor:pointer;filter:drop-shadow(0 3px 6px rgba(0,0,0,0.35));
                    transform:scale(0.5);transition:transform 0.2s ease;transform-origin:bottom center;
                ">
                    <div style="
                        width:${bubbleSize}px;height:${bubbleSize}px;
                        border-radius:6px;
                        background:${bgStyle};
                        border:3px solid white;
                        display:flex;flex-direction:column;align-items:center;justify-content:center;
                    ">
                        ${brickSvg}
                        <span style="color:white;font-weight:800;font-size:${count > 99 ? 10 : 12}px;line-height:1;margin-top:2px;text-shadow:0 1px 2px rgba(0,0,0,0.5);">${count}</span>
                    </div>
                    <div style="
                        width:0;height:0;
                        border-left:8px solid transparent;
                        border-right:8px solid transparent;
                        border-top:12px solid white;
                        margin-top:-1px;
                    "></div>
                </div>`,
                iconSize: [bubbleSize, pinHeight],
                iconAnchor: [halfSize, pinHeight]
            });

            const marker = L.marker(latlng, { icon: icon });
            marker.on('mouseover', function() {
                const el = this._icon.querySelector('.placement-pin-inner');
                if (el) { el.style.transform = 'scale(1)'; this._icon.style.zIndex = 9999; }
            });
            marker.on('mouseout', function() {
                const el = this._icon.querySelector('.placement-pin-inner');
                if (el) { el.style.transform = 'scale(0.5)'; this._icon.style.zIndex = ''; }
            });

            const avgAlt = cluster.reduce((s, p) => s + (p.altitude || 0), 0) / cluster.length;
            const timeRange = cluster.length > 1
                ? `${new Date(Math.min(...cluster.map(p => p.timestamp))).toLocaleString()} — ${new Date(Math.max(...cluster.map(p => p.timestamp))).toLocaleString()}`
                : new Date(cluster[0].timestamp).toLocaleString();
            const masonBreakdown = masons.map(m => {
                const c = cluster.filter(p => (p.mason_id || p.masonId) === m).length;
                const mi = uniqueMasons.indexOf(m);
                const mc = mi >= 0 ? masonColors[mi % masonColors.length] : '#CC0000';
                return `<span style="color:${mc};font-weight:bold;">${m}</span>: ${c} brick${c > 1 ? 's' : ''}`;
            }).join('<br>');

            const popupContent = `
                <div style="padding:10px;font-family:Arial;min-width:220px;">
                    <h3 style="margin:0 0 8px 0;color:${popupColor};">
                        ${count} Placement${count > 1 ? 's' : ''}
                    </h3>
                    <p style="margin:4px 0;font-size:0.9em;"><strong>Location:</strong> ${avgLat.toFixed(6)}, ${avgLng.toFixed(6)}</p>
                    <p style="margin:4px 0;font-size:0.9em;"><strong>Avg Altitude:</strong> ${avgAlt.toFixed(1)} m</p>
                    <p style="margin:4px 0;font-size:0.9em;"><strong>Time:</strong> ${timeRange}</p>
                    <div style="margin-top:8px;padding-top:8px;border-top:1px solid #ddd;">
                        <strong>Masons:</strong><br>${masonBreakdown}
                    </div>
                    <div style="margin-top:8px;padding-top:8px;border-top:1px solid #ddd;max-height:150px;overflow-y:auto;">
                        <strong>Scans (${count}):</strong>
                        ${cluster.map((p, i) => `
                            <div style="font-size:0.85em;margin:2px 0;">
                                <strong>${i+1}.</strong> ${p.rfidTag || p.brickNumber} — ${(p.mason_id || p.masonId)} — ${new Date(p.timestamp).toLocaleTimeString()}
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
            marker.bindPopup(popupContent, { maxWidth: 400 });
            marker.addTo(markerGroup);
            markers.push(marker);
            bounds.extend(latlng);
        }
        
        
        // Update map markers
        function updateMapMarkers(placements) {
            if (!map || !markerGroup) return;
            
            // Clear existing markers
            markerGroup.clearLayers();
            markers = [];
            
            // Filter placements with valid GPS
            const validPlacements = placements.filter(p => 
                p.latitude && p.longitude && 
                p.latitude !== 0 && p.longitude !== 0
            );
            
            if (validPlacements.length === 0) {
                alert('No placements with GPS coordinates found');
                return;
            }
            
            // Create bounds for auto-fit
            const bounds = L.latLngBounds();
            
            // Create unique mason ID list to ensure consistent color mapping
            const uniqueMasons = [...new Set(validPlacements.map(p => p.mason_id || p.masonId))];
            
            validPlacements.forEach((placement, idx) => {
                const latlng = [placement.latitude, placement.longitude];
                
                // Get mason color - consistent with chart colors
                const masonId = placement.mason_id || placement.masonId;
                const masonIndex = uniqueMasons.indexOf(masonId);
                const color = masonIndex >= 0 ? 
                    masonColors[masonIndex % masonColors.length] : 
                    '#CC0000';
                
                // Create brick pin icon
                const brickSvg = `<svg viewBox="0 0 24 18" width="22" height="16"><rect x="0" y="0" width="11" height="5" rx="0.5" fill="white" opacity="0.9"/><rect x="13" y="0" width="11" height="5" rx="0.5" fill="white" opacity="0.9"/><rect x="0" y="6.5" width="5" height="5" rx="0.5" fill="white" opacity="0.9"/><rect x="7" y="6.5" width="10" height="5" rx="0.5" fill="white" opacity="0.9"/><rect x="19" y="6.5" width="5" height="5" rx="0.5" fill="white" opacity="0.9"/><rect x="0" y="13" width="11" height="5" rx="0.5" fill="white" opacity="0.9"/><rect x="13" y="13" width="11" height="5" rx="0.5" fill="white" opacity="0.9"/></svg>`;
                const pinSize = 36;
                const pinHt = pinSize + 12;
                const icon = L.divIcon({
                    className: 'pallet-bubble-marker',
                    html: `<div class="placement-pin-inner" style="
                        display:flex;flex-direction:column;align-items:center;
                        cursor:pointer;filter:drop-shadow(0 3px 6px rgba(0,0,0,0.35));
                        transform:scale(0.5);transition:transform 0.2s ease;transform-origin:bottom center;
                    ">
                        <div style="
                            width:${pinSize}px;height:${pinSize}px;
                            border-radius:6px;
                            background:${color};
                            border:3px solid white;
                            display:flex;align-items:center;justify-content:center;
                        ">
                            ${brickSvg}
                        </div>
                        <div style="
                            width:0;height:0;
                            border-left:8px solid transparent;
                            border-right:8px solid transparent;
                            border-top:12px solid white;
                            margin-top:-1px;
                        "></div>
                    </div>`,
                    iconSize: [pinSize, pinHt],
                    iconAnchor: [pinSize / 2, pinHt]
                });
                
                // Create marker
                const marker = L.marker(latlng, { icon: icon });
                marker.on('mouseover', function() {
                    const el = this._icon.querySelector('.placement-pin-inner');
                    if (el) { el.style.transform = 'scale(1)'; this._icon.style.zIndex = 9999; }
                });
                marker.on('mouseout', function() {
                    const el = this._icon.querySelector('.placement-pin-inner');
                    if (el) { el.style.transform = 'scale(0.5)'; this._icon.style.zIndex = ''; }
                });
                
                // Create popup content
                const altitude = placement.altitude || 0;
                const popupContent = `
                    <div style="padding: 10px; font-family: Arial; min-width: 200px;">
                        <h3 style="margin: 0 0 10px 0; color: ${color};">${masonId || 'Unknown Mason'}</h3>
                        <p style="margin: 5px 0;"><strong>RFID:</strong> ${placement.rfidTag || placement.brickNumber}</p>
                        <p style="margin: 5px 0;"><strong>Time:</strong> ${new Date(placement.timestamp).toLocaleString()}</p>
                        <p style="margin: 5px 0;"><strong>Location:</strong> ${placement.latitude.toFixed(6)}, ${placement.longitude.toFixed(6)}</p>
                        <p style="margin: 5px 0;"><strong>Altitude:</strong> ${altitude.toFixed(1)} m</p>
                        <p style="margin: 5px 0;"><strong>Accuracy:</strong> Â±${placement.accuracy ? placement.accuracy.toFixed(1) : '999'} m</p>
                        ${placement.rssiAvg ? `<p style="margin: 5px 0;"><strong>RSSI:</strong> ${placement.rssiAvg} dBm</p>` : ''}
                    </div>
                `;
                
                marker.bindPopup(popupContent);
                marker.addTo(markerGroup);
                markers.push(marker);
                bounds.extend(latlng);
            });
            
            // Fit map to show all markers
            if (validPlacements.length === 1) {
                map.setView(bounds.getCenter(), 15);
            } else {
                map.fitBounds(bounds, { padding: [50, 50] });
            }
        }
        
        // Toggle fullscreen map mode
        function toggleMapFullscreen() {
            const isFS = document.body.classList.toggle('map-fullscreen');
            const btn = document.getElementById('btnFullscreen');
            if (isFS) {
                btn.innerHTML = '<svg viewBox="0 0 24 24" width="16" height="16" fill="white"><path d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z"/></svg> Exit';
            } else {
                btn.innerHTML = '<svg viewBox="0 0 24 24" width="16" height="16" fill="white"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/></svg> Fullscreen';
            }
            setTimeout(() => { if (map) map.invalidateSize(); }, 100);
        }

        // Escape key exits fullscreen
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape' && document.body.classList.contains('map-fullscreen')) {
                toggleMapFullscreen();
            }
        });

        // Fit map bounds to show all markers
        function fitMapBounds() {
            if (!map || markers.length === 0) return;
            
            const bounds = L.latLngBounds();
            markers.forEach(marker => {
                bounds.extend(marker.getLatLng());
            });
            
            if (markers.length === 1) {
                map.setView(bounds.getCenter(), 15);
            } else {
                map.fitBounds(bounds, { padding: [50, 50] });
            }
        }
        
        // Refresh map data
        function refreshMapData() {
            loadMapData();
        }

        // Map mode filter toggle
        function setMapFilter(filter) {
            mapFilter = filter;
            ['All', 'Placement', 'Pallet'].forEach(name => {
                const btn = document.getElementById('mapFilter' + name);
                if (btn) {
                    const isActive = name.toLowerCase() === filter || (name === 'All' && filter === 'all');
                    btn.style.background = isActive ? '#2D3436' : 'transparent';
                    btn.style.color = isActive ? 'white' : '#555';
                }
            });
            loadMapData();
        }

        // Render pallet scans as clustered bubbles with pallet icon
        function updateMapWithPalletBubbles(placements) {
            if (!map || !markerGroup) return;

            markerGroup.clearLayers();
            markers = [];
            wallPolygons.forEach(p => p.remove());
            wallPolygons = [];

            const validPlacements = placements.filter(p =>
                p.latitude && p.longitude &&
                p.latitude !== 0 && p.longitude !== 0
            );

            if (validPlacements.length === 0) {
                return;
            }

            // Cluster pallet scans by proximity (zoom-based distance)
            const palletClusterDist = getClusterDistance(map.getZoom()) * 1.5;
            const clusters = [];
            const visited = new Set();
            const sorted = [...validPlacements].sort((a, b) => a.timestamp - b.timestamp);

            sorted.forEach((placement, idx) => {
                if (visited.has(idx)) return;
                const cluster = [placement];
                const queue = [placement];
                visited.add(idx);

                while (queue.length > 0) {
                    const current = queue.shift();
                    sorted.forEach((other, otherIdx) => {
                        if (visited.has(otherIdx)) return;
                        const dist = calculateDistance(
                            current.latitude, current.longitude,
                            other.latitude, other.longitude
                        );
                        if (dist <= palletClusterDist) {
                            cluster.push(other);
                            queue.push(other);
                            visited.add(otherIdx);
                        }
                    });
                }
                clusters.push(cluster);
            });

            const bounds = L.latLngBounds();
            const uniqueMasons = [...new Set(validPlacements.map(p => p.mason_id || p.masonId))];

            // Second pass: merge clusters that would visually overlap on screen
            const mergedClusters = mergeOverlappingClusters(clusters, 64);

            mergedClusters.forEach(cluster => {
                // Average position
                const avgLat = cluster.reduce((s, p) => s + p.latitude, 0) / cluster.length;
                const avgLng = cluster.reduce((s, p) => s + p.longitude, 0) / cluster.length;
                const latlng = [avgLat, avgLng];

                const count = cluster.length;
                const masons = [...new Set(cluster.map(p => p.mason_id || p.masonId))];
                const primaryMason = masons[0];
                const masonIndex = uniqueMasons.indexOf(primaryMason);
                // Diagonal gradient when multiple masons
                const bgStyle = getMasonGradient(cluster, uniqueMasons);
                const popupColor = masonIndex >= 0 ? masonColors[masonIndex % masonColors.length] : '#3b82f6';

                // Log scale: 1→32, 5→40, 12→45, 50→56, 200→64 (max 64)
                const bubbleSize = Math.max(32, Math.min(64, 28 + Math.log2(count + 1) * 8));
                const halfSize = bubbleSize / 2;

                // Pallet SVG icon (simplified top-down pallet)
                const palletSvg = `<svg viewBox="0 0 32 32" width="${bubbleSize * 0.45}" height="${bubbleSize * 0.45}" style="opacity:0.9;">
                    <rect x="1" y="3" width="30" height="4" rx="1" fill="white" opacity="0.9"/>
                    <rect x="1" y="13" width="30" height="4" rx="1" fill="white" opacity="0.9"/>
                    <rect x="1" y="23" width="30" height="4" rx="1" fill="white" opacity="0.9"/>
                    <rect x="3" y="8" width="2" height="4" fill="white" opacity="0.5"/>
                    <rect x="15" y="8" width="2" height="4" fill="white" opacity="0.5"/>
                    <rect x="27" y="8" width="2" height="4" fill="white" opacity="0.5"/>
                    <rect x="3" y="18" width="2" height="4" fill="white" opacity="0.5"/>
                    <rect x="15" y="18" width="2" height="4" fill="white" opacity="0.5"/>
                    <rect x="27" y="18" width="2" height="4" fill="white" opacity="0.5"/>
                </svg>`;

                const pinHeight = bubbleSize + 12;
                const icon = L.divIcon({
                    className: 'pallet-bubble-marker',
                    html: `<div class="pallet-pin-inner" style="
                        display:flex;flex-direction:column;align-items:center;
                        cursor:pointer;filter:drop-shadow(0 3px 6px rgba(0,0,0,0.35));
                        transform:scale(0.5);transition:transform 0.2s ease;transform-origin:bottom center;
                    ">
                        <div style="
                            width:${bubbleSize}px;height:${bubbleSize}px;
                            border-radius:6px;
                            background:${bgStyle};
                            border:3px solid white;
                            display:flex;flex-direction:column;align-items:center;justify-content:center;
                            position:relative;
                        ">
                            ${palletSvg}
                            <span style="color:white;font-weight:800;font-size:${count > 99 ? 10 : 12}px;line-height:1;margin-top:1px;text-shadow:0 1px 2px rgba(0,0,0,0.5);">${count}</span>
                        </div>
                        <div style="
                            width:0;height:0;
                            border-left:8px solid transparent;
                            border-right:8px solid transparent;
                            border-top:12px solid white;
                            margin-top:-1px;
                        "></div>
                    </div>`,
                    iconSize: [bubbleSize, pinHeight],
                    iconAnchor: [halfSize, pinHeight]
                });

                const marker = L.marker(latlng, { icon: icon });

                marker.on('mouseover', function() {
                    const el = this._icon.querySelector('.pallet-pin-inner');
                    if (el) { el.style.transform = 'scale(1)'; this._icon.style.zIndex = 9999; }
                });
                marker.on('mouseout', function() {
                    const el = this._icon.querySelector('.pallet-pin-inner');
                    if (el) { el.style.transform = 'scale(0.5)'; this._icon.style.zIndex = ''; }
                });

                // Build popup
                const avgAlt = cluster.reduce((s, p) => s + (p.altitude || 0), 0) / cluster.length;
                const timeRange = cluster.length > 1
                    ? `${new Date(Math.min(...cluster.map(p => p.timestamp))).toLocaleString()} — ${new Date(Math.max(...cluster.map(p => p.timestamp))).toLocaleString()}`
                    : new Date(cluster[0].timestamp).toLocaleString();
                const masonBreakdown = masons.map(m => {
                    const c = cluster.filter(p => (p.mason_id || p.masonId) === m).length;
                    const mi = uniqueMasons.indexOf(m);
                    const mc = mi >= 0 ? masonColors[mi % masonColors.length] : '#3b82f6';
                    return `<span style="color:${mc};font-weight:bold;">${m}</span>: ${c} block${c > 1 ? 's' : ''}`;
                }).join('<br>');

                const popupContent = `
                    <div style="padding:10px;font-family:Arial;min-width:220px;">
                        <h3 style="margin:0 0 8px 0;color:${popupColor};">
                            <span style="background:#3b82f6;color:white;padding:2px 8px;border-radius:4px;font-size:0.75rem;font-weight:700;margin-right:6px;">PALLET</span>
                            ${count} Block${count > 1 ? 's' : ''} Indexed
                        </h3>
                        <p style="margin:4px 0;font-size:0.9em;"><strong>Location:</strong> ${avgLat.toFixed(6)}, ${avgLng.toFixed(6)}</p>
                        <p style="margin:4px 0;font-size:0.9em;"><strong>Avg Altitude:</strong> ${avgAlt.toFixed(1)} m</p>
                        <p style="margin:4px 0;font-size:0.9em;"><strong>Time:</strong> ${timeRange}</p>
                        <div style="margin-top:8px;padding-top:8px;border-top:1px solid #ddd;">
                            <strong>Masons:</strong><br>${masonBreakdown}
                        </div>
                        <div style="margin-top:8px;padding-top:8px;border-top:1px solid #ddd;max-height:150px;overflow-y:auto;">
                            <strong>Scans (${count}):</strong>
                            ${cluster.map((p, i) => `
                                <div style="font-size:0.85em;margin:2px 0;">
                                    <strong>${i+1}.</strong> ${p.rfidTag || p.brickNumber} — ${(p.mason_id || p.masonId)} — ${new Date(p.timestamp).toLocaleTimeString()}
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
                marker.bindPopup(popupContent, { maxWidth: 400 });
                marker.addTo(markerGroup);
                markers.push(marker);
                bounds.extend(latlng);
            });

            if (bounds.isValid() && !isZoomRender) {
                map.fitBounds(bounds, { padding: [50, 50] });
            }
        }
        
        // Add pallet bubbles on top of existing map layers (for "All" mode)
        function addPalletBubblesToMap(placements) {
            if (!map || !markerGroup) return;

            const validPlacements = placements.filter(p =>
                p.latitude && p.longitude &&
                p.latitude !== 0 && p.longitude !== 0
            );
            if (validPlacements.length === 0) return;

            // Cluster pallet scans by proximity (zoom-based distance)
            const palletClusterDist = getClusterDistance(map.getZoom()) * 1.5;
            const clusters = [];
            const visited = new Set();
            const sorted = [...validPlacements].sort((a, b) => a.timestamp - b.timestamp);

            sorted.forEach((placement, idx) => {
                if (visited.has(idx)) return;
                const cluster = [placement];
                const queue = [placement];
                visited.add(idx);

                while (queue.length > 0) {
                    const current = queue.shift();
                    sorted.forEach((other, otherIdx) => {
                        if (visited.has(otherIdx)) return;
                        const dist = calculateDistance(
                            current.latitude, current.longitude,
                            other.latitude, other.longitude
                        );
                        if (dist <= palletClusterDist) {
                            cluster.push(other);
                            queue.push(other);
                            visited.add(otherIdx);
                        }
                    });
                }
                clusters.push(cluster);
            });

            const uniqueMasons = [...new Set(validPlacements.map(p => p.mason_id || p.masonId))];
            const bounds = markers.length > 0 ? L.latLngBounds(markers.map(m => m.getLatLng())) : L.latLngBounds();

            // Second pass: merge clusters that would visually overlap on screen
            const mergedClusters = mergeOverlappingClusters(clusters, 64);

            mergedClusters.forEach(cluster => {
                const avgLat = cluster.reduce((s, p) => s + p.latitude, 0) / cluster.length;
                const avgLng = cluster.reduce((s, p) => s + p.longitude, 0) / cluster.length;
                const latlng = [avgLat, avgLng];
                const count = cluster.length;
                const masons = [...new Set(cluster.map(p => p.mason_id || p.masonId))];
                const primaryMason = masons[0];
                const masonIndex = uniqueMasons.indexOf(primaryMason);
                // Diagonal gradient when multiple masons
                const bgStyle = getMasonGradient(cluster, uniqueMasons);
                const popupColor = masonIndex >= 0 ? masonColors[masonIndex % masonColors.length] : '#3b82f6';

                // Log scale: 1→32, 5→40, 12→45, 50→56, 200→64 (max 64)
                const bubbleSize = Math.max(32, Math.min(64, 28 + Math.log2(count + 1) * 8));
                const halfSize = bubbleSize / 2;

                const palletSvg = `<svg viewBox="0 0 32 32" width="${bubbleSize * 0.45}" height="${bubbleSize * 0.45}" style="opacity:0.9;">
                    <rect x="1" y="3" width="30" height="4" rx="1" fill="white" opacity="0.9"/>
                    <rect x="1" y="13" width="30" height="4" rx="1" fill="white" opacity="0.9"/>
                    <rect x="1" y="23" width="30" height="4" rx="1" fill="white" opacity="0.9"/>
                    <rect x="3" y="8" width="2" height="4" fill="white" opacity="0.5"/>
                    <rect x="15" y="8" width="2" height="4" fill="white" opacity="0.5"/>
                    <rect x="27" y="8" width="2" height="4" fill="white" opacity="0.5"/>
                    <rect x="3" y="18" width="2" height="4" fill="white" opacity="0.5"/>
                    <rect x="15" y="18" width="2" height="4" fill="white" opacity="0.5"/>
                    <rect x="27" y="18" width="2" height="4" fill="white" opacity="0.5"/>
                </svg>`;

                const pinHeight = bubbleSize + 12;
                const icon = L.divIcon({
                    className: 'pallet-bubble-marker',
                    html: `<div class="pallet-pin-inner" style="
                        display:flex;flex-direction:column;align-items:center;
                        cursor:pointer;filter:drop-shadow(0 3px 6px rgba(0,0,0,0.35));
                        transform:scale(0.5);transition:transform 0.2s ease;transform-origin:bottom center;
                    ">
                        <div style="
                            width:${bubbleSize}px;height:${bubbleSize}px;
                            border-radius:6px;
                            background:${bgStyle};
                            border:3px solid white;
                            display:flex;flex-direction:column;align-items:center;justify-content:center;
                        ">
                            ${palletSvg}
                            <span style="color:white;font-weight:800;font-size:${count > 99 ? 10 : 12}px;line-height:1;margin-top:1px;text-shadow:0 1px 2px rgba(0,0,0,0.5);">${count}</span>
                        </div>
                        <div style="
                            width:0;height:0;
                            border-left:8px solid transparent;
                            border-right:8px solid transparent;
                            border-top:12px solid white;
                            margin-top:-1px;
                        "></div>
                    </div>`,
                    iconSize: [bubbleSize, pinHeight],
                    iconAnchor: [halfSize, pinHeight]
                });

                const marker = L.marker(latlng, { icon: icon });

                marker.on('mouseover', function() {
                    const el = this._icon.querySelector('.pallet-pin-inner');
                    if (el) { el.style.transform = 'scale(1)'; this._icon.style.zIndex = 9999; }
                });
                marker.on('mouseout', function() {
                    const el = this._icon.querySelector('.pallet-pin-inner');
                    if (el) { el.style.transform = 'scale(0.5)'; this._icon.style.zIndex = ''; }
                });

                const avgAlt = cluster.reduce((s, p) => s + (p.altitude || 0), 0) / cluster.length;
                const timeRange = cluster.length > 1
                    ? `${new Date(Math.min(...cluster.map(p => p.timestamp))).toLocaleString()} \u2014 ${new Date(Math.max(...cluster.map(p => p.timestamp))).toLocaleString()}`
                    : new Date(cluster[0].timestamp).toLocaleString();
                const masonBreakdown = masons.map(m => {
                    const c = cluster.filter(p => (p.mason_id || p.masonId) === m).length;
                    const mi = uniqueMasons.indexOf(m);
                    const mc = mi >= 0 ? masonColors[mi % masonColors.length] : '#3b82f6';
                    return `<span style="color:${mc};font-weight:bold;">${m}</span>: ${c} block${c > 1 ? 's' : ''}`;
                }).join('<br>');

                const popupContent = `
                    <div style="padding:10px;font-family:Arial;min-width:220px;">
                        <h3 style="margin:0 0 8px 0;color:${popupColor};">
                            <span style="background:#3b82f6;color:white;padding:2px 8px;border-radius:4px;font-size:0.75rem;font-weight:700;margin-right:6px;">PALLET</span>
                            ${count} Block${count > 1 ? 's' : ''} Indexed
                        </h3>
                        <p style="margin:4px 0;font-size:0.9em;"><strong>Location:</strong> ${avgLat.toFixed(6)}, ${avgLng.toFixed(6)}</p>
                        <p style="margin:4px 0;font-size:0.9em;"><strong>Avg Altitude:</strong> ${avgAlt.toFixed(1)} m</p>
                        <p style="margin:4px 0;font-size:0.9em;"><strong>Time:</strong> ${timeRange}</p>
                        <div style="margin-top:8px;padding-top:8px;border-top:1px solid #ddd;">
                            <strong>Masons:</strong><br>${masonBreakdown}
                        </div>
                    </div>
                `;
                marker.bindPopup(popupContent, { maxWidth: 400 });
                marker.addTo(markerGroup);
                markers.push(marker);
                bounds.extend(latlng);
            });

            if (bounds.isValid() && !isZoomRender) {
                map.fitBounds(bounds, { padding: [50, 50] });
            }
        }
        
        // ============================================
        // USER MANAGEMENT (Admin only)
        // ============================================
        
        function populateUserManagement(users) {
            const tbody = document.getElementById('userManagementBody');
            if (!tbody) return;
            
            // Store for filtering
            window._umUsers = users;
            renderUserTable(users);
        }

        function renderUserTable(users) {
            const tbody = document.getElementById('userManagementBody');
            if (!tbody) return;

            if (!users || users.length === 0) {
                tbody.innerHTML = '<tr><td colspan="5" class="um-empty">No users found.</td></tr>';
                return;
            }
            
            const currentMason = localStorage.getItem('dashboard_masonId');
            
            tbody.innerHTML = users.map(user => {
                const isCurrentUser = user.masonId === currentMason;
                const roleBadge = getRoleBadge(user.role);
                const canChangeRole = !isCurrentUser && (isSuperAdmin || (isCompanyAdmin && user.role !== 'super_admin'));
                const canDelete = !isCurrentUser && (isSuperAdmin || (isCompanyAdmin && user.role === 'user'));
                
                let actions = [];
                if (canChangeRole) {
                    if (user.role === 'user') {
                        actions.push(`<button class="um-btn promote" onclick="changeUserRole('${escapeHtml(user.masonId)}', 'company_admin')">Promote to Admin</button>`);
                    } else if (user.role === 'company_admin') {
                        actions.push(`<button class="um-btn demote" onclick="changeUserRole('${escapeHtml(user.masonId)}', 'user')">Remove Admin</button>`);
                    }
                    if (isSuperAdmin && user.role !== 'super_admin') {
                        actions.push(`<button class="um-btn super" onclick="changeUserRole('${escapeHtml(user.masonId)}', 'super_admin')">Make Super</button>`);
                    }
                }
                if (canDelete) {
                    actions.push(`<button class="um-btn delete" onclick="deleteUser('${escapeHtml(user.masonId)}', '${escapeHtml(user.username)}')">Delete</button>`);
                }
                if (isCurrentUser) {
                    actions.push('<span class="um-you-tag">You</span>');
                }
                
                return `<tr data-username="${escapeHtml(user.username).toLowerCase()}" data-masonid="${escapeHtml(user.masonId).toLowerCase()}" data-company="${escapeHtml(user.company).toLowerCase()}">
                    <td><span class="um-username${isCurrentUser ? ' is-you' : ''}">${escapeHtml(user.username)}</span>${isCurrentUser ? '<span class="um-you-tag">(you)</span>' : ''}</td>
                    <td><span class="um-mason-id">${escapeHtml(user.masonId)}</span></td>
                    <td class="um-company">${escapeHtml(user.company)}</td>
                    <td>${roleBadge}</td>
                    <td><div class="um-actions-cell">${actions.join('')}</div></td>
                </tr>`;
            }).join('');
        }

        function filterUserTable() {
            const query = (document.getElementById('umSearch').value || '').toLowerCase().trim();
            if (!window._umUsers) return;
            if (!query) {
                renderUserTable(window._umUsers);
                return;
            }
            const filtered = window._umUsers.filter(u =>
                u.username.toLowerCase().includes(query) ||
                u.masonId.toLowerCase().includes(query) ||
                (u.company || '').toLowerCase().includes(query) ||
                (u.role || '').toLowerCase().includes(query)
            );
            renderUserTable(filtered);
        }
        
        function getRoleBadge(role) {
            switch(role) {
                case 'super_admin':
                    return '<span class="role-badge super-admin">Super Admin</span>';
                case 'company_admin':
                    return '<span class="role-badge company-admin">Company Admin</span>';
                default:
                    return '<span class="role-badge user">User</span>';
            }
        }
        
        async function changeUserRole(masonId, newRole) {
            const roleName = newRole === 'super_admin' ? 'Super Admin' : newRole === 'company_admin' ? 'Company Admin' : 'User';
            if (!confirm(`Change this user's role to ${roleName}?`)) return;
            
            try {
                const response = await authFetch(`${API_BASE}/api/users/${encodeURIComponent(masonId)}/role`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ role: newRole })
                });
                const data = await response.json();
                
                if (data.success) {
                    await loadMasons();
                } else {
                    alert('Error: ' + (data.message || 'Failed to update role'));
                }
            } catch (err) {
                console.error('Error changing role:', err);
                alert('Failed to update role.');
            }
        }

        async function deleteUser(masonId, username) {
            if (!confirm(`Are you sure you want to delete user "${username}" (${masonId})?\n\nThis cannot be undone.`)) return;
            try {
                const response = await authFetch(`${API_BASE}/api/users/${encodeURIComponent(masonId)}`, {
                    method: 'DELETE'
                });
                const data = await response.json();
                if (data.success) {
                    await loadMasons();
                } else {
                    alert('Error: ' + (data.message || 'Failed to delete user'));
                }
            } catch (err) {
                console.error('Error deleting user:', err);
                alert('Failed to delete user.');
            }
        }

        // ── Create User Modal ──
        async function openCreateUserModal() {
            const modal = document.getElementById('createUserModal');
            const companySelect = document.getElementById('newCompany');
            const roleSelect = document.getElementById('newRole');
            const errDiv = document.getElementById('createUserError');

            // Reset form
            document.getElementById('newUsername').value = '';
            document.getElementById('newPassword').value = '';
            document.getElementById('newMasonId').value = '';
            errDiv.style.display = 'none';
            errDiv.textContent = '';

            // Reset new company fields
            const ncFields = document.getElementById('newCompanyFields');
            if (ncFields) { ncFields.style.display = 'none'; }
            const ncName = document.getElementById('newCompanyName');
            const ncCode = document.getElementById('newCompanyCode');
            if (ncName) ncName.value = '';
            if (ncCode) ncCode.value = '';

            // Populate companies
            if (isSuperAdmin) {
                // Super admin: load all companies + option to create new
                try {
                    const resp = await authFetch(`${API_BASE}/api/companies`);
                    const data = await resp.json();
                    companySelect.innerHTML = '<option value="">Select a company...</option>';
                    if (data.success && data.companies) {
                        data.companies.forEach(c => {
                            companySelect.innerHTML += `<option value="${c.id}">${escapeHtml(c.name)} (${escapeHtml(c.code)})</option>`;
                        });
                    }
                    companySelect.innerHTML += '<option value="__new__">+ Create New Company</option>';
                } catch (e) {
                    companySelect.innerHTML = '<option value="">Error loading companies</option>';
                }
                // Super admin can assign super_admin role
                roleSelect.innerHTML = `
                    <option value="user">User</option>
                    <option value="company_admin">Company Admin</option>
                    <option value="super_admin">Super Admin</option>
                `;
            } else if (isCompanyAdmin && userCompany) {
                // Company admin: locked to their company
                companySelect.innerHTML = `<option value="${userCompany.id}" selected>${escapeHtml(userCompany.name)}</option>`;
                companySelect.disabled = true;
                roleSelect.innerHTML = `
                    <option value="user">User</option>
                    <option value="company_admin">Company Admin</option>
                `;
            }

            modal.style.display = 'flex';
        }

        function toggleNewCompanyFields() {
            const sel = document.getElementById('newCompany');
            const fields = document.getElementById('newCompanyFields');
            if (fields) fields.style.display = sel.value === '__new__' ? 'block' : 'none';
        }

        function closeCreateUserModal() {
            document.getElementById('createUserModal').style.display = 'none';
            // Re-enable company select in case it was disabled
            document.getElementById('newCompany').disabled = false;
            const ncFields = document.getElementById('newCompanyFields');
            if (ncFields) ncFields.style.display = 'none';
        }

        async function submitCreateUser() {
            const btn = document.getElementById('btnCreateUser');
            const errDiv = document.getElementById('createUserError');
            const username = document.getElementById('newUsername').value.trim();
            const password = document.getElementById('newPassword').value;
            const masonId = document.getElementById('newMasonId').value.trim();
            let companyId = document.getElementById('newCompany').value;
            const role = document.getElementById('newRole').value;

            errDiv.style.display = 'none';

            // Validate
            if (!username) { showCreateError('Username is required'); return; }
            if (!password || password.length < 6) { showCreateError('Password must be at least 6 characters'); return; }
            if (!masonId) { showCreateError('User ID is required'); return; }

            // Handle creating a new company first
            if (companyId === '__new__') {
                const cName = (document.getElementById('newCompanyName').value || '').trim();
                const cCode = (document.getElementById('newCompanyCode').value || '').trim().toUpperCase();
                if (!cName) { showCreateError('Company name is required'); return; }
                if (!cCode || cCode.length < 2 || cCode.length > 10) { showCreateError('Company code must be 2-10 characters'); return; }
                try {
                    const cResp = await authFetch(`${API_BASE}/api/companies`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ name: cName, code: cCode })
                    });
                    const cData = await cResp.json();
                    if (cData.success && cData.company) {
                        companyId = cData.company.id;
                    } else {
                        showCreateError(cData.message || 'Failed to create company');
                        return;
                    }
                } catch (e) {
                    showCreateError('Failed to create company');
                    return;
                }
            }

            if (!companyId) { showCreateError('Please select a company'); return; }

            btn.disabled = true;
            btn.textContent = 'Creating...';

            try {
                const response = await authFetch(`${API_BASE}/api/admin/users`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username, password, mason_id: masonId, company_id: parseInt(companyId), role })
                });
                const data = await response.json();

                if (data.success) {
                    closeCreateUserModal();
                    await loadMasons();
                } else {
                    showCreateError(data.message || 'Failed to create user');
                }
            } catch (err) {
                console.error('Error creating user:', err);
                showCreateError('Network error. Please try again.');
            } finally {
                btn.disabled = false;
                btn.textContent = 'Create User';
            }
        }

        function showCreateError(msg) {
            const errDiv = document.getElementById('createUserError');
            errDiv.textContent = msg;
            errDiv.style.display = 'block';
        }
        
        // Initialize dashboard
        async function initDashboard() {
            try {
                // Show manage users in cog menu if admin
                if (isAnyAdmin) {
                    const manageBtn = document.getElementById('manageUsersBtn');
                    if (manageBtn) manageBtn.style.display = '';
                }
                
                await loadMasons();
                // Load user's widget layout from server (overrides localStorage if server has saved layout)
                await loadServerWidgetLayout();
                await refreshData();
                await loadPlacements();
                
                // Auto-refresh stats every 30 seconds (reduced from 10)
                refreshInterval = setInterval(() => {
                    refreshData();
                }, 30000);
                // Check for new placements every 5 seconds (reduced from 2)
                setInterval(loadPlacements, 5000);
            } catch (error) {
                console.error('Failed to initialize dashboard:', error);
                showError('Failed to initialize dashboard: ' + error.message);
                document.getElementById('loading').style.display = 'none';
            }
        }
        
        // Load all masons from /api/users endpoint (company-scoped based on role)
        async function loadMasons() {
            try {
                const response = await authFetch(`${API_BASE}/api/users`);
                const data = await response.json();
                const loggedInMasonId = localStorage.getItem('dashboard_masonId') || '';
                const isRegularUser = !isAnyAdmin;
                
                if (isRegularUser) {
                    // Regular users: hide the entire controls bar
                    const controlsBar = document.getElementById('controlsBar');
                    if (controlsBar) controlsBar.style.display = 'none';
                    currentMasonId = loggedInMasonId;
                    allMasons = (data.success && data.users) ? data.users : [];
                    return;
                }
                
                if (data.success && data.users && data.users.length > 0) {
                    allMasons = data.users;
                    
                    // Super admin: show company dropdown
                    if (isSuperAdmin) {
                        document.getElementById('companySelectGroup').style.display = '';
                        document.getElementById('filterDivider').style.display = '';
                        await loadCompanyDropdown();
                    }
                    
                    // Populate user dropdown
                    populateUserDropdown(allMasons);
                    currentMasonId = '';
                    
                    // Populate admin user management table
                    if (isAnyAdmin) {
                        populateUserManagement(data.users);
                    }
                } else {
                    const select = document.getElementById('masonSelect');
                    select.innerHTML = '<option value="">All Users (No users yet)</option>';
                    allMasons = [];
                    currentMasonId = '';
                }
            } catch (error) {
                console.error('Error loading masons:', error);
                const select = document.getElementById('masonSelect');
                select.innerHTML = '<option value="">All Users (Error)</option>';
                allMasons = [];
                currentMasonId = '';
            }
        }
        
        // Load companies into the company dropdown (super admin only)
        async function loadCompanyDropdown() {
            try {
                const resp = await authFetch(`${API_BASE}/api/companies`);
                const data = await resp.json();
                const select = document.getElementById('companySelect');
                select.innerHTML = '<option value="">All Companies</option>';
                if (data.success && data.companies) {
                    data.companies.forEach(c => {
                        const opt = document.createElement('option');
                        opt.value = c.id;
                        opt.textContent = `${c.name} (${c.code})`;
                        select.appendChild(opt);
                    });
                }
            } catch (err) {
                console.error('Error loading companies:', err);
            }
        }
        
        // Populate user dropdown, optionally filtered by company
        function populateUserDropdown(users, companyId) {
            const select = document.getElementById('masonSelect');
            let filtered = users;
            if (companyId) {
                filtered = users.filter(u => String(u.companyId) === String(companyId));
            }
            const companyLabel = isCompanyAdmin && userCompany ? ` (${escapeHtml(userCompany.name)})` : '';
            select.innerHTML = `<option value="">All Users${companyLabel}</option>`;
            filtered.forEach(user => {
                const option = document.createElement('option');
                option.value = user.masonId;
                option.textContent = user.username;
                select.appendChild(option);
            });
        }
        
        // Load recent placements
        async function loadPlacements() {
            if (isUpdating) return;
            
            try {
                isUpdating = true;
                const masonId = document.getElementById('masonSelect').value;
                
                if (!masonId) {
                    const response = await authFetch(`${API_BASE}/api/placements/recent?limit=100`);
                    const data = await response.json();
                    
                    if (data.success && data.placements) {
                        // Only update if placement count changed
                        if (data.placements.length !== lastPlacementCount) {
                            lastPlacementCount = data.placements.length;
                            
                            const today = new Date();
                            today.setHours(0, 0, 0, 0);
                            const todayTimestamp = today.getTime();
                            
                            const todayPlacements = data.placements.filter(p => p.timestamp >= todayTimestamp);
                            
                            allPlacements = todayPlacements;
                            // Charts only show actual placements (not pallet scans)
                            const chartPlacements = allPlacements.filter(p => (p.scan_type || p.scanType || 'placement') !== 'pallet');
                            updateLiveChartMultiMason(chartPlacements);
                        }
                    }
                } else {
                    const url = `${API_BASE}/api/placements/mason/${masonId}`;
                    const response = await authFetch(url);
                    const data = await response.json();
                    
                    if (data.success) {
                        if (data.placements.length !== lastPlacementCount) {
                            lastPlacementCount = data.placements.length;
                            
                            const today = new Date();
                            today.setHours(0, 0, 0, 0);
                            const todayTimestamp = today.getTime();
                            
                            const todayPlacements = (data.placements || []).filter(p => p.timestamp >= todayTimestamp);
                            
                            allPlacements = todayPlacements;
                            // Charts only show actual placements (not pallet scans)
                            const chartPlacements = allPlacements.filter(p => (p.scan_type || p.scanType || 'placement') !== 'pallet');
                            updateLiveChart(chartPlacements);
                        }
                    }
                }
            } catch (error) {
                console.error('Error loading placements:', error);
            } finally {
                isUpdating = false;
            }
        }
        
        
        // Refresh dashboard data (stats only, don't reload placements)
        async function refreshData() {
            try {
                const response = await authFetch(`${API_BASE}/api/statistics/efficiency`);
                const data = await response.json();
                
                if (!data.success) {
                    throw new Error(data.message || 'Failed to fetch data');
                }
                
                hideError();
                updateDashboard(data);
                document.getElementById('lastUpdated').textContent = new Date().toLocaleString();
                
            } catch (error) {
                console.error('Error refreshing data:', error);
                showError('Failed to refresh data: ' + error.message);
            }
        }
        
        // Update dashboard with new data
        function updateDashboard(data) {
            const masonId = document.getElementById('masonSelect').value || currentMasonId;
            
            // Filter data for selected mason
            let dailyData = data.dailyEfficiency || [];
            let summaryData = data.masonSummary || [];
            
            if (masonId) {
                dailyData = dailyData.filter(d => d.masonId === masonId);
                summaryData = summaryData.filter(s => s.masonId === masonId);
            }
            
            // Update title
            const title = 'Efficiency Dashboard';
            document.getElementById('dashboardTitle').textContent = title;
            
            // Helper: safely set KPI value (card may not be visible)
            function setKpi(id, value) {
                const el = document.getElementById(id);
                if (el) el.textContent = value;
            }

            // Compute KPI values
            let placed = 0, indexed = 0, daysWorked = 0, avgPerDay = '0.0', activeMasons = 0, totalScans = 0, avgPerHourAllTime = '0.0';
            
            if (summaryData.length > 0) {
                if (masonId) {
                    const summary = summaryData[0];
                    placed = summary.placementCount || 0;
                    indexed = summary.palletCount || 0;
                    daysWorked = summary.daysWorked || 0;
                    avgPerDay = daysWorked > 0 ? (placed / daysWorked).toFixed(1) : '0.0';
                    activeMasons = 1;
                    totalScans = placed + indexed;
                } else {
                    placed = summaryData.reduce((sum, s) => sum + (s.placementCount || 0), 0);
                    indexed = summaryData.reduce((sum, s) => sum + (s.palletCount || 0), 0);
                    daysWorked = Math.max(...summaryData.map(s => s.daysWorked || 0));
                    avgPerDay = daysWorked > 0 ? (placed / daysWorked).toFixed(1) : '0.0';
                    activeMasons = summaryData.length;
                    totalScans = placed + indexed;
                }
            }
            
            // Compute all-time avg/hour from daily data
            if (dailyData.length > 0) {
                const totalHours = dailyData.reduce((sum, d) => sum + (d.hoursWorked || 0), 0);
                const totalDailyPlacements = dailyData.reduce((sum, d) => sum + (d.totalPlacements || 0), 0);
                avgPerHourAllTime = totalHours > 0 ? (totalDailyPlacements / totalHours).toFixed(1) : '0.0';
            }

            setKpi('totalPlacements', placed.toLocaleString());
            setKpi('totalIndexed', indexed.toLocaleString());
            setKpi('daysWorked', daysWorked);
            setKpi('avgPerDay', avgPerDay);
            setKpi('activeMasons', activeMasons);
            setKpi('totalScans', totalScans.toLocaleString());
            setKpi('avgPerHourAllTime', avgPerHourAllTime);
            
            // Update current efficiency (most recent day)
            if (dailyData.length > 0) {
                if (masonId) {
                    const latest = dailyData[0];
                    setKpi('currentEfficiency', latest.placementsPerHour.toFixed(1));
                } else {
                    const avgEfficiency = (dailyData.reduce((sum, d) => sum + d.placementsPerHour, 0) / dailyData.length).toFixed(1);
                    setKpi('currentEfficiency', avgEfficiency);
                }
            } else {
                setKpi('currentEfficiency', '0.0');
            }
            
            // Update daily chart (only if the widget is present)
            if (document.getElementById('dailyChart')) {
                updateDailyChart(dailyData);
            }

            // Update efficiency chart
            if (document.getElementById('efficiencyChart')) {
                updateEfficiencyChart(dailyData);
            }

            // Update user comparison chart (show all users even when filtered)
            if (document.getElementById('masonCompareChart')) {
                updateMasonCompareChart(data.masonSummary || []);
            }

            // Update hourly activity chart
            if (document.getElementById('hourlyChart')) {
                updateHourlyChart(dailyData);
            }

            // Update placed vs indexed doughnut
            if (document.getElementById('placedVsIndexed')) {
                updatePlacedVsIndexedChart(placed, indexed);
            }
            
            // Show dashboard
            document.getElementById('loading').style.display = 'none';
            document.getElementById('dashboard').style.display = 'block';
        }
        
        // Update live placements chart for multiple masons
        function updateLiveChartMultiMason(placements) {
            if (!placements || placements.length === 0) return;
            if (!document.getElementById('liveChart')) return;
            
            const masonGroups = {};
            placements.forEach(p => {
                const masonId = p.mason_id || p.masonId;
                if (!masonId) return;
                if (!masonGroups[masonId]) masonGroups[masonId] = [];
                masonGroups[masonId].push(p);
            });
            
            // Sort mason IDs for consistent ordering
            const sortedMasonIds = Object.keys(masonGroups).sort();
            
            // Create datasets for each mason
            const datasets = sortedMasonIds.map((masonId) => {
                const masonPlacements = masonGroups[masonId].sort((a, b) => a.timestamp - b.timestamp);
                const dataPoints = masonPlacements.map((p, pIdx) => ({
                    x: p.timestamp,
                    y: pIdx + 1
                }));
                
                const color = getMasonColor(masonId, sortedMasonIds);
                
                return {
                    label: masonId,
                    data: dataPoints,
                    borderColor: color,
                    backgroundColor: color + '20', // Add transparency
                    borderWidth: 3,
                    fill: false,
                    tension: 0.4,
                    pointRadius: 3,
                    pointHoverRadius: 6,
                    pointBackgroundColor: color,
                    pointBorderColor: '#fff',
                    pointBorderWidth: 2
                };
            });
            
            // Calculate max Y value across all mason datasets
            const maxY = Math.max(...datasets.map(ds => Math.max(...ds.data.map(p => p.y)))) + 5;
            
            // Update existing chart or create new one
            if (liveChart) {
                liveChart.data.datasets = datasets;
                liveChart.options.scales.y.suggestedMax = maxY;
                liveChart.update('none');
                return;
            }
            
            // Create new chart
            const liveCtx = document.getElementById('liveChart').getContext('2d');
            liveChart = new Chart(liveCtx, {
                type: 'line',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            padding: 12,
                            titleFont: { size: 14 },
                            bodyFont: { size: 13 },
                            callbacks: {
                                title: function(context) {
                                    const date = new Date(context[0].parsed.x);
                                    return date.toLocaleString('en-US', {
                                        month: 'short',
                                        day: 'numeric',
                                        hour: '2-digit',
                                        minute: '2-digit',
                                        second: '2-digit'
                                    });
                                },
                                label: function(context) {
                                    return context.dataset.label + ': ' + context.parsed.y + ' placements';
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            suggestedMax: maxY,
                            title: {
                                display: true,
                                text: 'Cumulative Placements (per Mason)',
                                font: { size: 14, weight: 'bold' }
                            },
                            grid: {
                                color: 'rgba(0, 0, 0, 0.05)'
                            }
                        },
                        x: {
                            type: 'time',
                            time: {
                                unit: 'minute',
                                displayFormats: {
                                    minute: 'HH:mm',
                                    hour: 'HH:mm'
                                },
                                tooltipFormat: 'MMM d, HH:mm:ss'
                            },
                            title: {
                                display: true,
                                text: 'Time',
                                font: { size: 14, weight: 'bold' }
                            },
                            grid: {
                                display: false
                            },
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45,
                                autoSkip: true,
                                maxTicksLimit: 10
                            }
                        }
                    }
                }
            });
        }
        
        // Update live placements chart for single mason
        function updateLiveChart(placements) {
            if (!placements || placements.length === 0) return;
            if (!document.getElementById('liveChart')) return;
            
            // Sort by timestamp and take last 50
            const sorted = [...placements].sort((a, b) => a.timestamp - b.timestamp).slice(-50);
            
            // Use actual timestamp values for proper time-based spacing
            const dataPoints = sorted.map((p, idx) => ({
                x: p.timestamp, // Use actual timestamp for X-axis
                y: idx + 1      // Cumulative count for Y-axis
            }));
            
            // Update existing chart instead of destroying it
            if (liveChart) {
                liveChart.data.datasets = [{
                    label: 'Cumulative Placements',
                    data: dataPoints,
                    borderColor: '#CC0000',
                    backgroundColor: 'rgba(204, 0, 0, 0.1)',
                    borderWidth: 3,
                    fill: true,
                    tension: 0.4,
                    pointRadius: 3,
                    pointHoverRadius: 6,
                    pointBackgroundColor: '#CC0000',
                    pointBorderColor: '#fff',
                    pointBorderWidth: 2
                }];
                liveChart.options.scales.y.suggestedMax = undefined;
                liveChart.update('none'); // Update without animation for smooth real-time updates
                return;
            }
            
            // Create chart only if it doesn't exist
            const liveCtx = document.getElementById('liveChart').getContext('2d');
            liveChart = new Chart(liveCtx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Cumulative Placements',
                        data: dataPoints,
                        borderColor: '#CC0000',
                        backgroundColor: 'rgba(204, 0, 0, 0.1)',
                        borderWidth: 3,
                        fill: true,
                        tension: 0.4,
                        pointRadius: 3,
                        pointHoverRadius: 6,
                        pointBackgroundColor: '#CC0000',
                        pointBorderColor: '#fff',
                        pointBorderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            padding: 12,
                            titleFont: { size: 14 },
                            bodyFont: { size: 13 },
                            callbacks: {
                                title: function(context) {
                                    const date = new Date(context[0].parsed.x);
                                    return date.toLocaleString('en-US', {
                                        month: 'short',
                                        day: 'numeric',
                                        hour: '2-digit',
                                        minute: '2-digit',
                                        second: '2-digit'
                                    });
                                },
                                label: function(context) {
                                    return 'Total: ' + context.parsed.y + ' placements';
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Cumulative Placements',
                                font: { size: 14, weight: 'bold' }
                            },
                            grid: {
                                color: 'rgba(0, 0, 0, 0.05)'
                            }
                        },
                        x: {
                            type: 'time',
                            time: {
                                unit: 'minute',
                                displayFormats: {
                                    minute: 'HH:mm',
                                    hour: 'HH:mm'
                                },
                                tooltipFormat: 'MMM d, HH:mm:ss'
                            },
                            title: {
                                display: true,
                                text: 'Time',
                                font: { size: 14, weight: 'bold' }
                            },
                            grid: {
                                display: false
                            },
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45,
                                autoSkip: true,
                                maxTicksLimit: 10
                            }
                        }
                    }
                }
            });
        }
        
        // Update daily chart with aggregate data
        function updateDailyChart(dailyData) {
            if (!document.getElementById('dailyChart')) return;
            // Sort by date ascending
            dailyData.sort((a, b) => new Date(a.date) - new Date(b.date));
            
            const masonId = document.getElementById('masonSelect').value;
            
            console.log('updateDailyChart called with:', { masonId, dataCount: dailyData.length, data: dailyData });
            
            // If "All Masons" selected, create bar chart with each mason
            if (!masonId && dailyData.length > 0) {
                // Group by date and mason
                const dateMap = {};
                const masonSet = new Set();
                
                dailyData.forEach(d => {
                    if (!dateMap[d.date]) {
                        dateMap[d.date] = {};
                    }
                    dateMap[d.date][d.masonId] = d.totalPlacements;
                    masonSet.add(d.masonId);
                });
                
                console.log('Grouped data:', { dateMap, masons: Array.from(masonSet) });
                
                const dates = Object.keys(dateMap).sort();
                const masonIds = Array.from(masonSet).sort(); // Sort for consistent ordering
                
                // Create datasets for each mason
                const datasets = masonIds.map((mId) => {
                    const color = getMasonColor(mId, masonIds);
                    
                    return {
                        label: mId,
                        data: dates.map(date => dateMap[date][mId] || 0),
                        backgroundColor: color,
                        borderColor: color,
                        borderWidth: 2,
                        borderRadius: 5
                    };
                });
                
                if (dailyChart) {
                    dailyChart.data.labels = dates;
                    dailyChart.data.datasets = datasets;
                    dailyChart.options.scales.y.suggestedMax = Math.max(...dates.map(date => 
                        Object.values(dateMap[date]).reduce((sum, val) => sum + val, 0)
                    )) + 10;
                    dailyChart.update('none'); // Update without animation
                    return;
                }
                
                // Create stacked bar chart
                const dailyCtx = document.getElementById('dailyChart').getContext('2d');
                dailyChart = new Chart(dailyCtx, {
                    type: 'bar',
                    data: {
                        labels: dates,
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            tooltip: {
                                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                                padding: 12,
                                titleFont: { size: 14 },
                                bodyFont: { size: 13 }
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                stacked: false,  // Changed from true to false for side-by-side bars
                                suggestedMax: Math.max(...dates.map(date => 
                                    Math.max(...Object.values(dateMap[date]))
                                )) + 10,
                                title: {
                                    display: true,
                                    text: 'Total Placements',
                                    font: { size: 14, weight: 'bold' }
                                },
                                grid: {
                                    color: 'rgba(0, 0, 0, 0.05)'
                                }
                            },
                            x: {
                                stacked: false,  // Changed from true to false for side-by-side bars
                                title: {
                                    display: true,
                                    text: 'Date',
                                    font: { size: 14, weight: 'bold' }
                                },
                                grid: {
                                    display: false
                                }
                            }
                        }
                    }
                });
                return;
            }
            
            // Single mason view
            const dates = dailyData.map(d => d.date);
            const totals = dailyData.map(d => d.totalPlacements);
            
            // Get the mason's color (use first data point's masonId)
            const selectedMasonId = dailyData.length > 0 ? dailyData[0].masonId : null;
            const masonColor = selectedMasonId ? getMasonColor(selectedMasonId) : '#2D3436';
            
            // Update existing chart instead of destroying it
            if (dailyChart) {
                dailyChart.data.labels = dates;
                dailyChart.data.datasets = [{
                    label: `${selectedMasonId || 'Total'} Bricks Placed`,
                    data: totals,
                    backgroundColor: masonColor,
                    borderColor: masonColor,
                    borderWidth: 2,
                    borderRadius: 5
                }];
                dailyChart.options.scales.y.stacked = false;
                dailyChart.options.scales.x.stacked = false;
                dailyChart.options.scales.y.suggestedMax = undefined;
                dailyChart.update('none'); // Update without animation
                return;
            }
            
            // Create chart only if it doesn't exist
            const dailyCtx = document.getElementById('dailyChart').getContext('2d');
            dailyChart = new Chart(dailyCtx, {
                type: 'bar',
                data: {
                    labels: dates,
                    datasets: [{
                        label: `${selectedMasonId || 'Total'} Bricks Placed`,
                        data: totals,
                        backgroundColor: masonColor,
                        borderColor: masonColor,
                        borderWidth: 2,
                        borderRadius: 5
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            padding: 12,
                            titleFont: { size: 14 },
                            bodyFont: { size: 13 }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Total Placements',
                                font: { size: 14, weight: 'bold' }
                            },
                            grid: {
                                color: 'rgba(0, 0, 0, 0.05)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Date',
                                font: { size: 14, weight: 'bold' }
                            },
                            grid: {
                                display: false
                            }
                        }
                    }
                }
            });
        }
        
        // ── Efficiency Over Time (line chart of placements/hour by date) ──
        function updateEfficiencyChart(dailyData) {
            if (!document.getElementById('efficiencyChart')) return;
            if (!dailyData || dailyData.length === 0) return;

            const sorted = [...dailyData].sort((a, b) => new Date(a.date) - new Date(b.date));
            const masonId = document.getElementById('masonSelect').value;

            let datasets, labels;

            if (!masonId && sorted.length > 0) {
                // Multi-mason: one line per mason
                const dateSet = new Set();
                const masonMap = {};
                sorted.forEach(d => {
                    dateSet.add(d.date);
                    if (!masonMap[d.masonId]) masonMap[d.masonId] = {};
                    masonMap[d.masonId][d.date] = d.placementsPerHour;
                });
                labels = [...dateSet].sort();
                const masonIds = Object.keys(masonMap).sort();
                datasets = masonIds.map(mId => {
                    const color = getMasonColor(mId, masonIds);
                    return {
                        label: mId,
                        data: labels.map(date => masonMap[mId][date] || 0),
                        borderColor: color,
                        backgroundColor: color + '22',
                        tension: 0.3,
                        fill: false,
                        pointRadius: 3,
                        borderWidth: 2
                    };
                });
            } else {
                // Single mason
                labels = sorted.map(d => d.date);
                const color = sorted.length > 0 ? getMasonColor(sorted[0].masonId) : '#CC0000';
                datasets = [{
                    label: 'Placements / Hour',
                    data: sorted.map(d => d.placementsPerHour),
                    borderColor: color,
                    backgroundColor: color + '22',
                    tension: 0.3,
                    fill: true,
                    pointRadius: 3,
                    borderWidth: 2
                }];
            }

            if (efficiencyChartInstance) {
                efficiencyChartInstance.data.labels = labels;
                efficiencyChartInstance.data.datasets = datasets;
                efficiencyChartInstance.update('none');
                return;
            }

            const ctx = document.getElementById('efficiencyChart').getContext('2d');
            efficiencyChartInstance = new Chart(ctx, {
                type: 'line',
                data: { labels, datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: true, position: 'top' },
                        tooltip: { backgroundColor: 'rgba(0,0,0,0.8)', padding: 12, titleFont: { size: 14 }, bodyFont: { size: 13 } }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: { display: true, text: 'Placements / Hour', font: { size: 14, weight: 'bold' } },
                            grid: { color: 'rgba(0,0,0,0.05)' }
                        },
                        x: {
                            title: { display: true, text: 'Date', font: { size: 14, weight: 'bold' } },
                            grid: { display: false }
                        }
                    }
                }
            });
        }

        // ── User Comparison (horizontal bar chart of total placements per user) ──
        function updateMasonCompareChart(summaryData) {
            if (!document.getElementById('masonCompareChart')) return;
            if (!summaryData || summaryData.length === 0) return;

            const sorted = [...summaryData].sort((a, b) => (b.placementCount || 0) - (a.placementCount || 0));
            const masonIds = sorted.map(s => s.masonId);
            const totals = sorted.map(s => s.placementCount || 0);
            const colors = masonIds.map(mId => getMasonColor(mId, masonIds));

            const datasets = [{
                label: 'Total Placements',
                data: totals,
                backgroundColor: colors,
                borderColor: colors,
                borderWidth: 2,
                borderRadius: 5
            }];

            if (masonCompareChartInstance) {
                masonCompareChartInstance.data.labels = masonIds;
                masonCompareChartInstance.data.datasets = datasets;
                masonCompareChartInstance.update('none');
                return;
            }

            const ctx = document.getElementById('masonCompareChart').getContext('2d');
            masonCompareChartInstance = new Chart(ctx, {
                type: 'bar',
                data: { labels: masonIds, datasets },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: { backgroundColor: 'rgba(0,0,0,0.8)', padding: 12, titleFont: { size: 14 }, bodyFont: { size: 13 } }
                    },
                    scales: {
                        x: {
                            beginAtZero: true,
                            title: { display: true, text: 'Total Placements', font: { size: 14, weight: 'bold' } },
                            grid: { color: 'rgba(0,0,0,0.05)' }
                        },
                        y: {
                            title: { display: true, text: 'User', font: { size: 14, weight: 'bold' } },
                            grid: { display: false }
                        }
                    }
                }
            });
        }

        // ── Hourly Activity Pattern (bar chart of placements by hour-of-day) ──
        function updateHourlyChart(dailyData) {
            if (!document.getElementById('hourlyChart')) return;
            if (!dailyData || dailyData.length === 0) return;

            // Bucket placements by hour from firstPlacement timestamps
            const hourBuckets = new Array(24).fill(0);
            dailyData.forEach(d => {
                if (d.firstPlacement) {
                    const hour = new Date(d.firstPlacement).getHours();
                    hourBuckets[hour] += d.totalPlacements || 0;
                }
            });

            const labels = hourBuckets.map((_, i) => {
                const h = i % 12 || 12;
                return `${h}${i < 12 ? 'a' : 'p'}`;
            });

            const maxVal = Math.max(...hourBuckets);
            const barColors = hourBuckets.map(v => {
                const ratio = maxVal > 0 ? v / maxVal : 0;
                // Gradient from light to strong red
                const alpha = 0.25 + ratio * 0.75;
                return `rgba(204, 0, 0, ${alpha})`;
            });

            const datasets = [{
                label: 'Placements',
                data: hourBuckets,
                backgroundColor: barColors,
                borderColor: '#CC0000',
                borderWidth: 1,
                borderRadius: 4
            }];

            if (hourlyChartInstance) {
                hourlyChartInstance.data.labels = labels;
                hourlyChartInstance.data.datasets = datasets;
                hourlyChartInstance.update('none');
                return;
            }

            const ctx = document.getElementById('hourlyChart').getContext('2d');
            hourlyChartInstance = new Chart(ctx, {
                type: 'bar',
                data: { labels, datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(0,0,0,0.8)', padding: 12,
                            callbacks: {
                                title: (items) => {
                                    const i = items[0].dataIndex;
                                    const h = i % 12 || 12;
                                    return `${h}:00 ${i < 12 ? 'AM' : 'PM'}`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: { display: true, text: 'Placements', font: { size: 14, weight: 'bold' } },
                            grid: { color: 'rgba(0,0,0,0.05)' }
                        },
                        x: {
                            title: { display: true, text: 'Hour of Day', font: { size: 14, weight: 'bold' } },
                            grid: { display: false }
                        }
                    }
                }
            });
        }

        // ── Placed vs Indexed (doughnut chart) ──
        function updatePlacedVsIndexedChart(placed, indexed) {
            if (!document.getElementById('placedVsIndexed')) return;
            if (placed === 0 && indexed === 0) return;

            const data = [placed, indexed];
            const bgColors = ['#10b981', '#3b82f6'];
            const borderColors = ['#059669', '#2563eb'];

            const datasets = [{
                data: data,
                backgroundColor: bgColors,
                borderColor: borderColors,
                borderWidth: 2,
                hoverOffset: 8
            }];

            if (placedVsIndexedChartInstance) {
                placedVsIndexedChartInstance.data.datasets[0].data = data;
                placedVsIndexedChartInstance.update('none');
                return;
            }

            const ctx = document.getElementById('placedVsIndexed').getContext('2d');
            placedVsIndexedChartInstance = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: ['Placed', 'Indexed'],
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: true, position: 'bottom', labels: { padding: 16, font: { size: 13 } } },
                        tooltip: {
                            backgroundColor: 'rgba(0,0,0,0.8)', padding: 12,
                            callbacks: {
                                label: (ctx) => {
                                    const total = ctx.dataset.data.reduce((a, b) => a + b, 0);
                                    const pct = total > 0 ? ((ctx.raw / total) * 100).toFixed(1) : '0.0';
                                    return `${ctx.label}: ${ctx.raw.toLocaleString()} (${pct}%)`;
                                }
                            }
                        }
                    }
                }
            });
        }

        // ── Report Section Registry ──
        const REPORT_SECTIONS = {
            daysWorked:        { type: 'kpi',   label: 'Days Worked',          icon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="4" width="18" height="18" rx="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>' },
            totalPlacements:   { type: 'kpi',   label: 'Total Placements',     icon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>' },
            totalIndexed:      { type: 'kpi',   label: 'Blocks Indexed',       icon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"/><rect x="8" y="2" width="8" height="4" rx="1"/></svg>' },
            avgPerDay:         { type: 'kpi',   label: 'Avg Per Day',          icon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="20" x2="12" y2="10"/><line x1="18" y1="20" x2="18" y2="4"/><line x1="6" y1="20" x2="6" y2="16"/></svg>' },
            peakHour:          { type: 'kpi',   label: 'Peak Hour',            icon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 18a5 5 0 0 0-10 0"/><line x1="12" y1="9" x2="12" y2="2"/><line x1="4.22" y1="10.22" x2="5.64" y2="11.64"/><line x1="1" y1="18" x2="3" y2="18"/><line x1="21" y1="18" x2="23" y2="18"/><line x1="18.36" y1="11.64" x2="19.78" y2="10.22"/><line x1="23" y1="22" x2="1" y2="22"/><line x1="12" y1="18" x2="14.5" y2="13.5"/></svg>' },
            currentEfficiency: { type: 'kpi',   label: 'Placements / Hour',    icon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg>' },
            activeMasons:      { type: 'kpi',   label: 'Active Users',         icon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>' },
            totalScans:        { type: 'kpi',   label: 'Total Scans',          icon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 16.1A5 5 0 0 1 5.9 20M2 12.05A9 9 0 0 1 9.95 20M2 8V6a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-6"/><line x1="2" y1="20" x2="2.01" y2="20"/></svg>' },
            avgPerHourAllTime: { type: 'kpi',   label: 'Avg / Hour (All Time)',icon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>' },
            uniqueBricks:      { type: 'kpi',   label: 'Unique Bricks',        icon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/></svg>' },
            dailyChart:        { type: 'chart', label: 'Daily Productivity',   icon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="20" x2="18" y2="10"/><line x1="12" y1="20" x2="12" y2="4"/><line x1="6" y1="20" x2="6" y2="14"/></svg>' },
            efficiencyChart:   { type: 'chart', label: 'Efficiency Over Time', icon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 6 13.5 15.5 8.5 10.5 1 18"/><polyline points="17 6 23 6 23 12"/></svg>' },
            masonCompareChart: { type: 'chart', label: 'User Comparison',      icon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><line x1="22" y1="8" x2="22" y2="14"/><line x1="19" y1="11" x2="25" y2="11"/></svg>' },
            hourlyChart:       { type: 'chart', label: 'Hourly Activity',      icon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>' },
            placedVsIndexed:   { type: 'chart', label: 'Placed vs Indexed',    icon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.21 15.89A10 10 0 1 1 8 2.83"/><path d="M22 12A10 10 0 0 0 12 2v10z"/></svg>' }
        };

        // Map dashboard widget keys → report section keys
        const DASH_TO_REPORT = {
            totalPlacements: 'totalPlacements',
            totalIndexed: 'totalIndexed',
            daysWorked: 'daysWorked',
            avgPerDay: 'avgPerDay',
            currentEfficiency: 'currentEfficiency',
            activeMasons: 'activeMasons',
            totalScans: 'totalScans',
            avgPerHourAllTime: 'avgPerHourAllTime',
            liveChart: 'dailyChart',
            dailyChart: 'dailyChart',
            efficiencyChart: 'efficiencyChart',
            masonCompareChart: 'masonCompareChart',
            hourlyChart: 'hourlyChart',
            placedVsIndexed: 'placedVsIndexed'
        };

        function renderReportSections(selectedKeys) {
            const container = document.getElementById('reportSections');
            const kpis = Object.entries(REPORT_SECTIONS).filter(([,v]) => v.type === 'kpi');
            const charts = Object.entries(REPORT_SECTIONS).filter(([,v]) => v.type === 'chart');
            let html = '<div class="report-section-divider">KPIs</div>';
            kpis.forEach(([key, s]) => {
                const sel = selectedKeys.has(key);
                html += `<div class="report-card${sel ? ' selected' : ''}" data-key="${key}" onclick="toggleReportCard(this,'${key}')">
                    <div class="report-card-icon">${s.icon}</div>
                    <div class="report-card-name">${s.label}</div>
                    <div class="report-card-status">${sel ? '✓ Included' : 'Tap to include'}</div>
                </div>`;
            });
            html += '<div class="report-section-divider">Charts</div>';
            charts.forEach(([key, s]) => {
                const sel = selectedKeys.has(key);
                html += `<div class="report-card${sel ? ' selected' : ''}" data-key="${key}" onclick="toggleReportCard(this,'${key}')">
                    <div class="report-card-icon">${s.icon}</div>
                    <div class="report-card-name">${s.label}</div>
                    <div class="report-card-status">${sel ? '✓ Included' : 'Tap to include'}</div>
                </div>`;
            });
            container.innerHTML = html;
        }

        function toggleReportCard(el, key) {
            el.classList.toggle('selected');
            const isSel = el.classList.contains('selected');
            el.querySelector('.report-card-status').textContent = isSel ? '✓ Included' : 'Tap to include';
            reportPresetClear();
        }

        function getReportSelectedSections() {
            return [...document.querySelectorAll('#reportSections .report-card.selected')].map(el => el.dataset.key);
        }

        function setReportCheckboxes(keys) {
            document.querySelectorAll('#reportSections .report-card').forEach(el => {
                const k = el.dataset.key;
                const isSel = keys.has(k);
                el.classList.toggle('selected', isSel);
                el.querySelector('.report-card-status').textContent = isSel ? '✓ Included' : 'Tap to include';
            });
        }

        function reportPresetClear() {
            document.querySelectorAll('.report-preset-btn').forEach(b => b.classList.remove('active'));
        }

        function reportPresetAll() {
            reportPresetClear();
            setReportCheckboxes(new Set(Object.keys(REPORT_SECTIONS)));
            event.target.classList.add('active');
        }



        function reportPresetDashboard() {
            reportPresetClear();
            const layout = getWidgetLayout();
            const reportKeys = new Set();
            layout.forEach(k => { if (DASH_TO_REPORT[k]) reportKeys.add(DASH_TO_REPORT[k]); });
            // Always add peakHour if any KPI is selected (it's report-specific and useful)
            setReportCheckboxes(reportKeys);
            event.target.classList.add('active');
        }

        // Show performance review modal
        function showReportModal() {
            const modal = document.getElementById('reportModal');
            const modalMasonSelect = document.getElementById('modalMasonSelect');
            const modalCompanyGroup = document.getElementById('modalCompanyGroup');
            const modalCompanySelect = document.getElementById('modalCompanySelect');
            const isRegularUser = !isAnyAdmin;
            const loggedInMasonId = localStorage.getItem('dashboard_masonId') || '';
            
            // Company dropdown in modal (super admin only)
            if (isSuperAdmin && modalCompanyGroup) {
                modalCompanyGroup.style.display = '';
                // Sync with main company dropdown
                const mainCompanySelect = document.getElementById('companySelect');
                modalCompanySelect.innerHTML = mainCompanySelect.innerHTML;
                modalCompanySelect.value = mainCompanySelect.value;
            } else if (modalCompanyGroup) {
                modalCompanyGroup.style.display = 'none';
            }
            
            if (isRegularUser) {
                // Regular user: lock to self
                const selfUser = allMasons.find(u => u.masonId === loggedInMasonId);
                const displayName = selfUser ? selfUser.username : 'My Data';
                modalMasonSelect.innerHTML = `<option value="${escapeHtml(loggedInMasonId)}">${escapeHtml(displayName)}</option>`;
                modalMasonSelect.disabled = true;
            } else {
                // Mirror the current main dropdown state
                const currentMasonSelect = document.getElementById('masonSelect');
                modalMasonSelect.disabled = false;
                modalMasonSelect.innerHTML = '<option value="ALL">All Users</option>';
                Array.from(currentMasonSelect.options).forEach(option => {
                    if (option.value && option.value !== '') {
                        const opt = document.createElement('option');
                        opt.value = option.value;
                        opt.textContent = option.textContent;
                        if (option.value === currentMasonSelect.value) {
                            opt.selected = true;
                        }
                        modalMasonSelect.appendChild(opt);
                    }
                });
            }

            // Default to "Same as Dashboard" preset
            const layout = getWidgetLayout();
            const reportKeys = new Set();
            layout.forEach(k => { if (DASH_TO_REPORT[k]) reportKeys.add(DASH_TO_REPORT[k]); });
            renderReportSections(reportKeys);
            
            modal.classList.add('show');
        }
        
        // Filter modal user dropdown by modal company select (super admin)
        function filterModalUsers() {
            const companyId = document.getElementById('modalCompanySelect').value;
            const modalMasonSelect = document.getElementById('modalMasonSelect');
            let filtered = allMasons;
            if (companyId) {
                filtered = allMasons.filter(u => String(u.companyId) === String(companyId));
            }
            modalMasonSelect.innerHTML = '<option value="ALL">All Users</option>';
            filtered.forEach(user => {
                const opt = document.createElement('option');
                opt.value = user.masonId;
                opt.textContent = user.username;
                modalMasonSelect.appendChild(opt);
            });
        }
        
        // Close performance review modal
        function closeReportModal() {
            const modal = document.getElementById('reportModal');
            modal.classList.remove('show');
        }
        
        // Generate report from modal
        function generateReport() {
            const masonId = document.getElementById('modalMasonSelect').value;
            const periodDays = document.getElementById('modalPeriodSelect').value;
            const sections = getReportSelectedSections();

            if (sections.length === 0) {
                alert('Please select at least one report section.');
                return;
            }
            
            // Determine company context for the report
            let companyName = '';
            if (isSuperAdmin) {
                const modalCompanySel = document.getElementById('modalCompanySelect');
                if (modalCompanySel && modalCompanySel.value) {
                    // A specific company is selected
                    companyName = modalCompanySel.options[modalCompanySel.selectedIndex].textContent;
                } else {
                    companyName = 'All Companies';
                }
            } else if (isCompanyAdmin && userCompany) {
                companyName = userCompany.name;
            }
            
            // Resolve display name for the selected user
            let userName = '';
            if (masonId && masonId !== 'ALL') {
                const selOpt = document.getElementById('modalMasonSelect');
                if (selOpt) userName = selOpt.options[selOpt.selectedIndex].textContent;
            }
            
            // Calculate date range based on selected period
            const endDate = Date.now();
            let startDate;
            
            if (periodDays === 'all') {
                startDate = 0; // Unix epoch
            } else {
                const days = parseInt(periodDays);
                startDate = endDate - (days * 24 * 60 * 60 * 1000);
            }
            
            // Open report in new tab (pass token, sections, company, and username as query params)
            let reportUrl = `${API_BASE}/api/report/mason/${masonId}?startDate=${startDate}&endDate=${endDate}&sections=${sections.join(',')}&token=${encodeURIComponent(authToken)}`;
            if (companyName) reportUrl += `&companyName=${encodeURIComponent(companyName)}`;
            if (userName) reportUrl += `&userName=${encodeURIComponent(userName)}`;
            window.open(reportUrl, '_blank');
            
            // Close modal
            closeReportModal();
        }
        
        // Close modal when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('reportModal');
            if (event.target === modal) {
                closeReportModal();
            }
        }
        
        // Show error message
        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }
        
        // Hide error message
        function hideError() {
            document.getElementById('error').style.display = 'none';
        }
        
        // Company selection change handler (super admin)
        document.getElementById('companySelect').addEventListener('change', function() {
            const companyId = this.value;
            populateUserDropdown(allMasons, companyId || null);
            // Reset user selection and refresh data
            document.getElementById('masonSelect').value = '';
            currentMasonId = '';
            allPlacements = [];
            lastPlacementIds = new Set();
            lastPlacementCount = 0;
            refreshData();
            loadPlacements();
            if (map) loadMapData();
        });
        
        // Mason selection change handler
        document.getElementById('masonSelect').addEventListener('change', function() {
            currentMasonId = this.value;
            allPlacements = [];
            lastPlacementIds = new Set();
            lastPlacementCount = 0;
            refreshData();
            loadPlacements();
            
            // Refresh map if it's initialized
            if (map) {
                loadMapData();
            }
        });
        
        // Initialize on page load
        window.addEventListener('DOMContentLoaded', initDashboard);
        
        window.addEventListener('beforeunload', () => {
            if (refreshInterval) {
                clearInterval(refreshInterval);
            }
        });
    </script>
    <button class="scroll-to-top" id="scrollToTop" title="Scroll to top" onclick="window.scrollTo({top:0,behavior:'smooth'})">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="18 15 12 9 6 15"/></svg>
    </button>
    <script>
    (function(){
        const btn=document.getElementById('scrollToTop');
        window.addEventListener('scroll',function(){
            const scrollTop=window.scrollY||document.documentElement.scrollTop;
            const docHeight=document.documentElement.scrollHeight-window.innerHeight;
            if(docHeight>0 && scrollTop/docHeight>0.5){btn.classList.add('visible')}else{btn.classList.remove('visible')}
        },{passive:true});
    })();
    </script>
</body>
</html>
