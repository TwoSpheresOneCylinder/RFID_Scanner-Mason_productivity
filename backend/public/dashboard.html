<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mason Efficiency Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Barlow+Semi+Condensed:wght@400;600;700;800&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f5f5;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            padding: 0;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1), 0 12px 40px rgba(0,0,0,0.15);
            overflow: hidden;
        }
        
        .header {
            display: flex;
            align-items: stretch;
            margin-bottom: 0;
            border-radius: 12px 12px 0 0;
            overflow: hidden;
            min-height: 100px;
            position: relative;
            z-index: 10;
            box-shadow: 0 6px 16px rgba(0,0,0,0.25), 0 12px 32px rgba(0,0,0,0.15);
        }
        
        .header-left {
            background: #2D3436;
            color: white;
            flex: 0 0 70%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            padding: 25px 60px 25px 30px;
            position: relative;
            z-index: 1;
        }
        
        .header-left::after {
            content: '';
            position: absolute;
            top: 0;
            right: -40px;
            width: 80px;
            height: 100%;
            background: #2D3436;
            transform: skewX(-17deg);
            z-index: 1;
        }
        
        .header-left h1 {
            font-family: 'Barlow Semi Condensed', sans-serif;
            font-size: 2.2rem;
            margin: 0 0 6px 0;
            font-weight: 700;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            text-shadow: 0 1px 3px rgba(0,0,0,0.15);
        }
        
        .header-left p {
            font-size: 1.05rem;
            opacity: 0.7;
            margin: 0;
            text-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .header-right {
            background: white;
            flex: 0 0 30%;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding: 20px 30px 20px 60px;
        }
        
        .header-right img {
            max-height: 60px;
            width: auto;
        }

        .user-bar {
            background: #CC0000;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-radius: 0 0 10px 10px;
            margin-top: -10px;
            margin-bottom: 0;
            font-size: 0.9rem;
            position: relative;
            z-index: 9;
            min-height: 52px;
            padding: 22px 16px 14px 16px;
            box-shadow: 0 6px 16px rgba(0,0,0,0.25), 0 12px 32px rgba(0,0,0,0.15);
        }

        .user-bar .user-info {
            display: flex;
            align-items: center;
            gap: 10px;
            color: white;
        }

        .user-bar .user-icon {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: white;
            overflow: hidden;
            flex-shrink: 0;
        }

        .user-bar .user-icon img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            object-position: top;
        }

        .user-bar .user-info strong {
            font-weight: 700;
            color: white;
            font-size: 0.95rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            text-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        .settings-wrapper {
            position: relative;
        }

        .btn-settings {
            background: none;
            border: none;
            cursor: pointer;
            padding: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background 0.2s;
        }

        .btn-settings:hover {
            background: rgba(255,255,255,0.15);
        }

        .btn-settings svg {
            width: 22px;
            height: 22px;
            fill: white;
        }

        .settings-dropdown {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 6px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.15);
            min-width: 160px;
            z-index: 1000;
            overflow: hidden;
        }

        .settings-dropdown.open {
            display: block;
        }

        .settings-dropdown button {
            display: flex;
            align-items: center;
            gap: 10px;
            width: 100%;
            padding: 12px 16px;
            border: none;
            background: none;
            cursor: pointer;
            font-size: 0.85rem;
            font-family: inherit;
            color: #2D3436;
            transition: background 0.15s;
        }

        .settings-dropdown button:hover {
            background: #f5f5f5;
        }

        .settings-dropdown button svg {
            width: 16px;
            height: 16px;
            fill: #636E72;
        }

        .settings-dropdown button.danger {
            color: #CC0000;
        }

        .settings-dropdown button.danger svg {
            fill: #CC0000;
        }
        
        .controls {
            background: white;
            padding: 24px 20px 20px 20px;
            border-radius: 0;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            margin-top: -10px;
            margin-bottom: 0;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
            position: relative;
            z-index: 8;
        }
        
        .tabs {
            display: flex;
            background: white;
            border-radius: 0;
            box-shadow: none;
            margin-top: -10px;
            margin-bottom: 0;
            overflow: hidden;
            position: relative;
            z-index: 7;
            padding-top: 10px;
        }
        
        .tab-button {
            flex: 1;
            padding: 15px 20px;
            background: #f5f5f5;
            border: none;
            cursor: pointer;
            font-family: 'Barlow Semi Condensed', sans-serif;
            font-size: 1rem;
            font-weight: 600;
            color: #666;
            transition: all 0.3s;
            border-bottom: 3px solid transparent;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .tab-button:hover {
            background: #e8e8e8;
        }
        
        .tab-button.active {
            background: white;
            color: #2D3436;
            border-bottom-color: #CC0000;
        }
        
        .tab-content {
            display: none;
            background: white;
            padding: 20px;
            border-radius: 0;
            box-shadow: none;
            position: relative;
            z-index: 6;
        }
        
        .tab-content.active {
            display: block;
        }
        
        #map {
            width: 100%;
            height: 600px;
            border-radius: 8px;
        }

        .pallet-bubble-marker {
            background: none !important;
            border: none !important;
        }
        
        .map-controls {
            margin-bottom: 15px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .map-controls button {
            padding: 8px 16px;
            background: #2D3436;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
        }
        
        .map-controls button:hover {
            background: #444;
        }
        
        .controls label {
            font-weight: 600;
            color: #333;
        }
        
        .controls select, .controls button {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 1px 4px rgba(0,0,0,0.1);
        }
        
        .controls select {
            background: white;
        }
        
        .controls button {
            background: #E0E0E0;
            color: white;
            font-weight: 600;
        }
        
        .controls button:hover {
            background: #D0D0D0;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .stat-card {
            background: white;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08), 0 8px 24px rgba(0,0,0,0.12);
            text-align: center;
            transition: transform 0.3s;
        }
        
        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1), 0 12px 32px rgba(0,0,0,0.18);
        }
        
        .stat-card h3 {
            font-family: 'Barlow Semi Condensed', sans-serif;
            color: #555;
            font-size: 0.9rem;
            text-transform: uppercase;
            margin-bottom: 10px;
            letter-spacing: 1px;
            font-weight: 600;
        }
        
        .stat-card .value {
            font-family: 'Barlow Semi Condensed', sans-serif;
            font-size: 2.5rem;
            font-weight: 700;
            color: #333;
            margin-bottom: 5px;
        }
        
        .stat-card .label {
            color: #666;
            font-size: 0.9rem;
        }
        
        .chart-container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08), 0 8px 24px rgba(0,0,0,0.12);
            margin-bottom: 20px;
        }
        
        .chart-container h2 {
            font-family: 'Barlow Semi Condensed', sans-serif;
            color: #333;
            margin-bottom: 20px;
            text-align: center;
            font-weight: 700;
            letter-spacing: 0.5px;
            text-transform: uppercase;
        }
        
        .chart-wrapper {
            position: relative;
            height: 400px;
        }
        
        .last-updated {
            text-align: center;
            color: #888;
            font-size: 0.9rem;
            opacity: 0.8;
            margin-top: -6px;
            padding-top: 20px;
            position: relative;
            z-index: 5;
        }
        
        .loading {
            text-align: center;
            color: #666;
            font-size: 1.2rem;
            padding: 50px;
        }
        
        .error {
            background: #ff6b6b;
            color: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            margin-bottom: 20px;
        }
        
        .mason-select-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .refresh-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #4ade80;
            margin-left: 10px;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            animation: fadeIn 0.3s;
        }
        
        .modal.show {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            max-width: 500px;
            width: 90%;
            animation: slideIn 0.3s;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes slideIn {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        .modal-content h2 {
            font-family: 'Barlow Semi Condensed', sans-serif;
            color: #2D3436;
            margin-bottom: 20px;
            text-align: center;
            font-weight: 700;
            letter-spacing: 0.5px;
            text-transform: uppercase;
        }
        
        .modal-field {
            margin-bottom: 20px;
        }
        
        .modal-field label {
            display: block;
            color: #333;
            font-weight: 600;
            margin-bottom: 8px;
        }
        
        .modal-field select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1rem;
            background: white;
            cursor: pointer;
            transition: border-color 0.3s;
        }
        
        .modal-field select:focus {
            outline: none;
            border-color: #2D3436;
        }
        
        .modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 25px;
        }
        
        .modal-buttons button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .modal-buttons .btn-generate {
            background: #2D3436;
            color: white;
        }
        
        .modal-buttons .btn-generate:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .modal-buttons .btn-cancel {
            background: #e0e0e0;
            color: #666;
        }
        
        .modal-buttons .btn-cancel:hover {
            background: #d0d0d0;
        }
        
        .placement-log {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08), 0 8px 24px rgba(0,0,0,0.12);
            margin-bottom: 20px;
            max-height: 500px;
            overflow-y: auto;
        }
        
        .placement-log h2 {
            font-family: 'Barlow Semi Condensed', sans-serif;
            color: #333;
            margin-bottom: 20px;
            text-align: center;
            font-weight: 700;
            letter-spacing: 0.5px;
            text-transform: uppercase;
        }
        
        .placement-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            border-bottom: 1px solid #e0e0e0;
            transition: background 0.2s;
        }
        
        .placement-item:hover {
            background: #f5f5f5;
        }
        
        .placement-item:last-child {
            border-bottom: none;
        }
        
        .placement-item.new {
            animation: highlight 1s;
        }
        
        @keyframes highlight {
            0% { background: #4ade80; }
            100% { background: transparent; }
        }
        
        .placement-timestamp {
            font-family: 'Courier New', monospace;
            color: #333;
            font-weight: bold;
            font-size: 0.95rem;
        }
        
        .placement-details {
            display: flex;
            gap: 20px;
            align-items: center;
        }
        
        .placement-mason {
            color: #2D3436;
            font-weight: 600;
        }
        
        .placement-brick {
            color: #666;
            font-size: 0.9rem;
            font-family: 'Courier New', monospace;
        }
        
        .no-placements {
            text-align: center;
            color: #999;
            padding: 40px;
            font-style: italic;
        }

        /* Banner build-down animation — matches the Android app cascade */
        @keyframes bannerSlideDown {
            0% {
                opacity: 0;
                transform: translateY(-40px) scaleY(0.96);
            }
            40% {
                opacity: 0.7;
                transform: translateY(-8px) scaleY(0.99);
            }
            100% {
                opacity: 1;
                transform: translateY(0) scaleY(1);
            }
        }

        .header,
        .user-bar,
        .controls,
        .tabs,
        .stats-grid {
            will-change: transform, opacity;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            transform-origin: top center;
            animation-fill-mode: both;
            animation-timing-function: cubic-bezier(0, 0, 0.2, 1); /* Material decelerate */
            animation-name: bannerSlideDown;
        }

        .header {
            animation-duration: 0.35s;
            animation-delay: 0s;
        }

        .user-bar {
            animation-duration: 0.38s;
            animation-delay: 0.12s;
        }

        .controls {
            animation-duration: 0.41s;
            animation-delay: 0.24s;
        }

        .tabs {
            animation-duration: 0.44s;
            animation-delay: 0.36s;
        }

        .stats-grid {
            animation-duration: 0.47s;
            animation-delay: 0.48s;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="header-left">
                <h1 id="dashboardTitle">Efficiency Dashboard</h1>
                <p>Real-time performance insights</p>
            </div>
            <div class="header-right">
                <img src="cr_logo.png" alt="Construction Robotics">
            </div>
        </div>

        <div class="user-bar">
            <span class="user-info">
                <span class="user-icon">
                    <img src="usericon.png" alt="User">
                </span>
                <strong id="currentUserDisplay">—</strong>
            </span>
            <div class="settings-wrapper">
                <button class="btn-settings" onclick="toggleSettingsMenu()" title="Account Settings">
                    <svg viewBox="0 0 24 24"><path d="M19.14 12.94c.04-.31.06-.63.06-.94 0-.31-.02-.63-.06-.94l2.03-1.58a.49.49 0 00.12-.61l-1.92-3.32a.49.49 0 00-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54a.484.484 0 00-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96a.49.49 0 00-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.04.31-.06.63-.06.94s.02.63.06.94l-2.03 1.58a.49.49 0 00-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6A3.6 3.6 0 1112 8.4a3.6 3.6 0 010 7.2z"/></svg>
                </button>
                <div class="settings-dropdown" id="settingsDropdown">
                    <button id="manageUsersBtn" onclick="openManageUsers()" style="display: none;">
                        <svg viewBox="0 0 24 24"><path d="M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5C6.34 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z"/></svg>
                        Manage Users
                    </button>
                    <button onclick="logout()" class="danger">
                        <svg viewBox="0 0 24 24"><path d="M17 7l-1.41 1.41L18.17 11H8v2h10.17l-2.58 2.58L17 17l5-5zM4 5h8V3H4c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h8v-2H4V5z"/></svg>
                        Sign Out
                    </button>
                </div>
            </div>
        </div>
        
        <div class="controls">
            <div class="mason-select-group">
                <label for="masonSelect">User</label>
                <select id="masonSelect">
                    <option value="">Loading...</option>
                </select>
            </div>
            <button onclick="showReportModal()" style="background: #636E72; margin-left: auto;">
                Create Performance Review
            </button>
        </div>
        
        <!-- Performance Review Modal -->
        <div id="reportModal" class="modal">
            <div class="modal-content">
                <h2>Generate Performance Review</h2>
                <div class="modal-field">
                    <label for="modalMasonSelect">User</label>
                    <select id="modalMasonSelect">
                        <option value="ALL">All Users</option>
                    </select>
                </div>
                <div class="modal-field">
                    <label for="modalPeriodSelect">Time Period:</label>
                    <select id="modalPeriodSelect">
                        <option value="1">Today</option>
                        <option value="7">Last 7 Days</option>
                        <option value="30" selected>Last 30 Days</option>
                        <option value="90">Last 90 Days (Quarterly)</option>
                        <option value="365">Last Year</option>
                        <option value="all">All Time</option>
                    </select>
                </div>
                <div class="modal-buttons">
                    <button class="btn-cancel" onclick="closeReportModal()">Cancel</button>
                    <button class="btn-generate" onclick="generateReport()">Generate Report</button>
                </div>
            </div>
        </div>
        
        <div id="error" class="error" style="display: none;"></div>
        
        <div id="loading" class="loading">Loading dashboard data...</div>
        
        <div id="dashboard" style="display: none; margin-top: -10px; position: relative; z-index: 7;">
            <!-- Tab Navigation -->
            <div class="tabs">
                <button class="tab-button active" onclick="switchTab('overview')">Overview</button>
                <button class="tab-button" onclick="switchTab('map')">Map View</button>
            </div>
            
            <!-- Overview Tab -->
            <div id="overview-tab" class="tab-content active">
            <div class="stats-grid">
                <div class="stat-card" style="border-top:3px solid #10b981;">
                    <h3>Blocks Placed</h3>
                    <div class="value" id="totalPlacements">0</div>
                </div>
                <div class="stat-card" style="border-top:3px solid #3b82f6;">
                    <h3>Blocks Indexed</h3>
                    <div class="value" id="totalIndexed">0</div>
                </div>
                <div class="stat-card">
                    <h3>Days Worked</h3>
                    <div class="value" id="daysWorked">0</div>
                </div>
                <div class="stat-card">
                    <h3>Placements / Day</h3>
                    <div class="value" id="avgPerDay">0</div>
                </div>
                <div class="stat-card">
                    <h3>Placements / Hour</h3>
                    <div class="value" id="currentEfficiency">0</div>
                </div>
            </div>
            
            <div class="chart-container">
                <h2>Live Placements Timeline</h2>
                <div class="chart-wrapper">
                    <canvas id="liveChart"></canvas>
                </div>
            </div>
            
            <div class="chart-container">
                <h2>Daily Placement Totals</h2>
                <div class="chart-wrapper">
                    <canvas id="dailyChart"></canvas>
                </div>
            </div>
            
            <div class="placement-log">
                <div style="display:flex;align-items:center;justify-content:space-between;flex-wrap:wrap;gap:8px;margin-bottom:12px;">
                    <h2 style="margin:0;">Live Scan Log</h2>
                    <div id="logFilterBtns" style="display:flex;gap:6px;">
                        <button onclick="setLogFilter('all')" id="filterAll" style="padding:4px 12px;border-radius:6px;border:1px solid #ccc;background:#2D3436;color:white;font-size:0.8rem;font-weight:600;cursor:pointer;">All</button>
                        <button onclick="setLogFilter('placement')" id="filterPlacement" style="padding:4px 12px;border-radius:6px;border:1px solid #ccc;background:transparent;color:#555;font-size:0.8rem;font-weight:600;cursor:pointer;">Placements</button>
                        <button onclick="setLogFilter('pallet')" id="filterPallet" style="padding:4px 12px;border-radius:6px;border:1px solid #ccc;background:transparent;color:#555;font-size:0.8rem;font-weight:600;cursor:pointer;">Pallet</button>
                    </div>
                </div>
                <div id="placementLog">
                    <div class="no-placements">Loading placements...</div>
                </div>
            </div>
            </div>
            
            <!-- Map Tab -->
            <div id="map-tab" class="tab-content">
                <h2 style="margin-bottom: 15px;">Placement Locations</h2>
                <div class="map-controls">
                    <button onclick="fitMapBounds()">Fit All Markers</button>
                    <button onclick="refreshMapData()">Refresh Map</button>
                    <div style="display:flex;gap:6px;margin-left:auto;">
                        <button onclick="setMapFilter('all')" id="mapFilterAll" style="padding:4px 12px;border-radius:6px;border:1px solid #ccc;background:#2D3436;color:white;font-size:0.8rem;font-weight:600;cursor:pointer;">All</button>
                        <button onclick="setMapFilter('placement')" id="mapFilterPlacement" style="padding:4px 12px;border-radius:6px;border:1px solid #ccc;background:transparent;color:#555;font-size:0.8rem;font-weight:600;cursor:pointer;">Placements</button>
                        <button onclick="setMapFilter('pallet')" id="mapFilterPallet" style="padding:4px 12px;border-radius:6px;border:1px solid #ccc;background:transparent;color:#555;font-size:0.8rem;font-weight:600;cursor:pointer;">Pallet</button>
                    </div>
                </div>
                <div id="map"></div>
            </div>
            
            <!-- Manage Users Tab (admin only) -->
            <div id="manage-users-tab" class="tab-content">
                <h2 style="margin-bottom: 15px;">User Management</h2>

                <div style="overflow-x: auto;">
                    <table id="userManagementTable" style="width: 100%; border-collapse: collapse; font-size: 0.95rem;">
                        <thead>
                            <tr style="background: #2D3436; color: white; text-align: left;">
                                <th style="padding: 12px 16px;">Username</th>
                                <th style="padding: 12px 16px;">Mason ID</th>
                                <th style="padding: 12px 16px;">Company</th>
                                <th style="padding: 12px 16px;">Role</th>
                                <th style="padding: 12px 16px;">Actions</th>
                            </tr>
                        </thead>
                        <tbody id="userManagementBody">
                            <tr><td colspan="5" style="padding: 20px; text-align: center; color: #999;">Loading users...</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
        
        <div class="last-updated">
            Last updated: <span id="lastUpdated">Never</span>
        </div>
    </div>
    
    <script>
        // XSS sanitization helper
        function escapeHtml(str) {
            if (str === null || str === undefined) return '';
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
        }

        const API_BASE = window.location.origin;
        let authToken = localStorage.getItem('dashboard_token');
        let liveChart = null;
        let dailyChart = null;
        let currentMasonId = null;
        let allMasons = [];
        let refreshInterval = null;
        let lastPlacementIds = new Set();
        let allPlacements = [];
        let lastPlacementCount = 0;
        let isUpdating = false;
        let logFilter = 'all'; // 'all', 'placement', 'pallet'
        let mapFilter = 'all'; // 'all', 'placement', 'pallet'
        
        // Role awareness
        const userRole = localStorage.getItem('dashboard_role') || 'user';
        const isSuperAdmin = localStorage.getItem('dashboard_isSuperAdmin') === 'true';
        const isCompanyAdmin = localStorage.getItem('dashboard_isCompanyAdmin') === 'true';
        const isAnyAdmin = isSuperAdmin || isCompanyAdmin;
        const userCompanyRaw = localStorage.getItem('dashboard_company');
        const userCompany = userCompanyRaw ? JSON.parse(userCompanyRaw) : null;
        
        // Redirect to login page if not authenticated
        if (!authToken) {
            window.location.href = '/';
        }

        // Show current user in the user bar (with role badge)
        const currentUser = localStorage.getItem('dashboard_user');
        if (currentUser) {
            let displayText = currentUser;
            if (isSuperAdmin) {
                displayText += ' (Super Admin)';
            } else if (isCompanyAdmin) {
                displayText += ' (Company Admin)';
            }
            document.getElementById('currentUserDisplay').textContent = displayText;
        }

        // Authenticated fetch wrapper — attaches Bearer token to all API calls
        async function authFetch(url, options = {}) {
            if (!authToken) {
                window.location.href = '/';
                throw new Error('Not authenticated');
            }
            const headers = { ...(options.headers || {}), 'Authorization': `Bearer ${authToken}` };
            let response = await fetch(url, { ...options, headers });
            // If token expired, redirect to login
            if (response.status === 401) {
                logout();
                throw new Error('Session expired');
            }
            return response;
        }

        // Logout — clear all stored auth data and redirect to login
        function logout() {
            localStorage.removeItem('dashboard_token');
            localStorage.removeItem('dashboard_user');
            localStorage.removeItem('dashboard_pass');
            localStorage.removeItem('dashboard_masonId');
            localStorage.removeItem('dashboard_isAdmin');
            localStorage.removeItem('dashboard_role');
            localStorage.removeItem('dashboard_isSuperAdmin');
            localStorage.removeItem('dashboard_isCompanyAdmin');
            localStorage.removeItem('dashboard_company');
            window.location.href = '/';
        }

        // Settings cog dropdown
        function toggleSettingsMenu() {
            document.getElementById('settingsDropdown').classList.toggle('open');
        }

        // Open Manage Users tab from cog menu
        function openManageUsers() {
            document.getElementById('settingsDropdown').classList.remove('open');
            switchTab('manage-users');
        }

        document.addEventListener('click', function(e) {
            const wrapper = document.querySelector('.settings-wrapper');
            if (wrapper && !wrapper.contains(e.target)) {
                document.getElementById('settingsDropdown').classList.remove('open');
            }
        });
        
        // Map variables
        let map = null;
        let markers = [];
        let markerGroup = null;
        let wallPolygons = [];
        let cachedPlacementScans = null;
        let cachedPalletScans = null;
        let isZoomRender = false;
        
        // Color palette for different masons
        const masonColors = [
            '#FF0000', '#0066FF', '#00CC00', '#FF6600', 
            '#AA00FF', '#00CCCC', '#FF00AA', '#CCCC00',
            '#FF3399', '#00FF66', '#3366FF', '#FF9900'
        ];
        
        // Helper function to get consistent color for a mason
        function getMasonColor(masonId, allMasonIds = null) {
            // If we have all mason IDs, use them for consistent ordering
            if (allMasonIds) {
                const sortedMasons = [...allMasonIds].sort();
                const index = sortedMasons.indexOf(masonId);
                return index >= 0 ? masonColors[index % masonColors.length] : '#CC0000';
            }
            // Fallback: get unique masons from allPlacements
            if (allPlacements.length > 0) {
                const sortedMasons = [...new Set(allPlacements.map(p => p.mason_id || p.masonId))].sort();
                const index = sortedMasons.indexOf(masonId);
                return index >= 0 ? masonColors[index % masonColors.length] : '#CC0000';
            }
            return '#CC0000';
        }
        
        // Clustering parameters
        // Zoom-based cluster distance: zoomed out = absorb, zoomed in = break apart
        // Even at max zoom, overlapping points within 3m merge so you can click them
        function getClusterDistance(zoom) {
            // Conservative clustering — only merge truly nearby scans
            if (zoom >= 20) return 3;
            if (zoom >= 19) return 5;
            if (zoom >= 18) return 8;
            if (zoom >= 17) return 12;
            if (zoom >= 16) return 18;
            if (zoom >= 15) return 30;
            if (zoom >= 14) return 50;
            if (zoom >= 13) return 120;
            if (zoom >= 12) return 250;
            if (zoom >= 10) return 600;
            if (zoom >= 8) return 2000;
            return 5000;
        }

        // After geographic clustering, merge any clusters whose markers
        // would visually overlap on screen. Guarantees zero icon stacking.
        function mergeOverlappingClusters(clusters, markerSizePx) {
            if (!map || clusters.length <= 1) return clusters;

            // Markers display at scale(0.5), so visual size is half
            const minPixelDist = markerSizePx * 0.55;
            let merged = clusters.map(c => [...c]); // deep copy
            let changed = true;

            while (changed) {
                changed = false;
                for (let i = 0; i < merged.length; i++) {
                    const ci = merged[i];
                    const latI = ci.reduce((s, p) => s + p.latitude, 0) / ci.length;
                    const lngI = ci.reduce((s, p) => s + p.longitude, 0) / ci.length;
                    const pxI = map.latLngToContainerPoint(L.latLng(latI, lngI));

                    for (let j = i + 1; j < merged.length; j++) {
                        const cj = merged[j];
                        const latJ = cj.reduce((s, p) => s + p.latitude, 0) / cj.length;
                        const lngJ = cj.reduce((s, p) => s + p.longitude, 0) / cj.length;
                        const pxJ = map.latLngToContainerPoint(L.latLng(latJ, lngJ));

                        const dx = pxI.x - pxJ.x;
                        const dy = pxI.y - pxJ.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < minPixelDist) {
                            // Merge j into i
                            merged[i] = ci.concat(cj);
                            merged.splice(j, 1);
                            changed = true;
                            break;
                        }
                    }
                    if (changed) break; // restart outer loop after merge
                }
            }
            return merged;
        }
        
        // Tab switching function
        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            // Highlight the matching tab button if one exists (manage-users has no tab button)
            const matchingBtn = document.querySelector(`.tab-button[onclick*="'${tabName}'"]`);
            if (matchingBtn) {
                matchingBtn.classList.add('active');
            }
            
            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(tabName + '-tab').classList.add('active');
            
            // Initialize map when switching to map tab
            if (tabName === 'map' && !map) {
                setTimeout(() => initializeMap(), 100);
            }
        }
        
        // Initialize Leaflet Map
        async function initializeMap() {
            const mapDiv = document.getElementById('map');
            if (!mapDiv || map) return;
            
            // Create map centered on USA
            map = L.map('map').setView([39.8283, -98.5795], 4);
            
            // Add OpenStreetMap tiles (free, no API key needed)
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: 'Â© OpenStreetMap contributors',
                maxZoom: 19
            }).addTo(map);
            
            // Create marker group for easy management
            markerGroup = L.layerGroup().addTo(map);
            
            // Re-render on zoom change so markers cluster/uncluster dynamically
            map.on('zoomend', function() {
                if (cachedPlacementScans || cachedPalletScans) {
                    renderMapFromCache();
                }
            });
            
            loadMapData();
        }
        
        // Re-render map from cached data (called on zoom change)
        function renderMapFromCache() {
            isZoomRender = true;
            const zoom = map.getZoom();
            const clusterDist = getClusterDistance(zoom);
            
            if (mapFilter === 'pallet') {
                if (cachedPalletScans) updateMapWithPalletBubbles(cachedPalletScans);
            } else if (mapFilter === 'placement') {
                if (cachedPlacementScans) renderPlacementBubbles(cachedPlacementScans);
            } else {
                // "all" mode: always use combined renderer
                const allScans = [...(cachedPlacementScans || []), ...(cachedPalletScans || [])];
                if (allScans.length > 0) renderCombinedBubbles(allScans);
            }
            isZoomRender = false;
        }
        
        // Load placement data for map
        async function loadMapData() {
            try {
                const masonId = document.getElementById('masonSelect').value;
                const url = masonId ? 
                    `${API_BASE}/api/placements/mason/${masonId}` : 
                    `${API_BASE}/api/placements/recent?limit=500`;
                
                const response = await authFetch(url);
                const data = await response.json();
                
                if (data.success && data.placements) {
                    const all = data.placements;
                    
                    // Cache the data for zoom-based re-rendering
                    cachedPlacementScans = all.filter(p => (p.scan_type || p.scanType || 'placement') !== 'pallet');
                    cachedPalletScans = all.filter(p => (p.scan_type || p.scanType || 'placement') === 'pallet');
                    
                    if (mapFilter === 'pallet') {
                        updateMapWithPalletBubbles(cachedPalletScans);
                    } else if (mapFilter === 'placement') {
                        renderPlacementBubbles(cachedPlacementScans);
                    } else {
                        // 'all' — always use combined renderer
                        renderCombinedBubbles([...cachedPlacementScans, ...cachedPalletScans]);
                    }
                }
            } catch (error) {
                console.error('Error loading map data:', error);
            }
        }
        
        // Calculate distance between two GPS points in meters
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371e3; // Earth radius in meters
            const phi1 = lat1 * Math.PI / 180;
            const phi2 = lat2 * Math.PI / 180;
            const dPhi = (lat2 - lat1) * Math.PI / 180;
            const dLambda = (lon2 - lon1) * Math.PI / 180;
            
            const a = Math.sin(dPhi/2) * Math.sin(dPhi/2) +
                    Math.cos(phi1) * Math.cos(phi2) *
                    Math.sin(dLambda/2) * Math.sin(dLambda/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            
            return R * c;
        }
        

        // Build a diagonal CSS gradient from mason proportions in a cluster
        // Returns a CSS background value: solid color for 1 mason, diagonal gradient for multi-mason
        function getMasonGradient(cluster, uniqueMasons) {
            const masons = [...new Set(cluster.map(p => p.mason_id || p.masonId))];
            if (masons.length === 1) {
                const idx = uniqueMasons.indexOf(masons[0]);
                return idx >= 0 ? masonColors[idx % masonColors.length] : '#CC0000';
            }
            // Count per mason, sorted by count descending
            const counts = masons.map(m => ({
                mason: m,
                count: cluster.filter(p => (p.mason_id || p.masonId) === m).length,
                color: (() => { const i = uniqueMasons.indexOf(m); return i >= 0 ? masonColors[i % masonColors.length] : '#CC0000'; })()
            })).sort((a, b) => b.count - a.count);
            const total = cluster.length;
            // Build gradient stops
            let pct = 0;
            const stops = [];
            counts.forEach(c => {
                const end = pct + (c.count / total) * 100;
                stops.push(`${c.color} ${pct.toFixed(1)}%`);
                stops.push(`${c.color} ${end.toFixed(1)}%`);
                pct = end;
            });
            return `linear-gradient(135deg, ${stops.join(', ')})`;
        }
        
        // Simple proximity-only clustering (no time/direction constraints)
        // Used when zoomed out so everything merges properly
        function clusterByProximity(placements, maxDist) {
            const clusters = [];
            const visited = new Set();
            placements.forEach((p, idx) => {
                if (visited.has(idx)) return;
                const cluster = [p];
                const queue = [p];
                visited.add(idx);
                while (queue.length > 0) {
                    const current = queue.shift();
                    placements.forEach((other, otherIdx) => {
                        if (visited.has(otherIdx)) return;
                        const dist = calculateDistance(
                            current.latitude, current.longitude,
                            other.latitude, other.longitude
                        );
                        if (dist <= maxDist) {
                            cluster.push(other);
                            queue.push(other);
                            visited.add(otherIdx);
                        }
                    });
                }
                clusters.push(cluster);
            });
            return clusters;
        }
        
        // Render ALL scans (placements + pallets) as unified combined bubbles
        // Used in "all" mode at every zoom level.
        // Zoom <= 14: "Job Site #N" neutral bubbles (everything clusters into sites)
        // Zoom > 14: individual/combined bubbles with brick + pallet icons
        function renderCombinedBubbles(allScans) {
            if (!map || !markerGroup) return;
            
            markerGroup.clearLayers();
            markers = [];
            wallPolygons.forEach(p => p.remove());
            wallPolygons = [];
            
            const valid = allScans.filter(p =>
                p.latitude && p.longitude &&
                p.latitude !== 0 && p.longitude !== 0
            );
            if (valid.length === 0) return;
            
            const zoom = map.getZoom();
            const clusterDist = getClusterDistance(zoom);
            const geoClusters = clusterByProximity(valid, clusterDist);
            const isJobSiteMode = zoom <= 14;
            const mergePx = isJobSiteMode ? 120 : 100;
            const clusters = mergeOverlappingClusters(geoClusters, mergePx);
            const bounds = L.latLngBounds();
            const uniqueMasons = [...new Set(valid.map(p => p.mason_id || p.masonId))];
            
            clusters.forEach((cluster, clusterIndex) => {
                const avgLat = cluster.reduce((s, p) => s + p.latitude, 0) / cluster.length;
                const avgLng = cluster.reduce((s, p) => s + p.longitude, 0) / cluster.length;
                const latlng = [avgLat, avgLng];
                
                const placementItems = cluster.filter(p => (p.scan_type || p.scanType || 'placement') !== 'pallet');
                const palletItems = cluster.filter(p => (p.scan_type || p.scanType || 'placement') === 'pallet');
                const pCount = placementItems.length;
                const kCount = palletItems.length;
                const total = cluster.length;
                const hasBoth = pCount > 0 && kCount > 0;
                const palletOnly = pCount === 0 && kCount > 0;
                
                const masons = [...new Set(cluster.map(p => p.mason_id || p.masonId))];
                const primaryMason = masons[0];
                const masonIndex = uniqueMasons.indexOf(primaryMason);
                const bgStyle = getMasonGradient(cluster, uniqueMasons);
                const popupColor = masonIndex >= 0 ? masonColors[masonIndex % masonColors.length] : '#555';
                
                let innerHtml, markerW, pinHeight;
                
                if (isJobSiteMode) {
                    // === JOB SITE MODE: neutral square-rounded bubble with "Job Site #N" ===
                    const siteNum = clusterIndex + 1;
                    const bSize = 68;
                    markerW = 160;
                    pinHeight = bSize + 12;
                    
                    // Toolbox SVG icon
                    const toolSvg = `<svg viewBox="0 0 24 24" width="30" height="30" style="opacity:0.95;flex-shrink:0;"><path d="M22 8h-4V6c0-1.1-.9-2-2-2H8C6.9 4 6 4.9 6 6v2H2c-1.1 0-2 .9-2 2v4h4v-2h2v2h12v-2h2v2h4v-4c0-1.1-.9-2-2-2zM8 6h8v2H8V6zm14 12v2c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2v-2h4v-2h2v2h12v-2h2v2h4z" fill="white" opacity="0.95"/></svg>`;
                    
                    innerHtml = `
                        <div style="
                            height:${bSize}px;
                            border-radius:10px;
                            background:#5a6577;
                            border:3px solid white;
                            display:flex;align-items:center;justify-content:center;
                            padding:0 16px;gap:10px;
                        ">
                            ${toolSvg}
                            <span style="color:white;font-weight:800;font-size:18px;line-height:1;text-shadow:0 1px 2px rgba(0,0,0,0.5);white-space:nowrap;">Job Site ${siteNum}</span>
                        </div>
                        <div style="width:0;height:0;border-left:8px solid transparent;border-right:8px solid transparent;border-top:12px solid white;margin-top:-1px;"></div>`;
                } else {
                    // === DETAILED MODE: individual brick/pallet icons ===
                    const bubbleSize = Math.max(36, Math.min(64, 28 + Math.log2(total + 1) * 8));
                    
                    // Brick SVG
                    const brickSvg = `<svg viewBox="0 0 24 18" width="${bubbleSize * 0.5}" height="${bubbleSize * 0.38}" style="opacity:0.9;"><rect x="0" y="0" width="11" height="5" rx="0.5" fill="white" opacity="0.9"/><rect x="13" y="0" width="11" height="5" rx="0.5" fill="white" opacity="0.9"/><rect x="0" y="6.5" width="5" height="5" rx="0.5" fill="white" opacity="0.9"/><rect x="7" y="6.5" width="10" height="5" rx="0.5" fill="white" opacity="0.9"/><rect x="19" y="6.5" width="5" height="5" rx="0.5" fill="white" opacity="0.9"/><rect x="0" y="13" width="11" height="5" rx="0.5" fill="white" opacity="0.9"/><rect x="13" y="13" width="11" height="5" rx="0.5" fill="white" opacity="0.9"/></svg>`;
                    
                    // Pallet SVG
                    const palletSvg = `<svg viewBox="0 0 32 32" width="${bubbleSize * 0.45}" height="${bubbleSize * 0.45}" style="opacity:0.9;"><rect x="1" y="3" width="30" height="4" rx="1" fill="white" opacity="0.9"/><rect x="1" y="13" width="30" height="4" rx="1" fill="white" opacity="0.9"/><rect x="1" y="23" width="30" height="4" rx="1" fill="white" opacity="0.9"/><rect x="3" y="8" width="2" height="4" fill="white" opacity="0.5"/><rect x="15" y="8" width="2" height="4" fill="white" opacity="0.5"/><rect x="27" y="8" width="2" height="4" fill="white" opacity="0.5"/><rect x="3" y="18" width="2" height="4" fill="white" opacity="0.5"/><rect x="15" y="18" width="2" height="4" fill="white" opacity="0.5"/><rect x="27" y="18" width="2" height="4" fill="white" opacity="0.5"/></svg>`;
                    
                    if (hasBoth) {
                        // White bubble container with two separate colored square icons inside
                        const placementBg = getMasonGradient(placementItems, uniqueMasons);
                        const palletBg = getMasonGradient(palletItems, uniqueMasons);
                        const iconSize = bubbleSize - 6;
                        const gap = 6;
                        markerW = iconSize * 2 + gap + 16;
                        pinHeight = bubbleSize + 18;
                        innerHtml = `
                            <div style="
                                display:flex;align-items:center;justify-content:center;
                                border-radius:8px;
                                background:white;
                                padding:5px;
                                gap:${gap}px;
                            ">
                                <div style="
                                    width:${iconSize}px;height:${iconSize}px;
                                    border-radius:5px;
                                    background:${placementBg};
                                    display:flex;flex-direction:column;align-items:center;justify-content:center;
                                ">
                                    ${brickSvg}
                                    <span style="color:white;font-weight:800;font-size:${pCount > 99 ? 9 : 11}px;line-height:1;margin-top:2px;text-shadow:0 1px 2px rgba(0,0,0,0.5);">${pCount}</span>
                                </div>
                                <div style="
                                    width:${iconSize}px;height:${iconSize}px;
                                    border-radius:5px;
                                    background:${palletBg};
                                    display:flex;flex-direction:column;align-items:center;justify-content:center;
                                ">
                                    ${palletSvg}
                                    <span style="color:white;font-weight:800;font-size:${kCount > 99 ? 9 : 11}px;line-height:1;margin-top:2px;text-shadow:0 1px 2px rgba(0,0,0,0.5);">${kCount}</span>
                                </div>
                            </div>
                            <div style="width:0;height:0;border-left:8px solid transparent;border-right:8px solid transparent;border-top:12px solid white;margin-top:-1px;"></div>`;
                    } else if (palletOnly) {
                        markerW = bubbleSize;
                        pinHeight = bubbleSize + 12;
                        innerHtml = `
                            <div style="
                                width:${bubbleSize}px;height:${bubbleSize}px;
                                border-radius:6px;
                                background:${bgStyle};
                                border:3px solid white;
                                display:flex;flex-direction:column;align-items:center;justify-content:center;
                            ">
                                ${palletSvg}
                                <span style="color:white;font-weight:800;font-size:${kCount > 99 ? 10 : 12}px;line-height:1;margin-top:2px;text-shadow:0 1px 2px rgba(0,0,0,0.5);">${kCount}</span>
                            </div>
                            <div style="width:0;height:0;border-left:8px solid transparent;border-right:8px solid transparent;border-top:12px solid white;margin-top:-1px;"></div>`;
                    } else {
                        markerW = bubbleSize;
                        pinHeight = bubbleSize + 12;
                        innerHtml = `
                            <div style="
                                width:${bubbleSize}px;height:${bubbleSize}px;
                                border-radius:6px;
                                background:${bgStyle};
                                border:3px solid white;
                                display:flex;flex-direction:column;align-items:center;justify-content:center;
                            ">
                                ${brickSvg}
                                <span style="color:white;font-weight:800;font-size:${pCount > 99 ? 10 : 12}px;line-height:1;margin-top:2px;text-shadow:0 1px 2px rgba(0,0,0,0.5);">${pCount}</span>
                            </div>
                            <div style="width:0;height:0;border-left:8px solid transparent;border-right:8px solid transparent;border-top:12px solid white;margin-top:-1px;"></div>`;
                    }
                    
                    if (!pinHeight) pinHeight = 48;
                }

                const icon = L.divIcon({
                    className: 'pallet-bubble-marker',
                    html: `<div class="combined-pin-inner" style="
                        display:flex;flex-direction:column;align-items:center;
                        cursor:pointer;filter:drop-shadow(0 3px 6px rgba(0,0,0,0.35));
                        transform:scale(0.5);transition:transform 0.2s ease;transform-origin:bottom center;
                    ">
                        ${innerHtml}
                    </div>`,
                    iconSize: [markerW, pinHeight],
                    iconAnchor: [markerW / 2, pinHeight]
                });
                
                const marker = L.marker(latlng, { icon: icon });
                marker.on('mouseover', function() {
                    const el = this._icon.querySelector('.combined-pin-inner');
                    if (el) { el.style.transform = 'scale(1)'; this._icon.style.zIndex = 9999; }
                });
                marker.on('mouseout', function() {
                    const el = this._icon.querySelector('.combined-pin-inner');
                    if (el) { el.style.transform = 'scale(0.5)'; this._icon.style.zIndex = ''; }
                });
                
                // Popup with full breakdown
                const avgAlt = cluster.reduce((s, p) => s + (p.altitude || 0), 0) / cluster.length;
                const timeRange = cluster.length > 1
                    ? `${new Date(Math.min(...cluster.map(p => p.timestamp))).toLocaleString()} \u2014 ${new Date(Math.max(...cluster.map(p => p.timestamp))).toLocaleString()}`
                    : new Date(cluster[0].timestamp).toLocaleString();
                const masonBreakdown = masons.map(m => {
                    const c = cluster.filter(p => (p.mason_id || p.masonId) === m).length;
                    const mi = uniqueMasons.indexOf(m);
                    const mc = mi >= 0 ? masonColors[mi % masonColors.length] : '#555';
                    return `<span style="color:${mc};font-weight:bold;">${m}</span>: ${c} scan${c > 1 ? 's' : ''}`;
                }).join('<br>');
                
                const siteLabel = isJobSiteMode ? `<h3 style="margin:0 0 4px 0;color:#5a6577;">Job Site ${clusterIndex + 1}</h3>` : '';
                const popupContent = `
                    <div style="padding:10px;font-family:Arial;min-width:220px;">
                        ${siteLabel}
                        <h3 style="margin:0 0 8px 0;color:${popupColor};">
                            ${total} Scan${total > 1 ? 's' : ''}
                        </h3>
                        ${pCount > 0 ? `<p style="margin:4px 0;font-size:0.9em;"><strong>Placements:</strong> ${pCount}</p>` : ''}
                        ${kCount > 0 ? `<p style="margin:4px 0;font-size:0.9em;"><strong>Pallet:</strong> ${kCount}</p>` : ''}
                        <p style="margin:4px 0;font-size:0.9em;"><strong>Masons:</strong> ${masons.length}</p>
                        <p style="margin:4px 0;font-size:0.9em;"><strong>Location:</strong> ${avgLat.toFixed(6)}, ${avgLng.toFixed(6)}</p>
                        <p style="margin:4px 0;font-size:0.9em;"><strong>Avg Altitude:</strong> ${avgAlt.toFixed(1)} m</p>
                        <p style="margin:4px 0;font-size:0.9em;"><strong>Time:</strong> ${timeRange}</p>
                        <div style="margin-top:8px;padding-top:8px;border-top:1px solid #ddd;">
                            <strong>Mason Breakdown:</strong><br>${masonBreakdown}
                        </div>
                    </div>
                `;
                marker.bindPopup(popupContent, { maxWidth: 400 });
                marker.addTo(markerGroup);
                markers.push(marker);
                bounds.extend(latlng);
            });
            
            if (bounds.isValid() && !isZoomRender) {
                map.fitBounds(bounds, { padding: [50, 50] });
            }
        }
        
        // Render placements as proximity-clustered bubbles at every zoom level
        // Overlapping points always combine so nothing blocks anything
        function renderPlacementBubbles(placements) {
            if (!map || !markerGroup) return;
            
            markerGroup.clearLayers();
            markers = [];
            wallPolygons.forEach(p => p.remove());
            wallPolygons = [];
            
            const validPlacements = placements.filter(p =>
                p.latitude && p.longitude &&
                p.latitude !== 0 && p.longitude !== 0
            );
            if (validPlacements.length === 0) return;
            
            const zoom = map.getZoom();
            const clusterDist = getClusterDistance(zoom);
            const geoClusters = clusterByProximity(validPlacements, clusterDist);
            // Second pass: merge clusters that would visually overlap on screen
            const clusters = mergeOverlappingClusters(geoClusters, 64);
            const bounds = L.latLngBounds();
            const uniqueMasons = [...new Set(validPlacements.map(p => p.mason_id || p.masonId))];
            
            clusters.forEach(cluster => {
                renderPlacementClusterBubble(cluster, uniqueMasons, bounds);
            });
            
            if (bounds.isValid() && !isZoomRender) {
                map.fitBounds(bounds, { padding: [50, 50] });
            }
        }
        
        // Render a cluster of placements as a single bubble pin with brick icon + count
        function renderPlacementClusterBubble(cluster, uniqueMasons, bounds) {
            const avgLat = cluster.reduce((s, p) => s + p.latitude, 0) / cluster.length;
            const avgLng = cluster.reduce((s, p) => s + p.longitude, 0) / cluster.length;
            const latlng = [avgLat, avgLng];
            const count = cluster.length;
            const masons = [...new Set(cluster.map(p => p.mason_id || p.masonId))];
            const primaryMason = masons[0];
            const masonIndex = uniqueMasons.indexOf(primaryMason);
            // Diagonal gradient when multiple masons, solid color for single mason
            const bgStyle = getMasonGradient(cluster, uniqueMasons);
            const popupColor = masonIndex >= 0 ? masonColors[masonIndex % masonColors.length] : '#CC0000';

            // Log scale: 1→32, 5→40, 12→45, 50→56, 200→64 (max 64)
            const bubbleSize = Math.max(32, Math.min(64, 28 + Math.log2(count + 1) * 8));
            const halfSize = bubbleSize / 2;
            const brickSvg = `<svg viewBox="0 0 24 18" width="${bubbleSize * 0.5}" height="${bubbleSize * 0.38}" style="opacity:0.9;"><rect x="0" y="0" width="11" height="5" rx="0.5" fill="white" opacity="0.9"/><rect x="13" y="0" width="11" height="5" rx="0.5" fill="white" opacity="0.9"/><rect x="0" y="6.5" width="5" height="5" rx="0.5" fill="white" opacity="0.9"/><rect x="7" y="6.5" width="10" height="5" rx="0.5" fill="white" opacity="0.9"/><rect x="19" y="6.5" width="5" height="5" rx="0.5" fill="white" opacity="0.9"/><rect x="0" y="13" width="11" height="5" rx="0.5" fill="white" opacity="0.9"/><rect x="13" y="13" width="11" height="5" rx="0.5" fill="white" opacity="0.9"/></svg>`;

            const pinHeight = bubbleSize + 12;
            const icon = L.divIcon({
                className: 'pallet-bubble-marker',
                html: `<div class="placement-pin-inner" style="
                    display:flex;flex-direction:column;align-items:center;
                    cursor:pointer;filter:drop-shadow(0 3px 6px rgba(0,0,0,0.35));
                    transform:scale(0.5);transition:transform 0.2s ease;transform-origin:bottom center;
                ">
                    <div style="
                        width:${bubbleSize}px;height:${bubbleSize}px;
                        border-radius:6px;
                        background:${bgStyle};
                        border:3px solid white;
                        display:flex;flex-direction:column;align-items:center;justify-content:center;
                    ">
                        ${brickSvg}
                        <span style="color:white;font-weight:800;font-size:${count > 99 ? 10 : 12}px;line-height:1;margin-top:2px;text-shadow:0 1px 2px rgba(0,0,0,0.5);">${count}</span>
                    </div>
                    <div style="
                        width:0;height:0;
                        border-left:8px solid transparent;
                        border-right:8px solid transparent;
                        border-top:12px solid white;
                        margin-top:-1px;
                    "></div>
                </div>`,
                iconSize: [bubbleSize, pinHeight],
                iconAnchor: [halfSize, pinHeight]
            });

            const marker = L.marker(latlng, { icon: icon });
            marker.on('mouseover', function() {
                const el = this._icon.querySelector('.placement-pin-inner');
                if (el) { el.style.transform = 'scale(1)'; this._icon.style.zIndex = 9999; }
            });
            marker.on('mouseout', function() {
                const el = this._icon.querySelector('.placement-pin-inner');
                if (el) { el.style.transform = 'scale(0.5)'; this._icon.style.zIndex = ''; }
            });

            const avgAlt = cluster.reduce((s, p) => s + (p.altitude || 0), 0) / cluster.length;
            const timeRange = cluster.length > 1
                ? `${new Date(Math.min(...cluster.map(p => p.timestamp))).toLocaleString()} — ${new Date(Math.max(...cluster.map(p => p.timestamp))).toLocaleString()}`
                : new Date(cluster[0].timestamp).toLocaleString();
            const masonBreakdown = masons.map(m => {
                const c = cluster.filter(p => (p.mason_id || p.masonId) === m).length;
                const mi = uniqueMasons.indexOf(m);
                const mc = mi >= 0 ? masonColors[mi % masonColors.length] : '#CC0000';
                return `<span style="color:${mc};font-weight:bold;">${m}</span>: ${c} brick${c > 1 ? 's' : ''}`;
            }).join('<br>');

            const popupContent = `
                <div style="padding:10px;font-family:Arial;min-width:220px;">
                    <h3 style="margin:0 0 8px 0;color:${popupColor};">
                        ${count} Placement${count > 1 ? 's' : ''}
                    </h3>
                    <p style="margin:4px 0;font-size:0.9em;"><strong>Location:</strong> ${avgLat.toFixed(6)}, ${avgLng.toFixed(6)}</p>
                    <p style="margin:4px 0;font-size:0.9em;"><strong>Avg Altitude:</strong> ${avgAlt.toFixed(1)} m</p>
                    <p style="margin:4px 0;font-size:0.9em;"><strong>Time:</strong> ${timeRange}</p>
                    <div style="margin-top:8px;padding-top:8px;border-top:1px solid #ddd;">
                        <strong>Masons:</strong><br>${masonBreakdown}
                    </div>
                    <div style="margin-top:8px;padding-top:8px;border-top:1px solid #ddd;max-height:150px;overflow-y:auto;">
                        <strong>Scans (${count}):</strong>
                        ${cluster.map((p, i) => `
                            <div style="font-size:0.85em;margin:2px 0;">
                                <strong>${i+1}.</strong> ${p.rfidTag || p.brickNumber} — ${(p.mason_id || p.masonId)} — ${new Date(p.timestamp).toLocaleTimeString()}
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
            marker.bindPopup(popupContent, { maxWidth: 400 });
            marker.addTo(markerGroup);
            markers.push(marker);
            bounds.extend(latlng);
        }
        
        
        // Update map markers
        function updateMapMarkers(placements) {
            if (!map || !markerGroup) return;
            
            // Clear existing markers
            markerGroup.clearLayers();
            markers = [];
            
            // Filter placements with valid GPS
            const validPlacements = placements.filter(p => 
                p.latitude && p.longitude && 
                p.latitude !== 0 && p.longitude !== 0
            );
            
            if (validPlacements.length === 0) {
                alert('No placements with GPS coordinates found');
                return;
            }
            
            // Create bounds for auto-fit
            const bounds = L.latLngBounds();
            
            // Create unique mason ID list to ensure consistent color mapping
            const uniqueMasons = [...new Set(validPlacements.map(p => p.mason_id || p.masonId))];
            
            validPlacements.forEach((placement, idx) => {
                const latlng = [placement.latitude, placement.longitude];
                
                // Get mason color - consistent with chart colors
                const masonId = placement.mason_id || placement.masonId;
                const masonIndex = uniqueMasons.indexOf(masonId);
                const color = masonIndex >= 0 ? 
                    masonColors[masonIndex % masonColors.length] : 
                    '#CC0000';
                
                // Create brick pin icon
                const brickSvg = `<svg viewBox="0 0 24 18" width="22" height="16"><rect x="0" y="0" width="11" height="5" rx="0.5" fill="white" opacity="0.9"/><rect x="13" y="0" width="11" height="5" rx="0.5" fill="white" opacity="0.9"/><rect x="0" y="6.5" width="5" height="5" rx="0.5" fill="white" opacity="0.9"/><rect x="7" y="6.5" width="10" height="5" rx="0.5" fill="white" opacity="0.9"/><rect x="19" y="6.5" width="5" height="5" rx="0.5" fill="white" opacity="0.9"/><rect x="0" y="13" width="11" height="5" rx="0.5" fill="white" opacity="0.9"/><rect x="13" y="13" width="11" height="5" rx="0.5" fill="white" opacity="0.9"/></svg>`;
                const pinSize = 36;
                const pinHt = pinSize + 12;
                const icon = L.divIcon({
                    className: 'pallet-bubble-marker',
                    html: `<div class="placement-pin-inner" style="
                        display:flex;flex-direction:column;align-items:center;
                        cursor:pointer;filter:drop-shadow(0 3px 6px rgba(0,0,0,0.35));
                        transform:scale(0.5);transition:transform 0.2s ease;transform-origin:bottom center;
                    ">
                        <div style="
                            width:${pinSize}px;height:${pinSize}px;
                            border-radius:6px;
                            background:${color};
                            border:3px solid white;
                            display:flex;align-items:center;justify-content:center;
                        ">
                            ${brickSvg}
                        </div>
                        <div style="
                            width:0;height:0;
                            border-left:8px solid transparent;
                            border-right:8px solid transparent;
                            border-top:12px solid white;
                            margin-top:-1px;
                        "></div>
                    </div>`,
                    iconSize: [pinSize, pinHt],
                    iconAnchor: [pinSize / 2, pinHt]
                });
                
                // Create marker
                const marker = L.marker(latlng, { icon: icon });
                marker.on('mouseover', function() {
                    const el = this._icon.querySelector('.placement-pin-inner');
                    if (el) { el.style.transform = 'scale(1)'; this._icon.style.zIndex = 9999; }
                });
                marker.on('mouseout', function() {
                    const el = this._icon.querySelector('.placement-pin-inner');
                    if (el) { el.style.transform = 'scale(0.5)'; this._icon.style.zIndex = ''; }
                });
                
                // Create popup content
                const altitude = placement.altitude || 0;
                const popupContent = `
                    <div style="padding: 10px; font-family: Arial; min-width: 200px;">
                        <h3 style="margin: 0 0 10px 0; color: ${color};">${masonId || 'Unknown Mason'}</h3>
                        <p style="margin: 5px 0;"><strong>RFID:</strong> ${placement.rfidTag || placement.brickNumber}</p>
                        <p style="margin: 5px 0;"><strong>Time:</strong> ${new Date(placement.timestamp).toLocaleString()}</p>
                        <p style="margin: 5px 0;"><strong>Location:</strong> ${placement.latitude.toFixed(6)}, ${placement.longitude.toFixed(6)}</p>
                        <p style="margin: 5px 0;"><strong>Altitude:</strong> ${altitude.toFixed(1)} m</p>
                        <p style="margin: 5px 0;"><strong>Accuracy:</strong> Â±${placement.accuracy ? placement.accuracy.toFixed(1) : '999'} m</p>
                        ${placement.rssiAvg ? `<p style="margin: 5px 0;"><strong>RSSI:</strong> ${placement.rssiAvg} dBm</p>` : ''}
                    </div>
                `;
                
                marker.bindPopup(popupContent);
                marker.addTo(markerGroup);
                markers.push(marker);
                bounds.extend(latlng);
            });
            
            // Fit map to show all markers
            if (validPlacements.length === 1) {
                map.setView(bounds.getCenter(), 15);
            } else {
                map.fitBounds(bounds, { padding: [50, 50] });
            }
        }
        
        // Fit map bounds to show all markers
        function fitMapBounds() {
            if (!map || markers.length === 0) return;
            
            const bounds = L.latLngBounds();
            markers.forEach(marker => {
                bounds.extend(marker.getLatLng());
            });
            
            if (markers.length === 1) {
                map.setView(bounds.getCenter(), 15);
            } else {
                map.fitBounds(bounds, { padding: [50, 50] });
            }
        }
        
        // Refresh map data
        function refreshMapData() {
            loadMapData();
        }

        // Map mode filter toggle
        function setMapFilter(filter) {
            mapFilter = filter;
            ['All', 'Placement', 'Pallet'].forEach(name => {
                const btn = document.getElementById('mapFilter' + name);
                if (btn) {
                    const isActive = name.toLowerCase() === filter || (name === 'All' && filter === 'all');
                    btn.style.background = isActive ? '#2D3436' : 'transparent';
                    btn.style.color = isActive ? 'white' : '#555';
                }
            });
            loadMapData();
        }

        // Render pallet scans as clustered bubbles with pallet icon
        function updateMapWithPalletBubbles(placements) {
            if (!map || !markerGroup) return;

            markerGroup.clearLayers();
            markers = [];
            wallPolygons.forEach(p => p.remove());
            wallPolygons = [];

            const validPlacements = placements.filter(p =>
                p.latitude && p.longitude &&
                p.latitude !== 0 && p.longitude !== 0
            );

            if (validPlacements.length === 0) {
                return;
            }

            // Cluster pallet scans by proximity (zoom-based distance)
            const palletClusterDist = getClusterDistance(map.getZoom()) * 1.5;
            const clusters = [];
            const visited = new Set();
            const sorted = [...validPlacements].sort((a, b) => a.timestamp - b.timestamp);

            sorted.forEach((placement, idx) => {
                if (visited.has(idx)) return;
                const cluster = [placement];
                const queue = [placement];
                visited.add(idx);

                while (queue.length > 0) {
                    const current = queue.shift();
                    sorted.forEach((other, otherIdx) => {
                        if (visited.has(otherIdx)) return;
                        const dist = calculateDistance(
                            current.latitude, current.longitude,
                            other.latitude, other.longitude
                        );
                        if (dist <= palletClusterDist) {
                            cluster.push(other);
                            queue.push(other);
                            visited.add(otherIdx);
                        }
                    });
                }
                clusters.push(cluster);
            });

            const bounds = L.latLngBounds();
            const uniqueMasons = [...new Set(validPlacements.map(p => p.mason_id || p.masonId))];

            // Second pass: merge clusters that would visually overlap on screen
            const mergedClusters = mergeOverlappingClusters(clusters, 64);

            mergedClusters.forEach(cluster => {
                // Average position
                const avgLat = cluster.reduce((s, p) => s + p.latitude, 0) / cluster.length;
                const avgLng = cluster.reduce((s, p) => s + p.longitude, 0) / cluster.length;
                const latlng = [avgLat, avgLng];

                const count = cluster.length;
                const masons = [...new Set(cluster.map(p => p.mason_id || p.masonId))];
                const primaryMason = masons[0];
                const masonIndex = uniqueMasons.indexOf(primaryMason);
                // Diagonal gradient when multiple masons
                const bgStyle = getMasonGradient(cluster, uniqueMasons);
                const popupColor = masonIndex >= 0 ? masonColors[masonIndex % masonColors.length] : '#3b82f6';

                // Log scale: 1→32, 5→40, 12→45, 50→56, 200→64 (max 64)
                const bubbleSize = Math.max(32, Math.min(64, 28 + Math.log2(count + 1) * 8));
                const halfSize = bubbleSize / 2;

                // Pallet SVG icon (simplified top-down pallet)
                const palletSvg = `<svg viewBox="0 0 32 32" width="${bubbleSize * 0.45}" height="${bubbleSize * 0.45}" style="opacity:0.9;">
                    <rect x="1" y="3" width="30" height="4" rx="1" fill="white" opacity="0.9"/>
                    <rect x="1" y="13" width="30" height="4" rx="1" fill="white" opacity="0.9"/>
                    <rect x="1" y="23" width="30" height="4" rx="1" fill="white" opacity="0.9"/>
                    <rect x="3" y="8" width="2" height="4" fill="white" opacity="0.5"/>
                    <rect x="15" y="8" width="2" height="4" fill="white" opacity="0.5"/>
                    <rect x="27" y="8" width="2" height="4" fill="white" opacity="0.5"/>
                    <rect x="3" y="18" width="2" height="4" fill="white" opacity="0.5"/>
                    <rect x="15" y="18" width="2" height="4" fill="white" opacity="0.5"/>
                    <rect x="27" y="18" width="2" height="4" fill="white" opacity="0.5"/>
                </svg>`;

                const pinHeight = bubbleSize + 12;
                const icon = L.divIcon({
                    className: 'pallet-bubble-marker',
                    html: `<div class="pallet-pin-inner" style="
                        display:flex;flex-direction:column;align-items:center;
                        cursor:pointer;filter:drop-shadow(0 3px 6px rgba(0,0,0,0.35));
                        transform:scale(0.5);transition:transform 0.2s ease;transform-origin:bottom center;
                    ">
                        <div style="
                            width:${bubbleSize}px;height:${bubbleSize}px;
                            border-radius:6px;
                            background:${bgStyle};
                            border:3px solid white;
                            display:flex;flex-direction:column;align-items:center;justify-content:center;
                            position:relative;
                        ">
                            ${palletSvg}
                            <span style="color:white;font-weight:800;font-size:${count > 99 ? 10 : 12}px;line-height:1;margin-top:1px;text-shadow:0 1px 2px rgba(0,0,0,0.5);">${count}</span>
                        </div>
                        <div style="
                            width:0;height:0;
                            border-left:8px solid transparent;
                            border-right:8px solid transparent;
                            border-top:12px solid white;
                            margin-top:-1px;
                        "></div>
                    </div>`,
                    iconSize: [bubbleSize, pinHeight],
                    iconAnchor: [halfSize, pinHeight]
                });

                const marker = L.marker(latlng, { icon: icon });

                marker.on('mouseover', function() {
                    const el = this._icon.querySelector('.pallet-pin-inner');
                    if (el) { el.style.transform = 'scale(1)'; this._icon.style.zIndex = 9999; }
                });
                marker.on('mouseout', function() {
                    const el = this._icon.querySelector('.pallet-pin-inner');
                    if (el) { el.style.transform = 'scale(0.5)'; this._icon.style.zIndex = ''; }
                });

                // Build popup
                const avgAlt = cluster.reduce((s, p) => s + (p.altitude || 0), 0) / cluster.length;
                const timeRange = cluster.length > 1
                    ? `${new Date(Math.min(...cluster.map(p => p.timestamp))).toLocaleString()} — ${new Date(Math.max(...cluster.map(p => p.timestamp))).toLocaleString()}`
                    : new Date(cluster[0].timestamp).toLocaleString();
                const masonBreakdown = masons.map(m => {
                    const c = cluster.filter(p => (p.mason_id || p.masonId) === m).length;
                    const mi = uniqueMasons.indexOf(m);
                    const mc = mi >= 0 ? masonColors[mi % masonColors.length] : '#3b82f6';
                    return `<span style="color:${mc};font-weight:bold;">${m}</span>: ${c} block${c > 1 ? 's' : ''}`;
                }).join('<br>');

                const popupContent = `
                    <div style="padding:10px;font-family:Arial;min-width:220px;">
                        <h3 style="margin:0 0 8px 0;color:${popupColor};">
                            <span style="background:#3b82f6;color:white;padding:2px 8px;border-radius:4px;font-size:0.75rem;font-weight:700;margin-right:6px;">PALLET</span>
                            ${count} Block${count > 1 ? 's' : ''} Indexed
                        </h3>
                        <p style="margin:4px 0;font-size:0.9em;"><strong>Location:</strong> ${avgLat.toFixed(6)}, ${avgLng.toFixed(6)}</p>
                        <p style="margin:4px 0;font-size:0.9em;"><strong>Avg Altitude:</strong> ${avgAlt.toFixed(1)} m</p>
                        <p style="margin:4px 0;font-size:0.9em;"><strong>Time:</strong> ${timeRange}</p>
                        <div style="margin-top:8px;padding-top:8px;border-top:1px solid #ddd;">
                            <strong>Masons:</strong><br>${masonBreakdown}
                        </div>
                        <div style="margin-top:8px;padding-top:8px;border-top:1px solid #ddd;max-height:150px;overflow-y:auto;">
                            <strong>Scans (${count}):</strong>
                            ${cluster.map((p, i) => `
                                <div style="font-size:0.85em;margin:2px 0;">
                                    <strong>${i+1}.</strong> ${p.rfidTag || p.brickNumber} — ${(p.mason_id || p.masonId)} — ${new Date(p.timestamp).toLocaleTimeString()}
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
                marker.bindPopup(popupContent, { maxWidth: 400 });
                marker.addTo(markerGroup);
                markers.push(marker);
                bounds.extend(latlng);
            });

            if (bounds.isValid() && !isZoomRender) {
                map.fitBounds(bounds, { padding: [50, 50] });
            }
        }
        
        // Add pallet bubbles on top of existing map layers (for "All" mode)
        function addPalletBubblesToMap(placements) {
            if (!map || !markerGroup) return;

            const validPlacements = placements.filter(p =>
                p.latitude && p.longitude &&
                p.latitude !== 0 && p.longitude !== 0
            );
            if (validPlacements.length === 0) return;

            // Cluster pallet scans by proximity (zoom-based distance)
            const palletClusterDist = getClusterDistance(map.getZoom()) * 1.5;
            const clusters = [];
            const visited = new Set();
            const sorted = [...validPlacements].sort((a, b) => a.timestamp - b.timestamp);

            sorted.forEach((placement, idx) => {
                if (visited.has(idx)) return;
                const cluster = [placement];
                const queue = [placement];
                visited.add(idx);

                while (queue.length > 0) {
                    const current = queue.shift();
                    sorted.forEach((other, otherIdx) => {
                        if (visited.has(otherIdx)) return;
                        const dist = calculateDistance(
                            current.latitude, current.longitude,
                            other.latitude, other.longitude
                        );
                        if (dist <= palletClusterDist) {
                            cluster.push(other);
                            queue.push(other);
                            visited.add(otherIdx);
                        }
                    });
                }
                clusters.push(cluster);
            });

            const uniqueMasons = [...new Set(validPlacements.map(p => p.mason_id || p.masonId))];
            const bounds = markers.length > 0 ? L.latLngBounds(markers.map(m => m.getLatLng())) : L.latLngBounds();

            // Second pass: merge clusters that would visually overlap on screen
            const mergedClusters = mergeOverlappingClusters(clusters, 64);

            mergedClusters.forEach(cluster => {
                const avgLat = cluster.reduce((s, p) => s + p.latitude, 0) / cluster.length;
                const avgLng = cluster.reduce((s, p) => s + p.longitude, 0) / cluster.length;
                const latlng = [avgLat, avgLng];
                const count = cluster.length;
                const masons = [...new Set(cluster.map(p => p.mason_id || p.masonId))];
                const primaryMason = masons[0];
                const masonIndex = uniqueMasons.indexOf(primaryMason);
                // Diagonal gradient when multiple masons
                const bgStyle = getMasonGradient(cluster, uniqueMasons);
                const popupColor = masonIndex >= 0 ? masonColors[masonIndex % masonColors.length] : '#3b82f6';

                // Log scale: 1→32, 5→40, 12→45, 50→56, 200→64 (max 64)
                const bubbleSize = Math.max(32, Math.min(64, 28 + Math.log2(count + 1) * 8));
                const halfSize = bubbleSize / 2;

                const palletSvg = `<svg viewBox="0 0 32 32" width="${bubbleSize * 0.45}" height="${bubbleSize * 0.45}" style="opacity:0.9;">
                    <rect x="1" y="3" width="30" height="4" rx="1" fill="white" opacity="0.9"/>
                    <rect x="1" y="13" width="30" height="4" rx="1" fill="white" opacity="0.9"/>
                    <rect x="1" y="23" width="30" height="4" rx="1" fill="white" opacity="0.9"/>
                    <rect x="3" y="8" width="2" height="4" fill="white" opacity="0.5"/>
                    <rect x="15" y="8" width="2" height="4" fill="white" opacity="0.5"/>
                    <rect x="27" y="8" width="2" height="4" fill="white" opacity="0.5"/>
                    <rect x="3" y="18" width="2" height="4" fill="white" opacity="0.5"/>
                    <rect x="15" y="18" width="2" height="4" fill="white" opacity="0.5"/>
                    <rect x="27" y="18" width="2" height="4" fill="white" opacity="0.5"/>
                </svg>`;

                const pinHeight = bubbleSize + 12;
                const icon = L.divIcon({
                    className: 'pallet-bubble-marker',
                    html: `<div class="pallet-pin-inner" style="
                        display:flex;flex-direction:column;align-items:center;
                        cursor:pointer;filter:drop-shadow(0 3px 6px rgba(0,0,0,0.35));
                        transform:scale(0.5);transition:transform 0.2s ease;transform-origin:bottom center;
                    ">
                        <div style="
                            width:${bubbleSize}px;height:${bubbleSize}px;
                            border-radius:6px;
                            background:${bgStyle};
                            border:3px solid white;
                            display:flex;flex-direction:column;align-items:center;justify-content:center;
                        ">
                            ${palletSvg}
                            <span style="color:white;font-weight:800;font-size:${count > 99 ? 10 : 12}px;line-height:1;margin-top:1px;text-shadow:0 1px 2px rgba(0,0,0,0.5);">${count}</span>
                        </div>
                        <div style="
                            width:0;height:0;
                            border-left:8px solid transparent;
                            border-right:8px solid transparent;
                            border-top:12px solid white;
                            margin-top:-1px;
                        "></div>
                    </div>`,
                    iconSize: [bubbleSize, pinHeight],
                    iconAnchor: [halfSize, pinHeight]
                });

                const marker = L.marker(latlng, { icon: icon });

                marker.on('mouseover', function() {
                    const el = this._icon.querySelector('.pallet-pin-inner');
                    if (el) { el.style.transform = 'scale(1)'; this._icon.style.zIndex = 9999; }
                });
                marker.on('mouseout', function() {
                    const el = this._icon.querySelector('.pallet-pin-inner');
                    if (el) { el.style.transform = 'scale(0.5)'; this._icon.style.zIndex = ''; }
                });

                const avgAlt = cluster.reduce((s, p) => s + (p.altitude || 0), 0) / cluster.length;
                const timeRange = cluster.length > 1
                    ? `${new Date(Math.min(...cluster.map(p => p.timestamp))).toLocaleString()} \u2014 ${new Date(Math.max(...cluster.map(p => p.timestamp))).toLocaleString()}`
                    : new Date(cluster[0].timestamp).toLocaleString();
                const masonBreakdown = masons.map(m => {
                    const c = cluster.filter(p => (p.mason_id || p.masonId) === m).length;
                    const mi = uniqueMasons.indexOf(m);
                    const mc = mi >= 0 ? masonColors[mi % masonColors.length] : '#3b82f6';
                    return `<span style="color:${mc};font-weight:bold;">${m}</span>: ${c} block${c > 1 ? 's' : ''}`;
                }).join('<br>');

                const popupContent = `
                    <div style="padding:10px;font-family:Arial;min-width:220px;">
                        <h3 style="margin:0 0 8px 0;color:${popupColor};">
                            <span style="background:#3b82f6;color:white;padding:2px 8px;border-radius:4px;font-size:0.75rem;font-weight:700;margin-right:6px;">PALLET</span>
                            ${count} Block${count > 1 ? 's' : ''} Indexed
                        </h3>
                        <p style="margin:4px 0;font-size:0.9em;"><strong>Location:</strong> ${avgLat.toFixed(6)}, ${avgLng.toFixed(6)}</p>
                        <p style="margin:4px 0;font-size:0.9em;"><strong>Avg Altitude:</strong> ${avgAlt.toFixed(1)} m</p>
                        <p style="margin:4px 0;font-size:0.9em;"><strong>Time:</strong> ${timeRange}</p>
                        <div style="margin-top:8px;padding-top:8px;border-top:1px solid #ddd;">
                            <strong>Masons:</strong><br>${masonBreakdown}
                        </div>
                    </div>
                `;
                marker.bindPopup(popupContent, { maxWidth: 400 });
                marker.addTo(markerGroup);
                markers.push(marker);
                bounds.extend(latlng);
            });

            if (bounds.isValid() && !isZoomRender) {
                map.fitBounds(bounds, { padding: [50, 50] });
            }
        }
        
        // ============================================
        // USER MANAGEMENT (Admin only)
        // ============================================
        
        function populateUserManagement(users) {
            const tbody = document.getElementById('userManagementBody');
            if (!tbody) return;
            

            
            if (!users || users.length === 0) {
                tbody.innerHTML = '<tr><td colspan="5" style="padding: 20px; text-align: center; color: #999;">No users found.</td></tr>';
                return;
            }
            
            const currentMason = localStorage.getItem('dashboard_masonId');
            
            tbody.innerHTML = users.map(user => {
                const isCurrentUser = user.masonId === currentMason;
                const roleBadge = getRoleBadge(user.role);
                const canChangeRole = !isCurrentUser && (isSuperAdmin || (isCompanyAdmin && user.role !== 'super_admin'));
                
                let actionsHtml = '';
                if (canChangeRole) {
                    if (user.role === 'user') {
                        actionsHtml = `<button onclick="changeUserRole('${escapeHtml(user.masonId)}', 'company_admin')" 
                            style="padding: 6px 12px; background: #0984E3; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.85rem;">
                            Promote to Admin</button>`;
                    } else if (user.role === 'company_admin') {
                        actionsHtml = `<button onclick="changeUserRole('${escapeHtml(user.masonId)}', 'user')" 
                            style="padding: 6px 12px; background: #636E72; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.85rem;">
                            Remove Admin</button>`;
                    }
                    if (isSuperAdmin && user.role !== 'super_admin') {
                        actionsHtml += ` <button onclick="changeUserRole('${escapeHtml(user.masonId)}', 'super_admin')" 
                            style="padding: 6px 12px; background: #CC0000; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.85rem;">
                            Make Super Admin</button>`;
                    }
                } else if (isCurrentUser) {
                    actionsHtml = '<span style="color: #999; font-style: italic;">You</span>';
                }
                
                return `<tr style="border-bottom: 1px solid #eee;">
                    <td style="padding: 12px 16px; font-weight: ${isCurrentUser ? '700' : '400'};">${escapeHtml(user.username)}</td>
                    <td style="padding: 12px 16px; font-family: monospace; color: #636E72;">${escapeHtml(user.masonId)}</td>
                    <td style="padding: 12px 16px;">${escapeHtml(user.company)}</td>
                    <td style="padding: 12px 16px;">${roleBadge}</td>
                    <td style="padding: 12px 16px;">${actionsHtml}</td>
                </tr>`;
            }).join('');
        }
        
        function getRoleBadge(role) {
            switch(role) {
                case 'super_admin':
                    return '<span style="background: #CC0000; color: white; padding: 4px 10px; border-radius: 12px; font-size: 0.8rem; font-weight: 600;">Super Admin</span>';
                case 'company_admin':
                    return '<span style="background: #0984E3; color: white; padding: 4px 10px; border-radius: 12px; font-size: 0.8rem; font-weight: 600;">Company Admin</span>';
                default:
                    return '<span style="background: #DFE6E9; color: #2D3436; padding: 4px 10px; border-radius: 12px; font-size: 0.8rem;">User</span>';
            }
        }
        
        async function changeUserRole(masonId, newRole) {
            const roleName = newRole === 'super_admin' ? 'Super Admin' : newRole === 'company_admin' ? 'Company Admin' : 'User';
            if (!confirm(`Change this user's role to ${roleName}?`)) return;
            
            try {
                const response = await authFetch(`${API_BASE}/api/users/${encodeURIComponent(masonId)}/role`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ role: newRole })
                });
                const data = await response.json();
                
                if (data.success) {
                    // Reload user list to reflect changes
                    await loadMasons();
                    alert(`Role updated to ${roleName} successfully.`);
                } else {
                    alert('Error: ' + (data.message || 'Failed to update role'));
                }
            } catch (err) {
                console.error('Error changing role:', err);
                alert('Failed to update role. Check console for details.');
            }
        }
        
        // Initialize dashboard
        async function initDashboard() {
            try {
                // Show manage users in cog menu if admin
                if (isAnyAdmin) {
                    const manageBtn = document.getElementById('manageUsersBtn');
                    if (manageBtn) manageBtn.style.display = '';
                }
                
                await loadMasons();
                await refreshData();
                await loadPlacements();
                
                // Auto-refresh stats every 30 seconds (reduced from 10)
                refreshInterval = setInterval(() => {
                    refreshData();
                }, 30000);
                // Check for new placements every 5 seconds (reduced from 2)
                setInterval(loadPlacements, 5000);
            } catch (error) {
                console.error('Failed to initialize dashboard:', error);
                showError('Failed to initialize dashboard: ' + error.message);
                document.getElementById('loading').style.display = 'none';
            }
        }
        
        // Load all masons from /api/users endpoint (company-scoped based on role)
        async function loadMasons() {
            try {
                const response = await authFetch(`${API_BASE}/api/users`);
                const data = await response.json();
                
                if (data.success && data.users && data.users.length > 0) {
                    allMasons = data.users;
                    const select = document.getElementById('masonSelect');
                    const companyLabel = isCompanyAdmin && userCompany ? ` (${escapeHtml(userCompany.name)})` : '';
                    select.innerHTML = `<option value="">All Users${companyLabel}</option>`;
                    
                    data.users.forEach(user => {
                        const option = document.createElement('option');
                        option.value = user.masonId;
                        const roleTag = user.role === 'company_admin' ? ' ★' : user.role === 'super_admin' ? ' ◆' : '';
                        option.textContent = user.username + roleTag;
                        select.appendChild(option);
                    });
                    
                    // Also populate the modal mason select
                    const modalSelect = document.getElementById('modalMasonSelect');
                    if (modalSelect) {
                        modalSelect.innerHTML = `<option value="ALL">All Users${companyLabel}</option>`;
                        data.users.forEach(user => {
                            const option = document.createElement('option');
                            option.value = user.masonId;
                            option.textContent = user.username;
                            modalSelect.appendChild(option);
                        });
                    }
                    
                    // Populate admin user management table if admin
                    if (isAnyAdmin) {
                        populateUserManagement(data.users);
                    }
                    
                    currentMasonId = '';
                } else {
                    const select = document.getElementById('masonSelect');
                    select.innerHTML = '<option value="">All Users (No users yet)</option>';
                    allMasons = [];
                    currentMasonId = '';
                }
            } catch (error) {
                console.error('Error loading masons:', error);
                const select = document.getElementById('masonSelect');
                select.innerHTML = '<option value="">All Users (Error)</option>';
                allMasons = [];
                currentMasonId = '';
            }
        }
        
        // Load recent placements
        async function loadPlacements() {
            if (isUpdating) return;
            
            try {
                isUpdating = true;
                const masonId = document.getElementById('masonSelect').value;
                
                if (!masonId) {
                    const response = await authFetch(`${API_BASE}/api/placements/recent?limit=100`);
                    const data = await response.json();
                    
                    if (data.success && data.placements) {
                        // Only update if placement count changed
                        if (data.placements.length !== lastPlacementCount) {
                            lastPlacementCount = data.placements.length;
                            
                            const today = new Date();
                            today.setHours(0, 0, 0, 0);
                            const todayTimestamp = today.getTime();
                            
                            const todayPlacements = data.placements.filter(p => p.timestamp >= todayTimestamp);
                            
                            allPlacements = todayPlacements;
                            updatePlacementLog(allPlacements);
                            // Charts only show actual placements (not pallet scans)
                            const chartPlacements = allPlacements.filter(p => (p.scan_type || p.scanType || 'placement') !== 'pallet');
                            updateLiveChartMultiMason(chartPlacements);
                        }
                    }
                } else {
                    const url = `${API_BASE}/api/placements/mason/${masonId}`;
                    const response = await authFetch(url);
                    const data = await response.json();
                    
                    if (data.success) {
                        if (data.placements.length !== lastPlacementCount) {
                            lastPlacementCount = data.placements.length;
                            
                            const today = new Date();
                            today.setHours(0, 0, 0, 0);
                            const todayTimestamp = today.getTime();
                            
                            const todayPlacements = (data.placements || []).filter(p => p.timestamp >= todayTimestamp);
                            
                            allPlacements = todayPlacements;
                            updatePlacementLog(allPlacements);
                            // Charts only show actual placements (not pallet scans)
                            const chartPlacements = allPlacements.filter(p => (p.scan_type || p.scanType || 'placement') !== 'pallet');
                            updateLiveChart(chartPlacements);
                        }
                    }
                }
            } catch (error) {
                console.error('Error loading placements:', error);
            } finally {
                isUpdating = false;
            }
        }
        
        function updatePlacementLog(placements) {
            const logDiv = document.getElementById('placementLog');
            
            if (!placements || placements.length === 0) {
                logDiv.innerHTML = '<div class="no-placements">No scans recorded yet</div>';
                return;
            }
            
            // Apply log filter
            let filtered = placements;
            if (logFilter === 'placement') {
                filtered = placements.filter(p => (p.scan_type || p.scanType || 'placement') !== 'pallet');
            } else if (logFilter === 'pallet') {
                filtered = placements.filter(p => (p.scan_type || p.scanType || 'placement') === 'pallet');
            }
            
            if (filtered.length === 0) {
                logDiv.innerHTML = '<div class="no-placements">No ' + (logFilter === 'pallet' ? 'pallet' : 'placement') + ' scans found</div>';
                return;
            }
            
            // Sort by timestamp descending (newest first)
            filtered.sort((a, b) => b.timestamp - a.timestamp);
            
            // Take only the most recent 50
            const recentPlacements = filtered.slice(0, 50);
            
            // Track new placements for animation
            const newIds = new Set(recentPlacements.map(p => p.id));
            const justAdded = [...newIds].filter(id => !lastPlacementIds.has(id));
            lastPlacementIds = newIds;
            
            logDiv.innerHTML = recentPlacements.map(placement => {
                // Use GPS-based timezone if coordinates available
                const date = new Date(placement.timestamp);
                let timeString;
                
                if (placement.latitude && placement.longitude) {
                    // Calculate timezone offset based on longitude (rough approximation)
                    // 15 degrees longitude = 1 hour
                    const timezoneOffset = Math.round(placement.longitude / 15);
                    const localDate = new Date(date.getTime() + (timezoneOffset * 3600000));
                    
                    timeString = localDate.toISOString().replace('T', ' ').substring(0, 19) + 
                                 ` (GPS: ${placement.latitude.toFixed(4)}, ${placement.longitude.toFixed(4)})`;
                } else {
                    timeString = date.toLocaleString('en-US', {
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit',
                        hour12: false
                    });
                }
                
                const isNew = justAdded.includes(placement.id);
                const newClass = isNew ? ' new' : '';
                
                // Display both brickNumber and rfidTag if available
                const brickInfo = placement.brickNumber || placement.rfidTag || 'Unknown';
                const displayText = brickInfo.length > 20 ? 
                    `RFID: ${escapeHtml(brickInfo.substring(brickInfo.length - 8))}` : 
                    `Brick #${escapeHtml(brickInfo)}`;
                
                // Show session + sequence for true ordering (use snake_case column names)
                const sessionInfo = (placement.build_session_id || placement.buildSessionId) && (placement.event_seq || placement.eventSeq)
                    ? `<div style="font-size:0.8rem;color:#888;">Session: ${escapeHtml((placement.build_session_id || placement.buildSessionId).substring(0, 8))}... | Seq: ${placement.event_seq || placement.eventSeq}</div>` 
                    : '';
                
                // Show RSSI and decision status (use snake_case column names)
                const rssiAvg = placement.rssi_avg || placement.rssiAvg;
                const rssiPeak = placement.rssi_peak || placement.rssiPeak;
                const readsInWindow = placement.reads_in_window || placement.readsInWindow;
                const decisionStatus = placement.decision_status || placement.decisionStatus;
                const rssiInfo = rssiAvg ? `<div style="font-size:0.8rem;color:#4ade80;">RSSI: ${rssiAvg}dBm (peak ${rssiPeak}, reads ${readsInWindow})</div>` : '';
                const statusInfo = decisionStatus && decisionStatus !== 'ACCEPTED' ? `<div style="font-size:0.8rem;color:#ff6b6b;font-weight:600;">[${escapeHtml(decisionStatus)}]</div>` : '';
                
                // Scan type badge
                const scanType = placement.scan_type || placement.scanType || 'placement';
                const isPallet = scanType === 'pallet';
                const scanTypeBadge = `<span style="display:inline-block;padding:2px 8px;border-radius:4px;font-size:0.7rem;font-weight:700;text-transform:uppercase;letter-spacing:0.5px;margin-left:8px;${isPallet ? 'background:#3b82f6;color:white;' : 'background:#10b981;color:white;'}">${isPallet ? 'Pallet' : 'Placement'}</span>`;
                
                return `
                    <div class="placement-item${newClass}">
                        <div class="placement-timestamp">${escapeHtml(timeString)}</div>
                        <div class="placement-details">
                            <div class="placement-mason">${escapeHtml(placement.mason_id || placement.masonId || 'Unknown')}${scanTypeBadge}</div>
                            <div class="placement-brick">${displayText}</div>
                            ${sessionInfo}
                            ${rssiInfo}
                            ${statusInfo}
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // Scan log filter toggle
        function setLogFilter(filter) {
            logFilter = filter;
            // Update button styles
            ['All', 'Placement', 'Pallet'].forEach(name => {
                const btn = document.getElementById('filter' + name);
                if (btn) {
                    const isActive = name.toLowerCase() === filter || (name === 'All' && filter === 'all');
                    btn.style.background = isActive ? '#2D3436' : 'transparent';
                    btn.style.color = isActive ? 'white' : '#555';
                }
            });
            // Re-render log with current data
            updatePlacementLog(allPlacements);
        }
        
        // Refresh dashboard data (stats only, don't reload placements)
        async function refreshData() {
            try {
                const response = await authFetch(`${API_BASE}/api/statistics/efficiency`);
                const data = await response.json();
                
                if (!data.success) {
                    throw new Error(data.message || 'Failed to fetch data');
                }
                
                hideError();
                updateDashboard(data);
                document.getElementById('lastUpdated').textContent = new Date().toLocaleString();
                
            } catch (error) {
                console.error('Error refreshing data:', error);
                showError('Failed to refresh data: ' + error.message);
            }
        }
        
        // Update dashboard with new data
        function updateDashboard(data) {
            const masonId = document.getElementById('masonSelect').value || currentMasonId;
            
            // Filter data for selected mason
            let dailyData = data.dailyEfficiency || [];
            let summaryData = data.masonSummary || [];
            
            if (masonId) {
                dailyData = dailyData.filter(d => d.masonId === masonId);
                summaryData = summaryData.filter(s => s.masonId === masonId);
            }
            
            // Update title
            const title = 'Efficiency Dashboard';
            document.getElementById('dashboardTitle').textContent = title;
            
            // Update summary stats
            if (summaryData.length > 0) {
                if (masonId) {
                    // Single mason - show their data
                    const summary = summaryData[0];
                    const placed = summary.placementCount || 0;
                    const indexed = summary.palletCount || 0;
                    document.getElementById('totalPlacements').textContent = placed.toLocaleString();
                    document.getElementById('totalIndexed').textContent = indexed.toLocaleString();
                    document.getElementById('daysWorked').textContent = summary.daysWorked;
                    // Avg per day based on placements only
                    const avgPerDay = summary.daysWorked > 0 ? (placed / summary.daysWorked).toFixed(1) : '0.0';
                    document.getElementById('avgPerDay').textContent = avgPerDay;
                } else {
                    // All masons - aggregate the data
                    const totalPlaced = summaryData.reduce((sum, s) => sum + (s.placementCount || 0), 0);
                    const totalIndexed = summaryData.reduce((sum, s) => sum + (s.palletCount || 0), 0);
                    const maxDaysWorked = Math.max(...summaryData.map(s => s.daysWorked));
                    const avgPerDay = maxDaysWorked > 0 ? (totalPlaced / maxDaysWorked).toFixed(1) : '0.0';
                    
                    document.getElementById('totalPlacements').textContent = totalPlaced.toLocaleString();
                    document.getElementById('totalIndexed').textContent = totalIndexed.toLocaleString();
                    document.getElementById('daysWorked').textContent = maxDaysWorked;
                    document.getElementById('avgPerDay').textContent = avgPerDay;
                }
            } else {
                // No data yet
                document.getElementById('totalPlacements').textContent = '0';
                document.getElementById('totalIndexed').textContent = '0';
                document.getElementById('daysWorked').textContent = '0';
                document.getElementById('avgPerDay').textContent = '0.0';
            }
            
            // Update current efficiency (most recent day)
            if (dailyData.length > 0) {
                if (masonId) {
                    // Single mason
                    const latest = dailyData[0];
                    document.getElementById('currentEfficiency').textContent = latest.placementsPerHour.toFixed(1);
                } else {
                    // All masons - average efficiency across all masons' latest day
                    const avgEfficiency = (dailyData.reduce((sum, d) => sum + d.placementsPerHour, 0) / dailyData.length).toFixed(1);
                    document.getElementById('currentEfficiency').textContent = avgEfficiency;
                }
            } else {
                document.getElementById('currentEfficiency').textContent = '0.0';
            }
            
            // Update daily chart
            updateDailyChart(dailyData);
            
            // Show dashboard
            document.getElementById('loading').style.display = 'none';
            document.getElementById('dashboard').style.display = 'block';
        }
        
        // Update live placements chart for multiple masons
        function updateLiveChartMultiMason(placements) {
            if (!placements || placements.length === 0) return;
            
            const masonGroups = {};
            placements.forEach(p => {
                const masonId = p.mason_id || p.masonId;
                if (!masonId) return;
                if (!masonGroups[masonId]) masonGroups[masonId] = [];
                masonGroups[masonId].push(p);
            });
            
            // Sort mason IDs for consistent ordering
            const sortedMasonIds = Object.keys(masonGroups).sort();
            
            // Create datasets for each mason
            const datasets = sortedMasonIds.map((masonId) => {
                const masonPlacements = masonGroups[masonId].sort((a, b) => a.timestamp - b.timestamp);
                const dataPoints = masonPlacements.map((p, pIdx) => ({
                    x: p.timestamp,
                    y: pIdx + 1
                }));
                
                const color = getMasonColor(masonId, sortedMasonIds);
                
                return {
                    label: masonId,
                    data: dataPoints,
                    borderColor: color,
                    backgroundColor: color + '20', // Add transparency
                    borderWidth: 3,
                    fill: false,
                    tension: 0.4,
                    pointRadius: 3,
                    pointHoverRadius: 6,
                    pointBackgroundColor: color,
                    pointBorderColor: '#fff',
                    pointBorderWidth: 2
                };
            });
            
            // Calculate max Y value across all mason datasets
            const maxY = Math.max(...datasets.map(ds => Math.max(...ds.data.map(p => p.y)))) + 5;
            
            // Update existing chart or create new one
            if (liveChart) {
                liveChart.data.datasets = datasets;
                liveChart.options.scales.y.suggestedMax = maxY;
                liveChart.update('none');
                return;
            }
            
            // Create new chart
            const liveCtx = document.getElementById('liveChart').getContext('2d');
            liveChart = new Chart(liveCtx, {
                type: 'line',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            padding: 12,
                            titleFont: { size: 14 },
                            bodyFont: { size: 13 },
                            callbacks: {
                                title: function(context) {
                                    const date = new Date(context[0].parsed.x);
                                    return date.toLocaleString('en-US', {
                                        month: 'short',
                                        day: 'numeric',
                                        hour: '2-digit',
                                        minute: '2-digit',
                                        second: '2-digit'
                                    });
                                },
                                label: function(context) {
                                    return context.dataset.label + ': ' + context.parsed.y + ' placements';
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            suggestedMax: maxY,
                            title: {
                                display: true,
                                text: 'Cumulative Placements (per Mason)',
                                font: { size: 14, weight: 'bold' }
                            },
                            grid: {
                                color: 'rgba(0, 0, 0, 0.05)'
                            }
                        },
                        x: {
                            type: 'time',
                            time: {
                                unit: 'minute',
                                displayFormats: {
                                    minute: 'HH:mm',
                                    hour: 'HH:mm'
                                },
                                tooltipFormat: 'MMM d, HH:mm:ss'
                            },
                            title: {
                                display: true,
                                text: 'Time',
                                font: { size: 14, weight: 'bold' }
                            },
                            grid: {
                                display: false
                            },
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45,
                                autoSkip: true,
                                maxTicksLimit: 10
                            }
                        }
                    }
                }
            });
        }
        
        // Update live placements chart for single mason
        function updateLiveChart(placements) {
            if (!placements || placements.length === 0) return;
            
            // Sort by timestamp and take last 50
            const sorted = [...placements].sort((a, b) => a.timestamp - b.timestamp).slice(-50);
            
            // Use actual timestamp values for proper time-based spacing
            const dataPoints = sorted.map((p, idx) => ({
                x: p.timestamp, // Use actual timestamp for X-axis
                y: idx + 1      // Cumulative count for Y-axis
            }));
            
            // Update existing chart instead of destroying it
            if (liveChart) {
                liveChart.data.datasets = [{
                    label: 'Cumulative Placements',
                    data: dataPoints,
                    borderColor: '#CC0000',
                    backgroundColor: 'rgba(204, 0, 0, 0.1)',
                    borderWidth: 3,
                    fill: true,
                    tension: 0.4,
                    pointRadius: 3,
                    pointHoverRadius: 6,
                    pointBackgroundColor: '#CC0000',
                    pointBorderColor: '#fff',
                    pointBorderWidth: 2
                }];
                liveChart.options.scales.y.suggestedMax = undefined;
                liveChart.update('none'); // Update without animation for smooth real-time updates
                return;
            }
            
            // Create chart only if it doesn't exist
            const liveCtx = document.getElementById('liveChart').getContext('2d');
            liveChart = new Chart(liveCtx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Cumulative Placements',
                        data: dataPoints,
                        borderColor: '#CC0000',
                        backgroundColor: 'rgba(204, 0, 0, 0.1)',
                        borderWidth: 3,
                        fill: true,
                        tension: 0.4,
                        pointRadius: 3,
                        pointHoverRadius: 6,
                        pointBackgroundColor: '#CC0000',
                        pointBorderColor: '#fff',
                        pointBorderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            padding: 12,
                            titleFont: { size: 14 },
                            bodyFont: { size: 13 },
                            callbacks: {
                                title: function(context) {
                                    const date = new Date(context[0].parsed.x);
                                    return date.toLocaleString('en-US', {
                                        month: 'short',
                                        day: 'numeric',
                                        hour: '2-digit',
                                        minute: '2-digit',
                                        second: '2-digit'
                                    });
                                },
                                label: function(context) {
                                    return 'Total: ' + context.parsed.y + ' placements';
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Cumulative Placements',
                                font: { size: 14, weight: 'bold' }
                            },
                            grid: {
                                color: 'rgba(0, 0, 0, 0.05)'
                            }
                        },
                        x: {
                            type: 'time',
                            time: {
                                unit: 'minute',
                                displayFormats: {
                                    minute: 'HH:mm',
                                    hour: 'HH:mm'
                                },
                                tooltipFormat: 'MMM d, HH:mm:ss'
                            },
                            title: {
                                display: true,
                                text: 'Time',
                                font: { size: 14, weight: 'bold' }
                            },
                            grid: {
                                display: false
                            },
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45,
                                autoSkip: true,
                                maxTicksLimit: 10
                            }
                        }
                    }
                }
            });
        }
        
        // Update daily chart with aggregate data
        function updateDailyChart(dailyData) {
            // Sort by date ascending
            dailyData.sort((a, b) => new Date(a.date) - new Date(b.date));
            
            const masonId = document.getElementById('masonSelect').value;
            
            console.log('updateDailyChart called with:', { masonId, dataCount: dailyData.length, data: dailyData });
            
            // If "All Masons" selected, create bar chart with each mason
            if (!masonId && dailyData.length > 0) {
                // Group by date and mason
                const dateMap = {};
                const masonSet = new Set();
                
                dailyData.forEach(d => {
                    if (!dateMap[d.date]) {
                        dateMap[d.date] = {};
                    }
                    dateMap[d.date][d.masonId] = d.totalPlacements;
                    masonSet.add(d.masonId);
                });
                
                console.log('Grouped data:', { dateMap, masons: Array.from(masonSet) });
                
                const dates = Object.keys(dateMap).sort();
                const masonIds = Array.from(masonSet).sort(); // Sort for consistent ordering
                
                // Create datasets for each mason
                const datasets = masonIds.map((mId) => {
                    const color = getMasonColor(mId, masonIds);
                    
                    return {
                        label: mId,
                        data: dates.map(date => dateMap[date][mId] || 0),
                        backgroundColor: color,
                        borderColor: color,
                        borderWidth: 2,
                        borderRadius: 5
                    };
                });
                
                if (dailyChart) {
                    dailyChart.data.labels = dates;
                    dailyChart.data.datasets = datasets;
                    dailyChart.options.scales.y.suggestedMax = Math.max(...dates.map(date => 
                        Object.values(dateMap[date]).reduce((sum, val) => sum + val, 0)
                    )) + 10;
                    dailyChart.update('none'); // Update without animation
                    return;
                }
                
                // Create stacked bar chart
                const dailyCtx = document.getElementById('dailyChart').getContext('2d');
                dailyChart = new Chart(dailyCtx, {
                    type: 'bar',
                    data: {
                        labels: dates,
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            tooltip: {
                                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                                padding: 12,
                                titleFont: { size: 14 },
                                bodyFont: { size: 13 }
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                stacked: false,  // Changed from true to false for side-by-side bars
                                suggestedMax: Math.max(...dates.map(date => 
                                    Math.max(...Object.values(dateMap[date]))
                                )) + 10,
                                title: {
                                    display: true,
                                    text: 'Total Placements',
                                    font: { size: 14, weight: 'bold' }
                                },
                                grid: {
                                    color: 'rgba(0, 0, 0, 0.05)'
                                }
                            },
                            x: {
                                stacked: false,  // Changed from true to false for side-by-side bars
                                title: {
                                    display: true,
                                    text: 'Date',
                                    font: { size: 14, weight: 'bold' }
                                },
                                grid: {
                                    display: false
                                }
                            }
                        }
                    }
                });
                return;
            }
            
            // Single mason view
            const dates = dailyData.map(d => d.date);
            const totals = dailyData.map(d => d.totalPlacements);
            
            // Get the mason's color (use first data point's masonId)
            const selectedMasonId = dailyData.length > 0 ? dailyData[0].masonId : null;
            const masonColor = selectedMasonId ? getMasonColor(selectedMasonId) : '#2D3436';
            
            // Update existing chart instead of destroying it
            if (dailyChart) {
                dailyChart.data.labels = dates;
                dailyChart.data.datasets = [{
                    label: `${selectedMasonId || 'Total'} Bricks Placed`,
                    data: totals,
                    backgroundColor: masonColor,
                    borderColor: masonColor,
                    borderWidth: 2,
                    borderRadius: 5
                }];
                dailyChart.options.scales.y.stacked = false;
                dailyChart.options.scales.x.stacked = false;
                dailyChart.options.scales.y.suggestedMax = undefined;
                dailyChart.update('none'); // Update without animation
                return;
            }
            
            // Create chart only if it doesn't exist
            const dailyCtx = document.getElementById('dailyChart').getContext('2d');
            dailyChart = new Chart(dailyCtx, {
                type: 'bar',
                data: {
                    labels: dates,
                    datasets: [{
                        label: `${selectedMasonId || 'Total'} Bricks Placed`,
                        data: totals,
                        backgroundColor: masonColor,
                        borderColor: masonColor,
                        borderWidth: 2,
                        borderRadius: 5
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            padding: 12,
                            titleFont: { size: 14 },
                            bodyFont: { size: 13 }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Total Placements',
                                font: { size: 14, weight: 'bold' }
                            },
                            grid: {
                                color: 'rgba(0, 0, 0, 0.05)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Date',
                                font: { size: 14, weight: 'bold' }
                            },
                            grid: {
                                display: false
                            }
                        }
                    }
                }
            });
        }
        
        // Show performance review modal
        function showReportModal() {
            const modal = document.getElementById('reportModal');
            const modalMasonSelect = document.getElementById('modalMasonSelect');
            const currentMasonSelect = document.getElementById('masonSelect');
            
            // Populate modal mason dropdown with current masons
            modalMasonSelect.innerHTML = '<option value="ALL">All Users</option>';
            Array.from(currentMasonSelect.options).forEach(option => {
                if (option.value && option.value !== '') {
                    const opt = document.createElement('option');
                    opt.value = option.value;
                    opt.textContent = option.textContent;
                    if (option.value === currentMasonSelect.value) {
                        opt.selected = true;
                    }
                    modalMasonSelect.appendChild(opt);
                }
            });
            
            modal.classList.add('show');
        }
        
        // Close performance review modal
        function closeReportModal() {
            const modal = document.getElementById('reportModal');
            modal.classList.remove('show');
        }
        
        // Generate report from modal
        function generateReport() {
            const masonId = document.getElementById('modalMasonSelect').value;
            const periodDays = document.getElementById('modalPeriodSelect').value;
            
            // Calculate date range based on selected period
            const endDate = Date.now();
            let startDate;
            
            if (periodDays === 'all') {
                startDate = 0; // Unix epoch
            } else {
                const days = parseInt(periodDays);
                startDate = endDate - (days * 24 * 60 * 60 * 1000);
            }
            
            // Open report in new tab
            const reportUrl = `${API_BASE}/api/report/mason/${masonId}?startDate=${startDate}&endDate=${endDate}`;
            window.open(reportUrl, '_blank');
            
            // Close modal
            closeReportModal();
        }
        
        // Close modal when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('reportModal');
            if (event.target === modal) {
                closeReportModal();
            }
        }
        
        // Show error message
        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }
        
        // Hide error message
        function hideError() {
            document.getElementById('error').style.display = 'none';
        }
        
        // Mason selection change handler
        document.getElementById('masonSelect').addEventListener('change', function() {
            currentMasonId = this.value;
            allPlacements = [];
            lastPlacementIds = new Set();
            lastPlacementCount = 0;
            refreshData();
            loadPlacements();
            
            // Refresh map if it's initialized
            if (map) {
                loadMapData();
            }
        });
        
        // Initialize on page load
        window.addEventListener('DOMContentLoaded', initDashboard);
        
        window.addEventListener('beforeunload', () => {
            if (refreshInterval) {
                clearInterval(refreshInterval);
            }
        });
    </script>
</body>
</html>
